{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n\n    This function implements a robust strategy by:\n    1. Verifying that the required ingredients are in the agent's inventory.\n    2. Consulting the recipe to identify the specific workshop needed.\n    3. Using Breadth-First Search (BFS) to find the shortest, obstacle-free\n       path to an empty cell adjacent to the target workshop.\n    4. Generating a final action to turn the agent towards the workshop.\n    5. Appending the 'USE' action to perform the craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A sequence of integer actions to achieve the crafting goal.\n        \n    Raises:\n        ValueError: If the item is unknown, has no recipe, ingredients are\n                    missing, the required workshop is not on the map, or no\n                    valid path to the workshop exists.\n    \"\"\"\n    # Action constants for clarity\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # 1. Get necessary info from the environment state\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n    inventory = state.inventory\n    start_pos = tuple(state.pos)\n    width, height, _ = grid.shape\n\n    # 2. Look up the recipe and required workshop for the target item\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Item '{item}' not found in the cookbook index.\")\n    \n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n\n    # 3. Check if the agent has the necessary ingredients in its inventory\n    for ingredient_idx, required_count in recipe.items():\n        if isinstance(ingredient_idx, str) and ingredient_idx.startswith('_'):\n            continue  # Skip metadata like '_at'\n        if inventory[ingredient_idx] < required_count:\n            raise ValueError(f\"Missing ingredients for '{item}'.\")\n\n    # 4. Find the specific workshop required by the recipe\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n    \n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Required workshop '{required_workshop_name}' not found on the map.\")\n\n    # 5. Identify all valid target cells (empty cells adjacent to any required workshop)\n    target_cells = set()\n    for ws_pos in workshop_locations:\n        x, y = ws_pos\n        for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            # Check if the neighbor is within grid bounds and is an empty cell\n            if 0 <= nx < width and 0 <= ny < height and grid[nx, ny, :].sum() == 0:\n                target_cells.add((nx, ny))\n    \n    if not target_cells:\n        raise ValueError(f\"No accessible empty cells next to any '{required_workshop_name}'.\")\n\n    # 6. Use Breadth-First Search (BFS) to find the shortest path to a target cell\n    queue = collections.deque([(start_pos, [])])  # Stores (position, path_of_actions)\n    visited = {start_pos}\n    \n    path_to_workshop = None\n    final_agent_pos = None\n    target_workshop_pos = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n        \n        if current_pos in target_cells:\n            path_to_workshop = path\n            final_agent_pos = current_pos\n            # Identify which workshop this cell is adjacent to\n            cx, cy = current_pos\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                wx, wy = cx + dx, cy + dy\n                if 0 <= wx < width and 0 <= wy < height and grid[wx, wy, required_workshop_idx] == 1:\n                    target_workshop_pos = (wx, wy)\n                    break\n            break  # Path found, exit BFS\n\n        # Explore neighbors\n        x, y = current_pos\n        moves = [((0, -1), DOWN), ((0, 1), UP), ((-1, 0), LEFT), ((1, 0), RIGHT)]\n        for (dx, dy), action in moves:\n            next_pos = (x + dx, y + dy)\n            nx, ny = next_pos\n            \n            if (0 <= nx < width and 0 <= ny < height and\n                next_pos not in visited and\n                grid[nx, ny, :].sum() == 0):  # Can only move to empty cells\n                \n                visited.add(next_pos)\n                queue.append((next_pos, path + [action]))\n    \n    if path_to_workshop is None:\n        raise ValueError(f\"Could not find a valid path to a '{required_workshop_name}'.\")\n\n    # 7. Construct the final action sequence\n    actions = list(path_to_workshop)\n    \n    # Add a final action to turn and face the workshop\n    # This works because attempting to move into a blocked cell only changes direction.\n    dx = target_workshop_pos[0] - final_agent_pos[0]\n    dy = target_workshop_pos[1] - final_agent_pos[1]\n\n    if dx == 1:\n        actions.append(RIGHT)\n    elif dx == -1:\n        actions.append(LEFT)\n    elif dy == 1:\n        actions.append(UP)\n    elif dy == -1:\n        actions.append(DOWN)\n\n    # Finally, add the 'USE' action to craft the item\n    actions.append(USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    orient the agent, and craft a specified item.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    unobstructed path to a cell adjacent to the required workshop.\n\n    Args:\n        env (CraftLab): The environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to execute the crafting plan.\n\n    Raises:\n        ValueError: If the item is unknown, cannot be crafted, the required\n                    workshop doesn't exist, or ingredients are missing.\n        RuntimeError: If no path can be found to the workshop.\n    \"\"\"\n    # Action constants for readability, matching the environment's spec\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # 1. Identify the required workshop and check prerequisites from the cookbook\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n\n    if goal_index is None or goal_index not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' is unknown or has no recipe.\")\n\n    recipe = cookbook.recipes[goal_index]\n    \n    # Check if the agent has the necessary ingredients in inventory\n    current_inventory = env._current_state.inventory\n    for ingredient_idx, required_count in recipe.items():\n        if ingredient_idx == '_at':\n            continue\n        if current_inventory[ingredient_idx] < required_count:\n            ingredient_name = cookbook.index.get(ingredient_idx)\n            raise ValueError(\n                f\"Insufficient ingredients for '{item}'. \"\n                f\"Missing {required_count - current_inventory[ingredient_idx]} of '{ingredient_name}'.\"\n            )\n\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 2. Find all instances of the required workshop on the grid\n    grid = env._current_state.grid\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{required_workshop_name}' not found in the environment.\")\n    \n    # Use a set for efficient lookup during pathfinding\n    workshop_locations_set = {tuple(loc) for loc in workshop_locations}\n\n    # 3. Pathfind to a valid cell adjacent to the workshop using BFS\n    start_pos = env._current_state.pos\n    q = collections.deque([(start_pos, [])])  # Queue stores (position, path_list)\n    visited = {start_pos}\n\n    path_to_target = None\n    final_agent_pos = None\n    target_workshop_pos = None\n\n    while q:\n        current_pos, path = q.popleft()\n\n        # Check if the current position is a valid destination (adjacent to a workshop)\n        # Check in a consistent order: UP, DOWN, RIGHT, LEFT\n        for check_dx, check_dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_pos = (current_pos[0] + check_dx, current_pos[1] + check_dy)\n            if neighbor_pos in workshop_locations_set:\n                path_to_target = path\n                final_agent_pos = current_pos\n                target_workshop_pos = neighbor_pos\n                break  # Path found, exit inner loop\n        \n        if path_to_target is not None:\n            break  # Exit BFS main loop\n\n        # If not a destination, explore neighbors to continue the search\n        for action, (move_dx, move_dy) in zip([UP, DOWN, RIGHT, LEFT], [(0, 1), (0, -1), (1, 0), (-1, 0)]):\n            next_pos = (current_pos[0] + move_dx, current_pos[1] + move_dy)\n            nx, ny = next_pos\n\n            # Check grid bounds\n            if not (0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]):\n                continue\n            # Check if already visited\n            if next_pos in visited:\n                continue\n            # Check if the cell is blocked by any object\n            if grid[nx, ny, :].any():\n                continue\n\n            visited.add(next_pos)\n            new_path = path + [action]\n            q.append((next_pos, new_path))\n\n    if path_to_target is None:\n        raise RuntimeError(f\"Cannot find a path to a '{required_workshop_name}'.\")\n\n    # 4. Determine the final action to turn and face the workshop\n    actions = path_to_target\n    \n    # Calculate direction from the agent's final position to the workshop\n    dx = target_workshop_pos[0] - final_agent_pos[0]\n    dy = target_workshop_pos[1] - final_agent_pos[1]\n\n    turn_action = None\n    if (dx, dy) == (0, 1):\n        turn_action = UP\n    elif (dx, dy) == (0, -1):\n        turn_action = DOWN\n    elif (dx, dy) == (1, 0):\n        turn_action = RIGHT\n    elif (dx, dy) == (-1, 0):\n        turn_action = LEFT\n\n    # Add the turn action. In this environment, attempting to move into a\n    # blocked cell (like the workshop) successfully turns the agent.\n    actions.append(turn_action)\n\n    # 5. Add the USE action to perform the craft\n    actions.append(USE)\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    orient the agent, and craft the specified item. This function uses Breadth-First \n    Search (BFS) to find the shortest, obstacle-free path to a location from which \n    the agent can approach and use the workshop with the correct orientation.\n\n    Args:\n        env (CraftLab): The environment instance, providing access to the current state and world data.\n        item (str): The name of the item to craft (e.g., \"plank\", \"axe\").\n\n    Returns:\n        list[int]: A list of action integers representing the plan. Returns an\n                   empty list if crafting is not possible (e.g., no recipe, no\n                   path, or workshop is inaccessible).\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n    \n    # 1. Identify the specific workshop required for the item from the recipe.\n    try:\n        goal_index = cookbook.index[item]\n        if goal_index is None:\n            raise ValueError(f\"Item '{item}' not found in cookbook index.\")\n        recipe = cookbook.recipes.get(goal_index)\n        if recipe is None:\n            raise ValueError(f\"No recipe found for item '{item}'.\")\n        workshop_name = recipe['_at']\n        workshop_idx = cookbook.index[workshop_name]\n    except (KeyError, ValueError):\n        # Crafting is impossible if the item or its recipe doesn't exist.\n        return []\n\n    # Helper mapping from action ID to its (dx, dy) vector.\n    # Note: grid coordinates are (y, x), so vectors are applied as (pos_x+dx, pos_y+dy).\n    action_vectors = {\n        0: (0, -1),  # DOWN\n        1: (0, 1),   # UP\n        2: (-1, 0),  # LEFT\n        3: (1, 0),   # RIGHT\n    }\n    \n    # Pre-calculate a boolean grid of blocked cells for efficient collision checks in BFS.\n    grid_h, grid_w = grid.shape[:2]\n    blocked = np.sum(grid, axis=2) > 0\n\n    # 2. Determine valid \"approach positions\".\n    # An \"approach position\" is a cell from which a single move will place the agent\n    # in a \"stand position\" (adjacent to the workshop) with the correct orientation.\n    # `approach_map` will store {approach_pos: final_move_action}.\n    approach_map = {}\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx])\n\n    for pos_y, pos_x in workshop_locations:\n        workshop_pos = (pos_x, pos_y)\n        \n        # For each workshop, check all 4 directions for a valid approach.\n        for final_move, (dx, dy) in action_vectors.items():\n            # The agent will stand at `stand_pos` to use the workshop.\n            # `stand_pos` is adjacent to `workshop_pos` and must be empty.\n            stand_pos = (workshop_pos[0] - dx, workshop_pos[1] - dy)\n\n            if not (0 <= stand_pos[0] < grid_w and 0 <= stand_pos[1] < grid_h and \\\n                    not blocked[stand_pos[1], stand_pos[0]]):\n                continue\n            \n            # The agent performs `final_move` from `approach_pos` to land on `stand_pos`.\n            # The `approach_pos` must also be empty.\n            approach_pos = (stand_pos[0] - dx, stand_pos[1] - dy)\n\n            if not (0 <= approach_pos[0] < grid_w and 0 <= approach_pos[1] < grid_h and \\\n                    not blocked[approach_pos[1], approach_pos[0]]):\n                continue\n            \n            # This is a valid approach. Store it as a potential BFS goal.\n            if approach_pos not in approach_map:\n                 approach_map[approach_pos] = final_move\n\n    if not approach_map:\n        # No accessible spots found to approach any required workshop.\n        return []\n\n    # 3. Use BFS to find the shortest path to any valid \"approach position\".\n    start_pos = tuple(state.pos)\n    \n    # If the agent is already at an approach position, the plan is simple.\n    if start_pos in approach_map:\n        final_move = approach_map[start_pos]\n        return [final_move, USE_ACTION]\n\n    queue = collections.deque([(start_pos, [])]) # (position, path_list)\n    visited = {start_pos}\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        for action, (dx, dy) in action_vectors.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n            # Basic BFS checks: bounds, visited, and obstacles.\n            if not (0 <= next_pos[0] < grid_w and 0 <= next_pos[1] < grid_h) or \\\n               next_pos in visited or blocked[next_pos[1], next_pos[0]]:\n                continue\n\n            # Check if we have reached one of our goal positions.\n            if next_pos in approach_map:\n                # Path found. Construct the full action sequence.\n                path_to_approach = path + [action]\n                final_move = approach_map[next_pos]\n                return path_to_approach + [final_move, USE_ACTION]\n\n            visited.add(next_pos)\n            queue.append((next_pos, path + [action]))\n\n    # 4. If the queue becomes empty, no path was found.\n    return []\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item.\n\n    This function creates a plan by:\n    1.  Verifying the agent has the necessary ingredients from the recipe.\n    2.  Identifying the specific workshop required for crafting.\n    3.  Finding the closest empty, accessible cell adjacent to an instance of that workshop.\n    4.  Using Breadth-First Search (BFS) to compute the shortest path to that cell,\n        navigating around all obstacles.\n    5.  Ensuring the agent is facing the workshop before crafting, adding a turn\n        maneuver if necessary.\n    6.  Appending the 'USE' action to complete the craft.\n\n    Args:\n        env: The environment instance, providing access to the current state and world info.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of low-level action integers (0-4) to execute the plan.\n                   Returns an empty list if crafting is not possible.\n    \"\"\"\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n\n    # 1. Validate recipe and prerequisites\n    if goal_index is None or goal_index not in cookbook.recipes:\n        return []  # Item is not craftable or does not exist\n    \n    recipe = cookbook.recipes[goal_index]\n    \n    inventory = env._current_state.inventory\n    for ingredient_idx, required_count in recipe.items():\n        if ingredient_idx == '_at':\n            continue\n        if inventory[ingredient_idx] < required_count:\n            return []  # Missing ingredients\n\n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Setup for pathfinding\n    grid = env._current_state.grid\n    grid_dims = grid.shape[:2]  # (height, width), corresponds to (y, x)\n\n    # All non-empty cells are considered obstacles\n    obstacle_mask = grid.sum(axis=2) > 0\n    start_pos_xy = env._current_state.pos\n    start_pos_yx = (start_pos_xy[1], start_pos_xy[0])\n    # The agent's start position is not an obstacle for pathfinding away from it\n    obstacle_mask[start_pos_yx] = False\n\n    workshop_locations_yx = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations_yx.shape[0] == 0:\n        return [] # Required workshop is not in the environment\n\n    # 3. Find all valid target cells (empty cells adjacent to workshops)\n    target_cells_info = {}  # Maps target_pos_yx -> workshop_pos_yx\n    for wy, wx in workshop_locations_yx:\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ny, nx = wy + dy, wx + dx\n            if 0 <= ny < grid_dims[0] and 0 <= nx < grid_dims[1] and not obstacle_mask[ny, nx]:\n                target_cells_info[(ny, nx)] = (wy, wx)\n\n    if not target_cells_info:\n        return [] # No accessible spot next to a workshop\n\n    # 4. Pathfinding with BFS\n    queue = collections.deque([(start_pos_yx, [])])\n    visited = {start_pos_yx}\n    \n    # Map (dy, dx) movement deltas to low-level actions\n    moves = {(-1, 0): 0, (1, 0): 1, (0, -1): 2, (0, 1): 3} # Down, Up, Left, Right\n    \n    path_to_target = None\n    final_agent_pos_yx = None\n    target_workshop_pos_yx = None\n\n    # Check if agent is already at a target location\n    if start_pos_yx in target_cells_info:\n        path_to_target = []\n        final_agent_pos_yx = start_pos_yx\n        target_workshop_pos_yx = target_cells_info[start_pos_yx]\n    else:\n        while queue:\n            (cy, cx), path = queue.popleft()\n            for (dy, dx), action in moves.items():\n                ny, nx = cy + dy, cx + dx\n                neighbor_pos = (ny, nx)\n                \n                if not (0 <= ny < grid_dims[0] and 0 <= nx < grid_dims[1] and neighbor_pos not in visited):\n                    continue\n                visited.add(neighbor_pos)\n\n                if neighbor_pos in target_cells_info:\n                    path_to_target = path + [action]\n                    final_agent_pos_yx = neighbor_pos\n                    target_workshop_pos_yx = target_cells_info[neighbor_pos]\n                    queue.clear()\n                    break\n                \n                if not obstacle_mask[ny, nx]:\n                    queue.append((neighbor_pos, path + [action]))\n            if path_to_target is not None:\n                break\n    \n    if path_to_target is None:\n        return [] # No path found\n\n    final_actions = list(path_to_target)\n\n    # 5. Orient the agent to face the workshop\n    dy = target_workshop_pos_yx[0] - final_agent_pos_yx[0]\n    dx = target_workshop_pos_yx[1] - final_agent_pos_yx[1]\n    required_dir = moves[(dy, dx)]\n    \n    current_dir = env._current_state.dir if not final_actions else final_actions[-1]\n    \n    if current_dir != required_dir:\n        # Re-orient by moving away and then back towards the workshop\n        opposite_dir_delta = (-dy, -dx)\n        opposite_dir = moves[opposite_dir_delta]\n        turn_cell_yx = (final_agent_pos_yx[0] + opposite_dir_delta[0], final_agent_pos_yx[1] + opposite_dir_delta[1])\n        \n        # Check if the cell needed for turning is accessible\n        if 0 <= turn_cell_yx[0] < grid_dims[0] and 0 <= turn_cell_yx[1] < grid_dims[1] and not obstacle_mask[turn_cell_yx]:\n            final_actions.extend([opposite_dir, required_dir])\n        else:\n            return [] # Cannot turn, so the plan fails\n\n    # 6. Add the final 'USE' action\n    final_actions.append(4)\n    \n    return final_actions\n",
  "evaluation_result": [
    3.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    orient the agent, and craft the specified item.\n\n    This function implements a Breadth-First Search (BFS) algorithm to find the\n    shortest path that avoids obstacles. It correctly identifies the specific\n    workshop required by the item's recipe and navigates to an adjacent,\n    empty cell. Crucially, it ensures the agent's final move correctly\n    orients it to face the workshop before issuing the 'USE' command.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers (0-4) to execute.\n\n    Raises:\n        ValueError: If the item is unknown or not craftable.\n        RuntimeError: If no path to a suitable workshop can be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n\n    # 1. Identify the required workshop from the recipe\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' is not craftable or has no recipe.\")\n    \n    recipe = cookbook.recipes[goal_index]\n    if '_at' not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n        \n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Setup grid, agent's position, and obstacle map for pathfinding\n    grid = env._current_state.grid\n    start_pos = tuple(env._current_state.pos)\n    h, w = grid.shape[0], grid.shape[1]\n\n    # A cell is considered blocked if anything occupies it.\n    is_blocked = grid.sum(axis=2) > 0\n\n    # 3. Determine all valid target states for the pathfinding algorithm.\n    # A target state is not just the destination cell, but the cell *before* it,\n    # plus the final action needed to land on the destination cell correctly oriented.\n    # This ensures the agent is facing the workshop before crafting.\n    \n    # action_to_delta maps action indices to (dy, dx) grid movements in numpy's (row, col) format\n    action_to_delta = {\n        0: (1, 0),  # DOWN\n        1: (-1, 0), # UP\n        2: (0, -1), # LEFT\n        3: (0, 1),  # RIGHT\n    }\n    \n    # Maps the relative position of the workshop to the agent's required facing direction\n    # (dy, dx) is (workshop_pos - agent_pos)\n    facing_delta_to_direction = {\n        (1, 0): 0,  # Workshop is below -> face DOWN\n        (-1, 0): 1, # Workshop is above -> face UP\n        (0, -1): 2, # Workshop is left -> face LEFT\n        (0, 1): 3,  # Workshop is right -> face RIGHT\n    }\n\n    penultimate_states = {} # Maps a pre-target position to the final action to take from it\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx] > 0)\n\n    for w_y, w_x in workshop_locations:\n        # For each of the 4 adjacent cells to the workshop...\n        for facing_delta, final_direction in facing_delta_to_direction.items():\n            dy_face, dx_face = facing_delta\n            \n            # This is the target cell (t_pos) the agent must stand on.\n            t_y, t_x = w_y - dy_face, w_x - dx_face\n            t_pos = (t_y, t_x)\n\n            # Target cell must be within bounds and not blocked.\n            if not (0 <= t_y < h and 0 <= t_x < w):\n                continue\n            if is_blocked[t_y, t_x] and t_pos != start_pos:\n                continue\n\n            # To arrive at t_pos with the correct orientation (final_direction),\n            # the agent must come from the penultimate position (p_pos).\n            dy_move, dx_move = action_to_delta[final_direction]\n            p_y, p_x = t_y - dy_move, t_x - dx_move\n            p_pos = (p_y, p_x)\n            \n            # The penultimate cell must also be a valid location to move from.\n            if not (0 <= p_y < h and 0 <= p_x < w):\n                continue\n            if is_blocked[p_y, p_x] and p_pos != start_pos:\n                continue\n            \n            # Store the penultimate position as a goal for our BFS.\n            if p_pos not in penultimate_states:\n                penultimate_states[p_pos] = final_direction\n\n    # 4. Run Breadth-First Search (BFS) to find the shortest path\n    queue = collections.deque([(start_pos, [])]) # (position, path_of_actions)\n    visited = {start_pos}\n\n    path_to_penultimate = None\n    final_action = None\n\n    # Handle edge case where the agent is already at a penultimate position\n    if start_pos in penultimate_states:\n        path_to_penultimate = []\n        final_action = penultimate_states[start_pos]\n\n    while queue and path_to_penultimate is None:\n        (y, x), current_path = queue.popleft()\n\n        for action_idx, (dy, dx) in action_to_delta.items():\n            ny, nx = y + dy, x + dx\n            next_pos = (ny, nx)\n\n            if 0 <= ny < h and 0 <= nx < w and not is_blocked[ny, nx] and next_pos not in visited:\n                visited.add(next_pos)\n                new_path = current_path + [action_idx]\n\n                if next_pos in penultimate_states:\n                    path_to_penultimate = new_path\n                    final_action = penultimate_states[next_pos]\n                    break  # Shortest path found\n                \n                queue.append((next_pos, new_path))\n        if path_to_penultimate is not None:\n            break\n\n    # 5. Assemble the final action sequence\n    if path_to_penultimate is None:\n        raise RuntimeError(f\"Could not find a path to a workshop for crafting '{item}'.\")\n\n    # Full sequence: path to penultimate cell, final move for orientation, then USE\n    full_actions = path_to_penultimate + [final_action, 4] # 4 is USE action\n    return full_actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n\n    This function implements a robust strategy by:\n    1. Identifying the specific workshop required by the item's recipe.\n    2. Finding all empty, accessible cells adjacent to that workshop type.\n    3. Using Breadth-First Search (BFS) to find the shortest, obstacle-free\n       path to one of these adjacent cells.\n    4. Generating actions to turn the agent to face the workshop.\n    5. Appending the 'USE' action to perform the craft.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # 1. Look up item and its recipe to find the required workshop\n    goal_index = cookbook.index[item]\n    if goal_index is None or goal_index not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' is not craftable or does not exist.\")\n\n    recipe = cookbook.recipes[goal_index]\n    workshop_name = recipe['_at']\n    workshop_index = cookbook.index[workshop_name]\n\n    # 2. Get current environment state for pathfinding\n    grid = state.grid\n    # Use (y, x) convention for position, matching numpy's (row, col) indexing\n    start_pos = tuple(state.pos)\n    grid_height, grid_width = grid.shape[0], grid.shape[1]\n\n    # A cell is considered blocked if it contains any object.\n    blocked = grid.sum(axis=2) > 0\n\n    # 3. Find all valid target positions (empty cells adjacent to the workshop)\n    workshop_locations = np.argwhere(grid[:, :, workshop_index])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    valid_targets = set()\n    for ws_pos in workshop_locations:\n        y, x = ws_pos\n        # Check 4 neighbors (UP, DOWN, LEFT, RIGHT)\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            adj_pos = (y + dy, x + dx)\n            # Check if neighbor is within bounds and is not blocked\n            if (0 <= adj_pos[0] < grid_height and\n                0 <= adj_pos[1] < grid_width and\n                not blocked[adj_pos[0], adj_pos[1]]):\n                valid_targets.add(adj_pos)\n\n    if not valid_targets:\n        raise RuntimeError(f\"No accessible cells next to workshop '{workshop_name}'.\")\n\n    # 4. Pathfind using BFS to the nearest valid target cell\n    # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    # Corresponding (dy, dx) deltas for (y, x) coordinates:\n    action_deltas = {\n        0: (1, 0),   # DOWN (y increases)\n        1: (-1, 0),  # UP (y decreases)\n        2: (0, -1),  # LEFT (x decreases)\n        3: (0, 1),   # RIGHT (x increases)\n    }\n    # Reverse mapping from delta to action for the orientation step\n    delta_to_action = {v: k for k, v in action_deltas.items()}\n\n    queue = collections.deque([(start_pos, [])])  # Stores (position, path_of_actions)\n    visited = {start_pos}\n\n    path_to_target = None\n    final_pos = None\n\n    # Handle the case where the agent is already at a target position\n    if start_pos in valid_targets:\n        path_to_target = []\n        final_pos = start_pos\n    else:\n        while queue:\n            current_pos, path = queue.popleft()\n\n            for action, (dy, dx) in action_deltas.items():\n                next_pos = (current_pos[0] + dy, current_pos[1] + dx)\n\n                if not (0 <= next_pos[0] < grid_height and 0 <= next_pos[1] < grid_width):\n                    continue\n                if next_pos in visited:\n                    continue\n                \n                if next_pos in valid_targets:\n                    path_to_target = path + [action]\n                    final_pos = next_pos\n                    queue.clear()  # Path found, stop searching\n                    break\n                \n                if not blocked[next_pos[0], next_pos[1]]:\n                    visited.add(next_pos)\n                    queue.append((next_pos, path + [action]))\n\n    if path_to_target is None:\n        raise RuntimeError(f\"Could not find a path to an accessible spot near '{workshop_name}'.\")\n    \n    # 5. Determine orientation and add actions to face the workshop\n    \n    # Find the specific workshop cell that `final_pos` is adjacent to\n    target_workshop_pos = None\n    for ws_pos in workshop_locations:\n        ws_y, ws_x = ws_pos\n        if abs(ws_y - final_pos[0]) + abs(ws_x - final_pos[1]) == 1:\n            target_workshop_pos = (ws_y, ws_x)\n            break\n    \n    # Determine the direction the agent needs to face\n    dy = target_workshop_pos[0] - final_pos[0]\n    dx = target_workshop_pos[1] - final_pos[1]\n    target_action_for_facing = delta_to_action[(dy, dx)]\n    \n    # The agent's direction after the path is its last move action.\n    # If the path is empty, the agent hasn't moved, so use its current direction.\n    agent_dir_at_target = state.dir if not path_to_target else path_to_target[-1]\n    \n    final_actions = list(path_to_target)\n    \n    # If not already facing the workshop, perform a turn-in-place maneuver.\n    # This involves moving to an adjacent cell and immediately moving back.\n    if agent_dir_at_target != target_action_for_facing:\n        opposites = {0: 1, 1: 0, 2: 3, 3: 2}  # DOWN/UP, LEFT/RIGHT\n        turn_action_1 = opposites[target_action_for_facing]\n        turn_action_2 = target_action_for_facing\n        final_actions.extend([turn_action_1, turn_action_2])\n        \n    # 6. Add the USE action to perform the craft\n    final_actions.append(4)  # USE\n    \n    return final_actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item.\n\n    This function implements a robust strategy by:\n    1.  Verifying the agent has the required ingredients.\n    2.  Looking up the specific workshop required for the item from the recipe book.\n    3.  Using Breadth-First Search (BFS) to find the shortest, obstacle-free path \n        to a walkable cell adjacent to the correct workshop.\n    4.  Calculating the necessary turn actions to face the workshop.\n    5.  Appending the 'USE' action to perform the craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to execute the crafting plan.\n\n    Raises:\n        ValueError: If the item is unknown, ingredients are missing, the required\n                    workshop is not found on the map, or the workshop is unreachable.\n    \"\"\"\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    start_pos = tuple(env._current_state.pos)\n    height, width, _ = grid.shape\n\n    # 1. Look up recipe and identify the required workshop\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item: {item}\")\n    \n    recipe = cookbook.recipes[goal_index]\n    required_workshop_name = cookbook.index.get(recipe['_at'])\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 2. Check if the agent has the necessary ingredients\n    inventory = env._current_state.inventory\n    for ingredient, required_amount in recipe.items():\n        if ingredient == '_at':\n            continue\n        ingredient_idx = ingredient if isinstance(ingredient, int) else cookbook.index[ingredient]\n        if inventory[ingredient_idx] < required_amount:\n            raise ValueError(f\"Missing ingredients for {item}. Requires {required_amount} of {cookbook.index.get(ingredient_idx)}, has {int(inventory[ingredient_idx])}.\")\n\n    # 3. Find all locations of the required workshop and their adjacent, walkable cells\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Required workshop '{required_workshop_name}' not found in the environment.\")\n\n    # Helper maps for directions and actions\n    # Actions: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    # Deltas: (dy, dx) for (row, col) numpy indexing\n    action_to_delta = {0: (1, 0), 1: (-1, 0), 2: (0, -1), 3: (0, 1)}\n    delta_to_action = {v: k for k, v in action_to_delta.items()}\n    \n    def is_walkable(pos):\n        y, x = pos\n        if not (0 <= y < height and 0 <= x < width):\n            return False\n        # A cell is walkable if it contains nothing (sum of features is 0)\n        return grid[y, x, :].sum() == 0\n\n    destinations = {} # Map from destination cell -> adjacent workshop cell\n    for ws_pos_arr in workshop_locations:\n        ws_pos = tuple(ws_pos_arr)\n        for delta in action_to_delta.values():\n            adj_pos = (ws_pos[0] + delta[0], ws_pos[1] + delta[1])\n            if is_walkable(adj_pos):\n                if adj_pos not in destinations:\n                    destinations[adj_pos] = ws_pos\n\n    if not destinations:\n        raise ValueError(f\"No reachable cells adjacent to any '{required_workshop_name}'.\")\n\n    # 4. Pathfind using Breadth-First Search (BFS)\n    queue = collections.deque([(start_pos, [])]) # (position, path_list)\n    visited = {start_pos}\n    path_found = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in destinations:\n            path_found = (current_pos, path, destinations[current_pos])\n            break\n\n        for action, delta in action_to_delta.items():\n            next_pos = (current_pos[0] + delta[0], current_pos[1] + delta[1])\n            if next_pos not in visited and is_walkable(next_pos):\n                visited.add(next_pos)\n                new_path = path + [action]\n                queue.append((next_pos, new_path))\n    \n    if path_found is None:\n        raise ValueError(f\"Cannot find a path to any '{required_workshop_name}'.\")\n\n    final_pos, action_path, workshop_pos = path_found\n    \n    # 5. Orient the agent to face the workshop\n    # Determine the direction from the final agent position to the workshop\n    dy = workshop_pos[0] - final_pos[0]\n    dx = workshop_pos[1] - final_pos[1]\n    required_dir_action = delta_to_action[(dy, dx)]\n    \n    # Determine the agent's direction after the last move\n    if not action_path: # Agent is already at the destination\n        current_dir_action = env._current_state.dir\n    else:\n        current_dir_action = action_path[-1]\n\n    if current_dir_action != required_dir_action:\n        # To turn, move to an adjacent cell and back, ending with the correct facing.\n        # e.g., to face RIGHT (3), move LEFT (2) then RIGHT (3).\n        opposites = {0: 1, 1: 0, 2: 3, 3: 2} # DOWN/UP, LEFT/RIGHT\n        turn_action_1 = opposites[required_dir_action]\n        turn_action_2 = required_dir_action\n        \n        # Check if the intermediate cell for turning is walkable\n        intermediate_pos_delta = action_to_delta[turn_action_1]\n        intermediate_pos = (final_pos[0] + intermediate_pos_delta[0], final_pos[1] + intermediate_pos_delta[1])\n        \n        if is_walkable(intermediate_pos):\n             action_path.extend([turn_action_1, turn_action_2])\n        else:\n            # If simple turn is blocked, just moving in the required direction is a fallback.\n            # This is a simplification; a more complex algorithm could re-pathfind.\n            # For now, we'll assume the simple turn is usually possible.\n            pass # Or print a warning: \"Warning: Cannot perform optimal turn.\"\n\n    # 6. Add the final 'USE' action\n    action_path.append(4) # USE action\n\n    return action_path\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specified item.\n\n    This function implements a complete plan to craft an item, including:\n    1. Verifying the agent has the necessary ingredients.\n    2. Identifying the specific workshop required by the recipe.\n    3. Finding the closest empty, accessible cell adjacent to that workshop.\n    4. Using Breadth-First Search (BFS) to compute the shortest path.\n    5. Generating the action sequence to move, turn towards the workshop, and craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of integer actions to be executed by the environment.\n\n    Raises:\n        ValueError: If the item is unknown, cannot be crafted, prerequisites are not met,\n                    or the required workshop is missing or inaccessible.\n        RuntimeError: If no path can be found to the workshop.\n    \"\"\"\n    # 1. Initialization and Prerequisite Checks\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        raise ValueError(f\"{item} cannot be crafted (no recipe found).\")\n\n    current_state = env._current_state\n    inventory = current_state.inventory\n\n    # Check if the agent has all required ingredients\n    for ingredient, required_count in recipe.items():\n        if ingredient == '_at':\n            continue\n        ingredient_idx = cookbook.index[ingredient]\n        if inventory[ingredient_idx] < required_count:\n            raise ValueError(f\"Not enough {ingredient} to craft {item}. \"\n                             f\"Have {inventory[ingredient_idx]}, need {required_count}.\")\n\n    # 2. Find required workshop and identify valid adjacent target cells\n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n    grid = current_state.grid\n    grid_width, grid_height = grid.shape[:2]\n\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    target_cells = set()\n    # Workshop locations are (x, y) coordinates\n    for x, y in workshop_locations:\n        # Check 4-directional neighbors\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            # Check bounds and if the cell is empty (traversable)\n            if 0 <= nx < grid_width and 0 <= ny < grid_height:\n                if np.sum(grid[nx, ny, :]) == 0:\n                    target_cells.add((nx, ny))\n\n    if not target_cells:\n        raise ValueError(f\"No accessible empty cells next to workshop '{workshop_name}'.\")\n\n    # 3. Pathfind to the nearest target cell using Breadth-First Search (BFS)\n    start_pos = tuple(current_state.pos)  # Agent's current (x, y) position\n\n    # Action mappings to (dx, dy) movements\n    # Actions: 0=UP, 1=DOWN, 2=LEFT, 3=RIGHT, 4=USE\n    action_to_delta = {0: (0, -1), 1: (0, 1), 2: (-1, 0), 3: (1, 0)}\n    delta_to_action = {v: k for k, v in action_to_delta.items()}\n\n    # BFS queue stores tuples of (current_position, path_of_actions)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n\n        # If we reached a valid target cell, the path is found\n        if (cx, cy) in target_cells:\n            final_pos = (cx, cy)\n            \n            # Find the specific workshop this cell is adjacent to\n            workshop_pos = None\n            for action, (dx, dy) in action_to_delta.items():\n                nx, ny = final_pos[0] + dx, final_pos[1] + dy\n                if 0 <= nx < grid_width and 0 <= ny < grid_height:\n                    if grid[nx, ny, workshop_idx] > 0:\n                        workshop_pos = (nx, ny)\n                        break\n            \n            # Determine the final action to face the workshop. This assumes \"bumping\"\n            # into a blocked cell changes orientation without moving.\n            dx_face = workshop_pos[0] - final_pos[0]\n            dy_face = workshop_pos[1] - final_pos[1]\n            face_action = delta_to_action[(dx_face, dy_face)]\n            \n            # Append the face action and the USE action to the path\n            return path + [face_action, 4]\n\n        # Explore neighbors\n        for action, (dx, dy) in action_to_delta.items():\n            nx, ny = cx + dx, cy + dy\n            next_pos = (nx, ny)\n\n            # Check if neighbor is valid for traversal\n            if (0 <= nx < grid_width and 0 <= ny < grid_height and\n                    next_pos not in visited and np.sum(grid[nx, ny, :]) == 0):\n                \n                visited.add(next_pos)\n                new_path = path + [action]\n                queue.append((next_pos, new_path))\n                \n    # If the queue becomes empty, no path exists\n    raise RuntimeError(\"Could not find a path to an accessible workshop.\")\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specified item.\n\n    This function implements a robust strategy that:\n    1. Checks if the required ingredients are in the agent's inventory.\n    2. Identifies the specific workshop required by the item's recipe.\n    3. Finds a valid, empty, adjacent cell to the workshop to stand on. A cell is\n       valid only if it also has a clear space behind it for maneuvering.\n    4. Uses Breadth-First Search (BFS) to find the shortest obstacle-avoiding\n       path to the nearest valid standing cell.\n    5. Appends a two-step action sequence to guarantee the agent turns to face\n       the workshop.\n    6. Appends the 'USE' action to perform the craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to execute. Returns an empty list\n                   if crafting is not possible (e.g., missing ingredients, no\n                   path to workshop).\n    \"\"\"\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n\n    # 1. Verify that the item is craftable and get its recipe\n    if goal_index not in cookbook.recipes:\n        # Item is a primitive or doesn't exist; cannot be crafted.\n        return []\n    recipe = cookbook.recipes[goal_index]\n    \n    # 2. Check if the agent has the necessary ingredients\n    inventory = env._current_state.inventory\n    for ingredient_idx, required_count in recipe.items():\n        if ingredient_idx == '_at':\n            continue\n        if inventory[ingredient_idx] < required_count:\n            # Prerequisite not met, cannot craft.\n            return []\n\n    # 3. Identify the required workshop and set up for pathfinding\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n    \n    grid = env._current_state.grid\n    WIDTH, HEIGHT = grid.shape[:2]\n    start_pos = tuple(env._current_state.pos)\n\n    # Create a 2D boolean map of walkable cells for BFS.\n    walkable_map = (grid.sum(axis=2) == 0)\n    # The agent's starting position is always considered walkable for pathfinding.\n    walkable_map[start_pos[0], start_pos[1]] = True\n\n    # 4. Find all valid target destinations\n    # A target is an empty cell adjacent to the correct workshop, which also has\n    # a clear cell behind it for the orientation maneuver.\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    targets = set()\n    # Map each target cell to the actions needed for orientation\n    target_info = {}\n\n    # Map from relative workshop position (dx, dy) to (action_towards, action_away)\n    orientation_map = {\n        (0, 1): (UP, DOWN),      # Workshop is UP (y+1), so face UP, move away DOWN\n        (0, -1): (DOWN, UP),     # Workshop is DOWN (y-1), so face DOWN, move away UP\n        (1, 0): (RIGHT, LEFT),   # Workshop is RIGHT (x+1), so face RIGHT, move away LEFT\n        (-1, 0): (LEFT, RIGHT),  # Workshop is LEFT (x-1), so face LEFT, move away RIGHT\n    }\n    \n    for wx, wy in workshop_locations:\n        for (dx, dy), (face_action, away_action) in orientation_map.items():\n            # (ax, ay) is the cell adjacent to the workshop where the agent will stand\n            ax, ay = wx - dx, wy - dy\n            \n            # (bx, by) is the cell \"behind\" the agent, needed for the turn maneuver\n            bx, by = ax - dx, ay - dy\n\n            if (0 <= ax < WIDTH and 0 <= ay < HEIGHT and walkable_map[ax, ay] and\n                0 <= bx < WIDTH and 0 <= by < HEIGHT and walkable_map[bx, by]):\n                \n                target_pos = (ax, ay)\n                targets.add(target_pos)\n                if target_pos not in target_info:\n                    target_info[target_pos] = {\n                        'face_action': face_action, \n                        'away_action': away_action\n                    }\n    \n    if not targets:\n        return [] # No valid workshop locations found\n\n    # 5. Use BFS to find the shortest path to any of the valid targets\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    path_to_target = None\n    final_pos = None\n    \n    moves = {RIGHT: (1, 0), LEFT: (-1, 0), UP: (0, 1), DOWN: (0, -1)}\n\n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        current_pos = (curr_x, curr_y)\n        \n        if current_pos in targets:\n            path_to_target = path\n            final_pos = current_pos\n            break\n\n        for action, (dx, dy) in moves.items():\n            nx, ny = curr_x + dx, curr_y + dy\n            neighbor = (nx, ny)\n\n            if 0 <= nx < WIDTH and 0 <= ny < HEIGHT and walkable_map[nx, ny] and neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [action]))\n\n    if path_to_target is None:\n        return [] # No path exists to any workshop\n\n    # 6. Assemble the final action sequence\n    info = target_info[final_pos]\n    \n    # Path to get adjacent -> move away -> move towards (to orient) -> use workshop\n    actions = path_to_target\n    actions.append(info['away_action'])\n    actions.append(info['face_action'])\n    actions.append(USE)\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    orient the agent, and craft the specified item.\n\n    This function implements a full pathfinding and interaction plan:\n    1.  Identifies the specific workshop required by the item's recipe.\n    2.  Uses Breadth-First Search (BFS) to find the shortest, obstacle-free\n        path to an empty cell adjacent to that workshop.\n    3.  Generates the sequence of primitive move actions (UP, DOWN, LEFT, RIGHT)\n        to follow the path.\n    4.  Adds an action to \"bump\" into the workshop, which orients the agent\n        to face it.\n    5.  Adds the final 'USE' action to perform the craft.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    \n    # 1. Look up the recipe and required workshop for the item.\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"'{item}' is not a craftable item with a known recipe.\")\n\n    recipe = cookbook.recipes[goal_index]\n    workshop_name = recipe.get('_at')\n    if not workshop_name:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n        \n    workshop_idx = cookbook.index[workshop_name]\n\n    # Note: A robust implementation would also check for required ingredients in\n    # state.inventory here. This is omitted to focus on the primary task of \n    # correcting the navigation and interaction logic.\n\n    # 2. Set up the grid for pathfinding.\n    grid = state.grid\n    width, height, _ = grid.shape\n    start_pos = tuple(state.pos) # pos is (x, y)\n\n    # A cell is \"blocked\" if any item, resource, or structure is on it.\n    is_blocked = grid.sum(axis=2) > 0\n\n    # 3. Find all instances of the required workshop and their adjacent empty cells (targets).\n    workshop_locs = set(map(tuple, np.argwhere(grid[:, :, workshop_idx])))\n    if not workshop_locs:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    target_cells = set()\n    # Agent can't move onto a workshop, so valid targets are adjacent empty cells.\n    for x, y in workshop_locs:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and not is_blocked[nx, ny]:\n                target_cells.add((nx, ny))\n\n    if not target_cells:\n        raise ValueError(f\"No accessible cells next to the required workshop '{workshop_name}'.\")\n\n    # 4. Perform Breadth-First Search (BFS) to find the shortest path.\n    # Action mapping based on codebase inspection:\n    # 0:DOWN(y-1), 1:UP(y+1), 2:LEFT(x-1), 3:RIGHT(x+1)\n    moves = {\n        0: (0, -1), # DOWN\n        1: (0, 1),  # UP\n        2: (-1, 0), # LEFT\n        3: (1, 0)   # RIGHT\n    }\n    \n    queue = collections.deque([(start_pos, [])]) # (current_pos, list_of_actions)\n    visited = {start_pos}\n    path_to_target = None\n    final_pos = None\n\n    # Handle case where agent already starts at a target cell.\n    if start_pos in target_cells:\n        path_to_target = []\n        final_pos = start_pos\n    else:\n        while queue:\n            (curr_x, curr_y), path = queue.popleft()\n            \n            # Explore neighbors\n            for action, (dx, dy) in moves.items():\n                next_x, next_y = curr_x + dx, curr_y + dy\n                next_pos = (next_x, next_y)\n\n                if 0 <= next_x < width and 0 <= next_y < height and next_pos not in visited:\n                    # If the cell is not blocked, it's a valid move.\n                    if not is_blocked[next_x, next_y]:\n                        visited.add(next_pos)\n                        new_path = path + [action]\n                        if next_pos in target_cells:\n                            path_to_target = new_path\n                            final_pos = next_pos\n                            queue.clear() # Found shortest path, terminate search\n                            break\n                        queue.append((next_pos, new_path))\n    \n    if path_to_target is None:\n        raise ValueError(\"No path found to an accessible cell near the workshop.\")\n        \n    # 5. Determine the final actions for orientation and crafting.\n    # Find which workshop instance we are adjacent to.\n    adjacent_workshop = None\n    ax, ay = final_pos\n    for dx, dy in moves.values():\n        check_pos = (ax + dx, ay + dy)\n        if check_pos in workshop_locs:\n            adjacent_workshop = check_pos\n            break\n            \n    if adjacent_workshop is None:\n        raise RuntimeError(\"Internal logic error: cannot find adjacent workshop from target cell.\")\n\n    # Determine the action needed to face/bump into the workshop, setting agent direction.\n    wx, wy = adjacent_workshop\n    face_dx, face_dy = wx - ax, wy - ay\n    \n    turn_action = -1\n    for action, (dx, dy) in moves.items():\n        if (dx, dy) == (face_dx, face_dy):\n            turn_action = action\n            break\n    \n    # The full plan: move along the path, turn to face, then use the workshop.\n    # The USE action is mapped to integer 4.\n    actions = path_to_target + [turn_action, 4]\n    \n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1. Identifying the specific workshop required by the item's recipe.\n    2. Finding all empty, accessible cells adjacent to that workshop type.\n    3. Using Breadth-First Search (BFS) to find the shortest, obstacle-free path \n       from the agent's current position to the nearest of these target cells.\n    4. Appending an action to turn the agent to face the workshop.\n    5. Appending the 'USE' action to perform the crafting.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to be executed.\n        \n    Raises:\n        ValueError: If the item has no recipe or the required workshop is not found.\n        RuntimeError: If no path to an accessible workshop cell can be found.\n    \"\"\"\n    # Action constants\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # Map actions to coordinate changes (dx, dy) for a (width, height) grid\n    action_deltas = {\n        RIGHT: (1, 0),\n        LEFT: (-1, 0),\n        UP: (0, 1),\n        DOWN: (0, -1),\n    }\n\n    # 1. Look up the recipe to find the required workshop\n    cookbook = env.world.cookbook\n    goal_idx = cookbook.index[item]\n    if goal_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' has no recipe and cannot be crafted.\")\n    \n    recipe = cookbook.recipes[goal_idx]\n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Prepare for pathfinding by analyzing the current grid state\n    state = env._current_state\n    grid = state.grid\n    grid_w, grid_h, _ = grid.shape\n    start_pos = tuple(state.pos)\n\n    # Identify all blocked cells (obstacles). Non-grabbable items are obstacles.\n    non_grabbable_indices = list(env.world.non_grabbable_indices)\n    is_blocked = np.sum(grid[:, :, non_grabbable_indices], axis=2) > 0\n    \n    # Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx] > 0)\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    # Determine valid target cells: empty cells adjacent to any workshop instance\n    target_cells = set()\n    for ws_pos in workshop_locations:\n        x, y = ws_pos[0], ws_pos[1]\n        for dx, dy in action_deltas.values():\n            adj_x, adj_y = x + dx, y + dy\n            if 0 <= adj_x < grid_w and 0 <= adj_y < grid_h and not is_blocked[adj_x, adj_y]:\n                target_cells.add((adj_x, adj_y))\n\n    if not target_cells:\n        raise ValueError(f\"No accessible cell next to workshop '{workshop_name}' found.\")\n\n    # 3. Pathfind using Breadth-First Search (BFS)\n    # Check if the agent is already at a target cell\n    if start_pos in target_cells:\n        path_to_target = []\n        final_pos = start_pos\n    else:\n        # (position, path_of_actions)\n        queue = collections.deque([(start_pos, [])])\n        visited = {start_pos}\n        path_to_target = None\n        final_pos = None\n\n        while queue:\n            curr_pos, path = queue.popleft()\n            curr_x, curr_y = curr_pos\n\n            for action, (dx, dy) in action_deltas.items():\n                next_pos = (curr_x + dx, curr_y + dy)\n                next_x, next_y = next_pos\n\n                if not (0 <= next_x < grid_w and 0 <= next_y < grid_h):\n                    continue\n                \n                if next_pos in visited or is_blocked[next_x, next_y]:\n                    continue\n                \n                new_path = path + [action]\n                if next_pos in target_cells:\n                    path_to_target = new_path\n                    final_pos = next_pos\n                    queue.clear()  # Stop searching once the shortest path is found\n                    break\n                \n                visited.add(next_pos)\n                queue.append((next_pos, new_path))\n            \n            if path_to_target is not None:\n                break\n    \n    if path_to_target is None:\n        raise RuntimeError(f\"Could not find a path to workshop '{workshop_name}'.\")\n\n    # 4. Generate the final sequence of actions\n    actions = path_to_target\n    \n    # Determine the action required to face the workshop from the final position\n    final_x, final_y = final_pos\n    face_action = -1\n    for action, (dx, dy) in action_deltas.items():\n        neighbor_x, neighbor_y = final_x + dx, final_y + dy\n        if 0 <= neighbor_x < grid_w and 0 <= neighbor_y < grid_h:\n            if grid[neighbor_x, neighbor_y, workshop_idx] > 0:\n                face_action = action\n                break\n    \n    # Append the action to turn towards the workshop\n    actions.append(face_action)\n    \n    # Append the USE action to craft the item\n    actions.append(USE)\n\n    return actions\n",
  "evaluation_result": [
    4.900000002980232,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a complete plan to craft a given item:\n    1.  Reads the recipe to determine the specific workshop required.\n    2.  Identifies all locations of that workshop on the grid.\n    3.  Determines all valid, empty cells adjacent to these workshops, which serve as targets.\n    4.  Uses a Breadth-First Search (BFS) algorithm to find the shortest, obstacle-avoiding\n        path from the agent's current position to one of the target cells.\n    5.  Appends the necessary turn action to face the workshop from the adjacent cell.\n    6.  Appends the 'USE' action to perform the crafting.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft (e.g., \"plank\").\n\n    Returns:\n        list[int]: A list of integer actions to execute the plan.\n    \n    Raises:\n        ValueError: If the item is not craftable, the required workshop doesn't exist,\n                    or no accessible adjacent cells are found.\n        RuntimeError: If no path to the workshop can be found.\n    \"\"\"\n    # 1. Look up the recipe to find the required workshop\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n\n    if goal_index is None or goal_index not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' is not craftable or has no recipe.\")\n\n    recipe = cookbook.recipes[goal_index]\n    workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all locations of the required workshop and identify valid adjacent cells\n    state = env._current_state\n    grid = state.grid\n    start_pos = tuple(state.pos)\n    width, height, _ = grid.shape\n\n    # Create a 2D boolean grid for pathfinding where True indicates an obstacle\n    is_obstacle = grid.sum(axis=2) > 0\n    # The agent's current position is not an obstacle for pathfinding purposes\n    is_obstacle[start_pos[0], start_pos[1]] = False\n\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    # Find all empty cells adjacent to any instance of the required workshop\n    target_adj_cells = set()\n    adj_to_workshop_map = {}\n    for wx, wy in workshop_locations:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = wx + dx, wy + dy\n            # Check if neighbor is within bounds and is not an obstacle\n            if 0 <= nx < width and 0 <= ny < height and not is_obstacle[nx, ny]:\n                adj_cell = (nx, ny)\n                target_adj_cells.add(adj_cell)\n                adj_to_workshop_map[adj_cell] = (wx, wy)\n\n    if not target_adj_cells:\n        raise ValueError(f\"No accessible cells found next to workshop '{workshop_name}'.\")\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path to an adjacent cell\n    queue = collections.deque([(start_pos, [])])  # (position, path_of_actions)\n    visited = {start_pos}\n    \n    path_to_adj = None\n    reached_adj_cell = None\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if (x, y) in target_adj_cells:\n            path_to_adj = path\n            reached_adj_cell = (x, y)\n            break  # Found the shortest path to a valid target\n\n        # Explore neighbors: format is ((next_x, next_y), action)\n        # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n        moves = [\n            ((x, y - 1), 0),  # DOWN\n            ((x, y + 1), 1),  # UP\n            ((x - 1, y), 2),  # LEFT\n            ((x + 1, y), 3),  # RIGHT\n        ]\n\n        for (nx, ny), action in moves:\n            neighbor = (nx, ny)\n            if 0 <= nx < width and 0 <= ny < height and neighbor not in visited and not is_obstacle[nx, ny]:\n                visited.add(neighbor)\n                new_path = path + [action]\n                queue.append((neighbor, new_path))\n    \n    if path_to_adj is None:\n        raise RuntimeError(f\"Agent cannot find a path to workshop '{workshop_name}'.\")\n\n    # 4. Assemble the final action sequence\n    actions = path_to_adj\n    \n    # Add an action to turn and face the workshop\n    workshop_pos = adj_to_workshop_map[reached_adj_cell]\n    ax, ay = reached_adj_cell\n    wx, wy = workshop_pos\n    \n    if wx > ax:\n        actions.append(3)  # Face RIGHT\n    elif wx < ax:\n        actions.append(2)  # Face LEFT\n    elif wy > ay:\n        actions.append(1)  # Face UP\n    elif wy < ay:\n        actions.append(0)  # Face DOWN\n\n    # 5. Add the USE action\n    actions.append(4)  # USE\n\n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1.  Identifying the specific workshop required by the item's recipe.\n    2.  Finding all instances of that workshop on the grid.\n    3.  Identifying all valid, empty, adjacent cells to these workshops, which serve as targets.\n    4.  Using Breadth-First Search (BFS) to find the shortest, obstacle-avoiding path from the\n        agent's current position to the nearest target cell.\n    5.  Translating the path of coordinates into a sequence of move actions.\n    6.  Adding a final action to turn the agent to face the workshop.\n    7.  Appending the 'USE' action to perform the crafting.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n    start_pos = tuple(state.pos)  # Use tuple for hashability and set operations\n\n    # Action constants from the environment's action spec\n    ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n\n    # Step 1: Look up the recipe to find the required workshop\n    goal_index = cookbook.index[item]\n    if goal_index is None or goal_index not in cookbook.recipes:\n        return []  # Item doesn't exist or cannot be crafted\n\n    recipe = cookbook.recipes[goal_index]\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # Step 2: Find all locations of the required workshop on the grid\n    workshop_locs = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locs.shape[0] == 0:\n        return []  # Required workshop not found on the map\n\n    # Step 3: Identify all valid, empty adjacent cells to serve as pathfinding targets\n    height, width, _ = grid.shape\n    target_locs = set()\n    for r, c in workshop_locs:\n        # Check neighbors in the order: up, down, left, right\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            # A valid target is within bounds and is an empty cell\n            if 0 <= nr < height and 0 <= nc < width and grid[nr, nc, :].sum() == 0:\n                target_locs.add((nr, nc))\n\n    if not target_locs:\n        return []  # No accessible spots next to any instance of the required workshop\n\n    # Step 4: Use Breadth-First Search (BFS) to find the shortest path to a target\n    queue = collections.deque([start_pos])\n    visited = {start_pos}\n    parent = {start_pos: None}  # A map to reconstruct the path: child -> parent\n\n    end_pos = None\n    if start_pos in target_locs:\n        end_pos = start_pos\n    else:\n        while queue:\n            curr_pos = queue.popleft()\n            r, c = curr_pos\n\n            # Explore neighbors: up, down, left, right\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                neighbor_pos = (r + dr, c + dc)\n                nr, nc = neighbor_pos\n\n                if 0 <= nr < height and 0 <= nc < width and neighbor_pos not in visited:\n                    # A cell is walkable if it is empty. Target cells are already known to be empty.\n                    if grid[nr, nc, :].sum() == 0:\n                        visited.add(neighbor_pos)\n                        parent[neighbor_pos] = curr_pos\n                        queue.append(neighbor_pos)\n\n                        if neighbor_pos in target_locs:\n                            end_pos = neighbor_pos\n                            queue.clear()  # Terminate search once the first (and shortest) path is found\n                            break\n            if end_pos:\n                break\n    \n    if end_pos is None:\n        return []  # No path found from agent's position to any target\n\n    # Step 5: Reconstruct the path from the parent map and convert it to actions\n    actions = []\n    path = []\n    curr = end_pos\n    while curr is not None:\n        path.append(curr)\n        curr = parent.get(curr)\n    path.reverse()\n\n    # Convert the sequence of coordinates into a sequence of move actions\n    for i in range(len(path) - 1):\n        r1, c1 = path[i]\n        r2, c2 = path[i+1]\n        dr, dc = r2 - r1, c2 - c1\n        \n        if dr == 1: actions.append(ACTION_DOWN)\n        elif dr == -1: actions.append(ACTION_UP)\n        elif dc == 1: actions.append(ACTION_RIGHT)\n        elif dc == -1: actions.append(ACTION_LEFT)\n\n    # Step 6: Add a final action to turn and face the workshop\n    # The agent attempts to move into the workshop cell, which is blocked.\n    # This action fails to move the agent but successfully changes its direction.\n    r_agent, c_agent = end_pos\n    workshop_pos = None\n    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nr, nc = r_agent + dr, c_agent + dc\n        if 0 <= nr < height and 0 <= nc < width and grid[nr, nc, required_workshop_idx]:\n            workshop_pos = (nr, nc)\n            break\n    \n    if workshop_pos is None:\n        # This case should be unreachable if logic is correct, but serves as a safeguard\n        return []\n        \n    r_ws, c_ws = workshop_pos\n    dr, dc = r_ws - r_agent, c_ws - c_agent\n    \n    if dr == 1: actions.append(ACTION_DOWN)\n    elif dr == -1: actions.append(ACTION_UP)\n    elif dc == 1: actions.append(ACTION_RIGHT)\n    elif dc == -1: actions.append(ACTION_LEFT)\n    \n    # Step 7: Append the 'USE' action to perform the craft\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1. Looking up the item's recipe in the cookbook to identify the specific workshop required.\n    2. Finding all instances of that workshop on the grid.\n    3. Identifying all empty, accessible cells adjacent to these workshops, as these are the valid positions from which to perform the craft action.\n    4. Using a Breadth-First Search (BFS) algorithm to find the shortest, obstacle-avoiding path from the agent's current position to the nearest of these valid target cells.\n    5. Translating the found path into a sequence of movement actions (UP, DOWN, LEFT, RIGHT).\n    6. Appending a final turn action to ensure the agent is facing the workshop.\n    7. Appending the USE action to complete the crafting process.\n\n    If no path is possible or the required workshop does not exist, it returns an empty list.\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n\n    # Step 1: Look up the recipe to find the required workshop type\n    goal_idx = cookbook.index[item]\n    if goal_idx is None or goal_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' is not craftable or has no recipe.\")\n\n    recipe = cookbook.recipes[goal_idx]\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # Step 2: Find all valid target locations (empty cells next to the workshop)\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        # Required workshop does not exist on the map\n        return []\n\n    width, height, _ = grid.shape\n    # A cell is blocked if any item/terrain is on it.\n    blocked_mask = grid.sum(axis=2) > 0\n    start_pos = tuple(state.pos)\n\n    # Agent's current position is not a valid destination, but is traversable from.\n    if 0 <= start_pos[0] < width and 0 <= start_pos[1] < height:\n        blocked_mask[start_pos[0], start_pos[1]] = False\n\n    # Find all empty cells adjacent to any instance of the required workshop\n    target_cells = {}\n    for ws_pos_arr in workshop_locations:\n        ws_pos = tuple(ws_pos_arr)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_pos = (ws_pos[0] + dx, ws_pos[1] + dy)\n            if (0 <= neighbor_pos[0] < width and\n                0 <= neighbor_pos[1] < height and\n                not blocked_mask[neighbor_pos[0], neighbor_pos[1]]):\n                # Map the valid destination cell to the workshop it is adjacent to\n                target_cells[neighbor_pos] = ws_pos\n\n    if not target_cells:\n        # No accessible cells next to the required workshop\n        return []\n\n    # Step 3: Find the shortest path to a target cell using Breadth-First Search (BFS)\n    # The queue stores tuples of (current_position, path_of_actions)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    path_to_target, final_pos, workshop_to_face = None, None, None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in target_cells:\n            path_to_target = path\n            final_pos = current_pos\n            workshop_to_face = target_cells[current_pos]\n            break # Found the shortest path to the nearest valid target\n\n        # Explore neighbors (Right, Left, Up, Down)\n        # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n        # Position mapping: pos = (x, y)\n        moves = {3: (1, 0), 2: (-1, 0), 1: (0, 1), 0: (0, -1)}\n        for action, (dx, dy) in moves.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n            if (0 <= next_pos[0] < width and 0 <= next_pos[1] < height and\n                next_pos not in visited and not blocked_mask[next_pos[0], next_pos[1]]):\n                visited.add(next_pos)\n                queue.append((next_pos, path + [action]))\n\n    if path_to_target is None:\n        # No path could be found\n        return []\n\n    # Step 4 & 5: Convert the path to actions and add the final face & use actions\n    actions = path_to_target\n\n    # Determine the final turn action to face the workshop from the destination cell\n    dx = workshop_to_face[0] - final_pos[0]\n    dy = workshop_to_face[1] - final_pos[1]\n\n    if dx == 1: actions.append(3)   # Face RIGHT\n    elif dx == -1: actions.append(2)  # Face LEFT\n    elif dy == 1: actions.append(1)   # Face UP\n    elif dy == -1: actions.append(0)  # Face DOWN\n\n    # Append the USE action\n    actions.append(4)\n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    valid path to a cell adjacent to the required workshop. It avoids obstacles\n    and ensures the agent is correctly positioned and oriented before attempting\n    to craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A sequence of integer actions to achieve the goal. Returns an\n              empty list if the task is impossible (e.g., no path).\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n\n    # 1. Find the required workshop from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx is None or item_idx not in cookbook.recipes:\n        # This item cannot be crafted\n        return []\n    \n    recipe = cookbook.recipes[item_idx]\n    # The recipe stores the workshop name (e.g., \"workshop0\")\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 2. Find all locations of the required workshop and their valid neighbors (target cells)\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        # Required workshop does not exist on the map\n        return []\n\n    # A cell is walkable if nothing is on it.\n    walkable_mask = grid.sum(axis=-1) == 0\n    \n    target_cells = set()\n    # Store which workshop each target cell is adjacent to\n    target_to_workshop_map = {}\n\n    for wx, wy in workshop_locations:\n        # Check all four neighbors (up, down, left, right)\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = wx + dx, wy + dy\n            # Check if neighbor is within grid bounds and is walkable\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1] and walkable_mask[nx, ny]:\n                neighbor_pos = (nx, ny)\n                target_cells.add(neighbor_pos)\n                target_to_workshop_map[neighbor_pos] = (wx, wy)\n\n    if not target_cells:\n        # No accessible spots next to any required workshop\n        return []\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path\n    start_pos = tuple(state.pos)\n    \n    # If starting position is already a target, no move actions are needed.\n    if start_pos in target_cells:\n        path = []\n    else:\n        queue = collections.deque([(start_pos, [])]) # (position, path_list)\n        visited = {start_pos}\n        path = None\n\n        while queue:\n            current_pos, current_path = queue.popleft()\n\n            if current_pos in target_cells:\n                path = current_path\n                break # Found the shortest path\n\n            # Explore neighbors: UP, DOWN, LEFT, RIGHT\n            # Actions:      0,    1,     2,     3\n            # Dirs (dx,dy): (0,-1),(0,1), (-1,0),(1,0)\n            for action, (dx, dy) in enumerate([(0, -1), (0, 1), (-1, 0), (1, 0)]):\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n                if (0 <= next_pos[0] < grid.shape[0] and\n                    0 <= next_pos[1] < grid.shape[1] and\n                    next_pos not in visited and\n                    (walkable_mask[next_pos] or next_pos in target_cells)):\n                    \n                    visited.add(next_pos)\n                    new_path = current_path + [action]\n                    queue.append((next_pos, new_path))\n        \n    if path is None:\n        # No path found\n        return []\n\n    # 4. Determine final orientation and add USE action\n    actions = path\n    final_pos = start_pos\n    if path: # If any moves were made, calculate the new final position\n        # This is a simplified calculation assuming path is executed.\n        # The BFS ensures this is the correct final position.\n        for action in path:\n            dx, dy = [(0, -1), (0, 1), (-1, 0), (1, 0)][action]\n            final_pos = (final_pos[0] + dx, final_pos[1] + dy)\n    \n    # Get the workshop this final position is adjacent to\n    workshop_pos = target_to_workshop_map[final_pos]\n\n    # Determine direction to face the workshop\n    dx = workshop_pos[0] - final_pos[0]\n    dy = workshop_pos[1] - final_pos[1]\n\n    face_action = -1\n    if dx == 1: face_action = 3 # RIGHT\n    elif dx == -1: face_action = 2 # LEFT\n    elif dy == 1: face_action = 1 # DOWN\n    elif dy == -1: face_action = 0 # UP\n    \n    if face_action != -1:\n        actions.append(face_action)\n    \n    actions.append(4) # USE action\n\n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1.  Identifying the specific workshop required by the item's recipe.\n    2.  Checking if the agent has the necessary ingredients in its inventory.\n    3.  Finding all reachable, empty cells adjacent to all instances of the required workshop.\n    4.  Using Breadth-First Search (BFS) to find the shortest obstacle-avoiding path \n        from the agent's current position to the nearest of these target cells.\n    5.  Translating the path into a sequence of movement actions.\n    6.  Adding a final action to turn and face the workshop.\n    7.  Adding the 'USE' action to perform the craft.\n\n    Returns an empty list if crafting is impossible (e.g., missing ingredients, no workshop,\n    or no valid path).\n    \"\"\"\n    \n    # Action constants mapping (dy, dx) movement vectors to action codes.\n    # Assumes standard numpy indexing where pos is (row, col) or (y, x).\n    # DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n    ACTION_MAP = {\n        (1, 0): 0,   # Move down (y increases)\n        (-1, 0): 1,  # Move up (y decreases)\n        (0, -1): 2,  # Move left (x decreases)\n        (0, 1): 3    # Move right (x increases)\n    }\n\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n    \n    # 1. Look up the recipe and required workshop from the cookbook\n    item_idx = cookbook.index[item]\n    if item_idx is None or item_idx not in cookbook.recipes:\n        # The item is unknown or is a primitive that cannot be crafted.\n        return []\n\n    recipe = cookbook.recipes[item_idx]\n    \n    # 2. Check if the agent's inventory has the required ingredients\n    inventory = state.inventory\n    for ingredient_idx, required_count in recipe.items():\n        if ingredient_idx == '_at':\n            continue\n        if inventory[ingredient_idx] < required_count:\n            # Missing ingredients, so crafting is impossible.\n            return []\n\n    # 3. Find the specific workshop index required by the recipe\n    required_workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[required_workshop_name]\n    if workshop_idx is None:\n        return []\n\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        # The required workshop does not exist on the map.\n        return []\n\n    # 4. Identify all valid, empty cells adjacent to the workshops. These are our pathfinding targets.\n    height, width, _ = grid.shape\n    start_pos = tuple(state.pos)\n    \n    # A cell is blocked if any object (terrain, item, workshop) occupies it.\n    is_blocked = grid.sum(axis=2) > 0\n    \n    # The agent's starting position is traversable for the pathfinder.\n    if 0 <= start_pos[0] < height and 0 <= start_pos[1] < width:\n        is_blocked[start_pos] = False \n\n    # Collect all valid destination cells, mapping each to its adjacent workshop's position.\n    target_cells = {} \n    for w_pos_array in workshop_locations:\n        w_pos = tuple(w_pos_array)\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            neighbor = (w_pos[0] + dy, w_pos[1] + dx)\n            if (0 <= neighbor[0] < height and 0 <= neighbor[1] < width and not is_blocked[neighbor]):\n                if neighbor not in target_cells:\n                    target_cells[neighbor] = w_pos\n\n    if not target_cells:\n        # No accessible spots next to any instance of the required workshop.\n        return []\n\n    # 5. Use Breadth-First Search (BFS) to find the shortest path to the nearest target cell.\n    queue = collections.deque([(start_pos, [])]) # Each item is (current_position, path_so_far)\n    visited = {start_pos}\n    path_to_target = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in target_cells:\n            # Found the shortest path to a reachable target cell.\n            path_to_target = path + [current_pos]\n            break\n\n        # Explore neighbors in a fixed order (e.g., Up, Down, Left, Right)\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_pos = (current_pos[0] + dy, current_pos[1] + dx)\n            if (0 <= next_pos[0] < height and 0 <= next_pos[1] < width and\n                    next_pos not in visited and not is_blocked[next_pos]):\n                visited.add(next_pos)\n                queue.append((next_pos, path + [current_pos]))\n    \n    if path_to_target is None:\n        # No path exists from the agent to any valid workshop-adjacent cell.\n        return []\n\n    # 6. Convert the found path of coordinates into a sequence of movement actions.\n    actions = []\n    for i in range(len(path_to_target) - 1):\n        pos1 = path_to_target[i]\n        pos2 = path_to_target[i+1]\n        \n        dy, dx = pos2[0] - pos1[0], pos2[1] - pos1[1]\n        action = ACTION_MAP.get((dy, dx))\n        if action is not None:\n             actions.append(action)\n        else:\n             # This case should not be reached with a valid BFS path.\n             return [] \n            \n    # 7. Append the final actions: one to turn towards the workshop, and one to 'USE' it.\n    final_agent_pos = path_to_target[-1]\n    target_workshop_pos = target_cells[final_agent_pos]\n\n    # Calculate the vector from the agent to the workshop to determine which way to face.\n    dy, dx = target_workshop_pos[0] - final_agent_pos[0], target_workshop_pos[1] - final_agent_pos[1]\n    \n    # Append a move action that makes the agent face the workshop.\n    # If the workshop cell is blocked, this action changes the agent's direction without moving.\n    turn_action = ACTION_MAP.get((dy, dx))\n    if turn_action is not None:\n        actions.append(turn_action)\n    else:\n        # Logic error if the final position is not adjacent to the workshop.\n        return []\n    \n    # Finally, append the USE action.\n    actions.append(4) \n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop, face it, and craft an item.\n\n    Args:\n        env: The current environment instance (e.g., CraftLab).\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A sequence of integer actions to achieve the crafting goal.\n\n    Raises:\n        ValueError: If the item has no recipe or the required workshop is not on the map.\n        RuntimeError: If no accessible path to the required workshop can be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # 1. Identify the specific workshop required for the item from the recipe book.\n    item_idx = cookbook.index[item]\n    if item_idx is None or item_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' has no recipe and cannot be crafted.\")\n    \n    recipe = cookbook.recipes[item_idx]\n    workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all locations of the required workshop on the grid.\n    grid = state.grid\n    height, width, _ = grid.shape\n    agent_pos = tuple(state.pos)\n\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found on the map.\")\n\n    # 3. Identify all valid target positions: empty, walkable cells adjacent to any instance of the required workshop.\n    target_positions = set()\n    # This dictionary maps each valid target position back to its associated workshop.\n    # This is needed to know which direction to face at the end of the path.\n    target_to_workshop_map = {}\n    is_walkable = (grid.sum(axis=2) == 0)\n\n    for r, c in workshop_locations:\n        for dr, dc in [(1, 0), (-1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            neighbor_pos = (nr, nc)\n            # A neighbor is a valid target if it's in bounds and is walkable (or is the agent's current spot).\n            if (0 <= nr < height and 0 <= nc < width and \n               (is_walkable[nr, nc] or neighbor_pos == agent_pos)):\n                target_positions.add(neighbor_pos)\n                target_to_workshop_map[neighbor_pos] = (r, c)\n    \n    if not target_positions:\n        raise RuntimeError(f\"No accessible cells next to any '{workshop_name}'.\")\n    \n    # 4. Find the shortest path from the agent's position to any of the valid target cells.\n    path_to_workshop = find_shortest_path(grid, agent_pos, target_positions)\n    \n    if path_to_workshop is None:\n        raise RuntimeError(f\"Cannot find a path to a '{workshop_name}'.\")\n\n    # 5. Determine the agent's final position after following the path to determine which direction to face.\n    final_agent_pos = agent_pos\n    for action in path_to_workshop:\n        if action == ACTION_DOWN: final_agent_pos = (final_agent_pos[0] + 1, final_agent_pos[1])\n        elif action == ACTION_UP: final_agent_pos = (final_agent_pos[0] - 1, final_agent_pos[1])\n        elif action == ACTION_LEFT: final_agent_pos = (final_agent_pos[0], final_agent_pos[1] - 1)\n        elif action == ACTION_RIGHT: final_agent_pos = (final_agent_pos[0], final_agent_pos[1] + 1)\n            \n    target_workshop_pos = target_to_workshop_map[final_agent_pos]\n\n    # 6. Calculate the \"face\" action required to turn towards the workshop.\n    dr = target_workshop_pos[0] - final_agent_pos[0]\n    dc = target_workshop_pos[1] - final_agent_pos[1]\n    \n    face_action = None\n    if (dr, dc) == (1, 0): face_action = ACTION_DOWN\n    elif (dr, dc) == (-1, 0): face_action = ACTION_UP\n    elif (dr, dc) == (0, -1): face_action = ACTION_LEFT\n    elif (dr, dc) == (0, 1): face_action = ACTION_RIGHT\n    \n    # 7. Assemble the full action sequence: path to move, action to turn, and action to use.\n    actions = path_to_workshop\n    if face_action is not None:\n        actions.append(face_action)\n    actions.append(ACTION_USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft a specified item.\n\n    This function implements a robust strategy by:\n    1.  Identifying the specific workshop required for the item from the game's cookbook.\n    2.  Finding all accessible (empty) cells adjacent to any instance of that workshop.\n    3.  Using Breadth-First Search (BFS) to compute the shortest, obstacle-free path from the agent's\n        current position to one of the valid adjacent cells.\n    4.  Appending an action to turn the agent to face the workshop.\n    5.  Appending the 'USE' action to perform the crafting.\n\n    Args:\n        env: The environment instance, providing access to the game state and world data.\n        item (str): The name of the item to be crafted (e.g., 'plank', 'stick').\n\n    Returns:\n        list: A sequence of integer actions (0-4) to execute for crafting the item.\n\n    Raises:\n        ValueError: If the item is not craftable, or the required workshop does not exist\n                    or is completely inaccessible.\n        RuntimeError: If no valid path to the required workshop can be found.\n    \"\"\"\n    # Action constants for clarity, matching the environment's action specification.\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # 1. Get Recipe Information: Find which workshop is required for the item.\n    cookbook = env.world.cookbook\n    item_idx = cookbook.index[item]\n\n    if item_idx is None or item_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' is not a known craftable item.\")\n\n    recipe = cookbook.recipes[item_idx]\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 2. Find Target Destinations: Identify all empty cells adjacent to the required workshop.\n    grid = env._current_state.grid\n    grid_width, grid_height, _ = grid.shape\n    \n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx] == 1)\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{required_workshop_name}' not found in the environment.\")\n\n    # Store a map from a valid destination cell to the workshop cell it's adjacent to.\n    # This helps in determining which way to face at the end of the path.\n    destination_to_workshop_map = {}\n    for ws_pos in workshop_locations:\n        x, y = ws_pos\n        # Check neighbors in four directions (Up, Down, Left, Right)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            # Ensure the neighbor is within grid bounds and is an empty cell\n            if 0 <= nx < grid_width and 0 <= ny < grid_height and np.sum(grid[nx, ny, :]) == 0:\n                adj_pos = (nx, ny)\n                destination_to_workshop_map[adj_pos] = tuple(ws_pos)\n\n    valid_destinations = set(destination_to_workshop_map.keys())\n    if not valid_destinations:\n        raise ValueError(f\"No accessible cells found next to workshop '{required_workshop_name}'.\")\n\n    # 3. Pathfinding: Use Breadth-First Search (BFS) to find the shortest path.\n    start_pos = env._current_state.pos\n    \n    # If agent is already at a valid location, no movement is needed.\n    if start_pos in valid_destinations:\n        path = []\n        final_pos = start_pos\n    else:\n        # The queue stores tuples of (current_position, path_to_get_here)\n        queue = collections.deque([(start_pos, [])])\n        visited = {start_pos}\n        path = None\n        final_pos = None\n\n        while queue:\n            current_pos, current_path = queue.popleft()\n\n            if current_pos in valid_destinations:\n                path = current_path\n                final_pos = current_pos\n                break  # Found the shortest path\n\n            # Explore neighbors using (dx, dy, action) tuples\n            moves = [(-1, 0, LEFT), (1, 0, RIGHT), (0, -1, DOWN), (0, 1, UP)]\n            for dx, dy, action in moves:\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                nx, ny = next_pos\n\n                if (0 <= nx < grid_width and 0 <= ny < grid_height and\n                        next_pos not in visited and np.sum(grid[nx, ny, :]) == 0):\n                    visited.add(next_pos)\n                    new_path = current_path + [action]\n                    queue.append((next_pos, new_path))\n    \n    if path is None:\n        raise RuntimeError(f\"Cannot find a valid path to the '{required_workshop_name}' workshop.\")\n\n    # 4. Generate Final Action Sequence\n    actions = path\n\n    # Determine the direction to face the workshop from the final position.\n    # Issuing a move command towards a blocked cell (the workshop) will make the agent turn to face it.\n    workshop_to_face = destination_to_workshop_map[final_pos]\n    dx = workshop_to_face[0] - final_pos[0]\n    dy = workshop_to_face[1] - final_pos[1]\n\n    face_action = -1\n    if dy == 1: face_action = UP\n    elif dy == -1: face_action = DOWN\n    elif dx == 1: face_action = RIGHT\n    elif dx == -1: face_action = LEFT\n    \n    if face_action != -1:\n        actions.append(face_action)\n    \n    # Add the 'USE' action to perform the craft.\n    actions.append(USE)\n\n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n\n    This function implements a robust strategy:\n    1.  **Recipe Lookup**: It first consults the cookbook to find which specific\n        workshop is required to craft the item.\n    2.  **Target Identification**: It identifies all empty, accessible cells\n        adjacent to all instances of the required workshop on the grid.\n    3.  **Pathfinding (BFS)**: It uses a Breadth-First Search (BFS) algorithm to\n        find the shortest, obstacle-free path from the agent's current position\n        to one of these target cells.\n    4.  **Positioning and Facing**: The generated path moves the agent to the\n        cell next to the workshop. It then adds an action to make the agent\n        turn and face the workshop. This works because attempting to move into the\n        workshop (a blocked cell) updates the agent's direction without changing\n        its position.\n    5.  **Craft Action**: Finally, it appends the 'USE' action to perform the craft.\n\n    Args:\n        env: The simulation environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of integer actions to be executed.\n\n    Raises:\n        ValueError: If the item is unknown, the required workshop doesn't exist,\n                    or no path can be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n\n    # 1. Look up the recipe to find the required workshop\n    item_idx = cookbook.index[item]\n    if item_idx is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all valid target positions (empty cells adjacent to the workshop)\n    # np.argwhere returns (row, col), which corresponds to (y, x)\n    workshop_locations_yx = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations_yx.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found on the grid.\")\n\n    H, W, _ = grid.shape\n    # We will use (x, y) coordinates for our pathfinding logic\n    # Action map: (dx, dy) for actions [DOWN(0), UP(1), LEFT(2), RIGHT(3)]\n    # DOWN: y-1, UP: y+1, LEFT: x-1, RIGHT: x+1\n    moves = {\n        0: (0, -1),  # DOWN\n        1: (0, 1),   # UP\n        2: (-1, 0),  # LEFT\n        3: (1, 0)    # RIGHT\n    }\n\n    # Store potential final positions for the agent (x, y)\n    target_positions = set()\n    for wy, wx in workshop_locations_yx:\n        for dx, dy in moves.values():\n            nx, ny = wx + dx, wy + dy\n            # Check if neighbor is in bounds and is empty\n            if 0 <= nx < W and 0 <= ny < H and grid[ny, nx, :].sum() == 0:\n                target_positions.add((nx, ny))\n    \n    if not target_positions:\n        raise ValueError(f\"No accessible locations next to workshop '{workshop_name}'.\")\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path to a target\n    start_pos = state.pos  # This is already in (x, y) format\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n\n    best_path = None\n    final_pos = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in target_positions:\n            best_path = path\n            final_pos = current_pos\n            break\n\n        # Explore neighbors\n        for action, (dx, dy) in moves.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            nx, ny = next_pos\n\n            # Check validity of the next position\n            if (0 <= nx < W and 0 <= ny < H and\n                    next_pos not in visited and\n                    grid[ny, nx, :].sum() == 0):\n                visited.add(next_pos)\n                queue.append((next_pos, path + [action]))\n\n    if best_path is None:\n        raise ValueError(\"Could not find a path to the workshop.\")\n\n    # 4. Determine the final action to face the workshop\n    # Find which workshop our final_pos is adjacent to\n    workshop_pos_xy = None\n    for wy, wx in workshop_locations_yx:\n        if abs(wx - final_pos[0]) + abs(wy - final_pos[1]) == 1:\n            workshop_pos_xy = (wx, wy)\n            break\n    \n    # Calculate direction from agent's final position to the workshop\n    dx = workshop_pos_xy[0] - final_pos[0]\n    dy = workshop_pos_xy[1] - final_pos[1]\n\n    face_action = -1\n    if (dx, dy) == (0, 1): face_action = 1  # Face UP\n    elif (dx, dy) == (0, -1): face_action = 0 # Face DOWN\n    elif (dx, dy) == (1, 0): face_action = 3 # Face RIGHT\n    elif (dx, dy) == (-1, 0): face_action = 2 # Face LEFT\n    \n    # 5. Combine path, face action, and use action\n    # The 'face_action' will attempt to move into the workshop, which is a\n    # blocked cell. This fails the move but updates the agent's direction.\n    actions = best_path + [face_action, 4]  # 4 is the USE action\n\n    return actions\n",
  "evaluation_result": [
    3.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    face it, and craft the specified item.\n\n    This function implements a robust strategy:\n    1.  Identifies the specific workshop required for the item from the recipe book.\n    2.  Locates all instances of that workshop in the current grid.\n    3.  Uses Breadth-First Search (BFS) to find the shortest, obstacle-free path \n        to a cell adjacent to the nearest reachable workshop.\n    4.  Determines the correct direction to face the workshop.\n    5.  Appends a turning action if the agent is not already facing the workshop after moving.\n    6.  Appends the 'USE' action to perform the craft.\n\n    Args:\n        env: The environment instance, providing access to the current state and world info.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A sequence of integer actions to be executed.\n        \n    Raises:\n        ValueError: If the item, recipe, or workshop is not found.\n        RuntimeError: If no path to a valid workshop location can be found.\n    \"\"\"\n    # 1. Find the correct workshop for the item from the cookbook\n    cookbook = env.world.cookbook\n    try:\n        item_idx = cookbook.index[item]\n    except KeyError:\n        raise ValueError(f\"Item '{item}' not found in cookbook index.\")\n\n    if item_idx not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n\n    recipe = cookbook.recipes[item_idx]\n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Set up for pathfinding\n    grid = env._current_state.grid\n    agent_pos_xy = env._current_state.pos  # Current agent position (x, y)\n    height, width, _ = grid.shape\n\n    # Define movement actions and their corresponding (dx, dy) changes\n    # 0: DOWN (y-1), 1: UP (y+1), 2: LEFT (x-1), 3: RIGHT (x+1)\n    moves = {\n        0: (0, -1),\n        1: (0, 1),\n        2: (-1, 0),\n        3: (1, 0),\n    }\n    action_for_move = {v: k for k, v in moves.items()}\n\n    # Create a boolean map of obstacles. Any non-empty cell is an obstacle.\n    obstacle_map = grid.sum(axis=2) > 0\n    # The agent's starting cell is not considered an obstacle for pathfinding.\n    obstacle_map[agent_pos_xy[1], agent_pos_xy[0]] = False\n    \n    # 3. Find all valid destination cells (adjacent to any instance of the workshop)\n    workshop_locations_yx = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations_yx.shape[0] == 0:\n        raise RuntimeError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    destinations = set()\n    workshop_locations_xy = workshop_locations_yx[:, ::-1] # Convert from (y,x) to (x,y)\n    for w_x, w_y in workshop_locations_xy:\n        for dx, dy in moves.values():\n            adj_x, adj_y = w_x + dx, w_y + dy\n            if 0 <= adj_x < width and 0 <= adj_y < height and not obstacle_map[adj_y, adj_x]:\n                destinations.add((adj_x, adj_y))\n\n    if not destinations:\n        raise RuntimeError(f\"No reachable cells are adjacent to any '{workshop_name}'.\")\n\n    # 4. Use Breadth-First Search (BFS) to find the shortest path\n    start_node = tuple(agent_pos_xy)\n    queue = collections.deque([(start_node, [])])  # (position, path_of_actions)\n    visited = {start_node}\n    path_to_workshop = None\n\n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n\n        if (curr_x, curr_y) in destinations:\n            path_to_workshop = path\n            break  # Found the shortest path\n\n        for action, (dx, dy) in moves.items():\n            next_x, next_y = curr_x + dx, curr_y + dy\n            next_pos = (next_x, next_y)\n            \n            if (0 <= next_x < width and 0 <= next_y < height and\n                    next_pos not in visited and not obstacle_map[next_y, next_x]):\n                visited.add(next_pos)\n                queue.append((next_pos, path + [action]))\n\n    if path_to_workshop is None:\n        raise RuntimeError(f\"Could not find a valid path to workshop '{workshop_name}'.\")\n\n    # 5. Determine final actions: move, turn (if necessary), and use\n    final_actions = list(path_to_workshop)\n    \n    # Determine the agent's final position after moving\n    final_pos_x, final_pos_y = agent_pos_xy\n    for action in path_to_workshop:\n        dx, dy = moves[action]\n        final_pos_x += dx\n        final_pos_y += dy\n    \n    # Find which workshop this final position is next to\n    target_workshop_pos = None\n    for w_x, w_y in workshop_locations_xy:\n        if abs(final_pos_x - w_x) + abs(final_pos_y - w_y) == 1:\n            target_workshop_pos = (w_x, w_y)\n            break\n            \n    # Determine the direction to face the workshop\n    face_dx = target_workshop_pos[0] - final_pos_x\n    face_dy = target_workshop_pos[1] - final_pos_y\n    facing_action = action_for_move[(face_dx, face_dy)]\n\n    # After moving, the agent's direction is set by the last move action.\n    # If this direction is not already facing the workshop, add a \"turn\" action.\n    # We assume an action towards a blocked cell results in a turn without movement.\n    if not path_to_workshop:  # Agent started adjacent to the workshop\n        if env._current_state.dir != facing_action:\n            final_actions.append(facing_action)\n    elif path_to_workshop[-1] != facing_action:\n        final_actions.append(facing_action)\n\n    final_actions.append(4)  # USE action\n\n    return final_actions\n",
  "evaluation_result": [
    3.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item by finding the\n    correct workshop and pathfinding to it.\n\n    This corrected implementation resolves the flaws of the original by:\n    1.  Looking up the item's recipe in the cookbook to identify the specific\n        workshop required (e.g., 'workshop0').\n    2.  Locating all instances of that specific workshop on the grid.\n    3.  Using Breadth-First Search (BFS), a proper pathfinding algorithm, to find\n        the shortest, obstacle-avoiding path to a walkable tile *adjacent* to\n        any of the workshop instances.\n    4.  Translating the found path into the correct sequence of movement actions\n        (UP, DOWN, LEFT, RIGHT). The final movement action naturally ensures the\n        agent is facing the workshop.\n    5.  Appending the 'USE' action to the sequence to perform the craft.\n    \"\"\"\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    start_pos = env._current_state.pos\n    width, height = grid.shape[:2]\n\n    # 1. Find the required workshop from the recipe\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook.\")\n\n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        # Item is a primitive or uncraftable, so no crafting actions are needed.\n        return []\n\n    required_workshop_name = recipe['_at']\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 2. Locate all instances of the required workshop\n    # The grid shape is (WIDTH, HEIGHT, ...), so np.argwhere returns (x, y) coordinates.\n    workshop_locations_np = np.argwhere(grid[:, :, required_workshop_idx])\n    workshop_coords = {tuple(coords) for coords in workshop_locations_np}\n\n    if not workshop_coords:\n        # Required workshop does not exist on the map.\n        return []\n\n    # Helper function to check if a tile is walkable (i.e., empty)\n    def is_walkable(pos):\n        x, y = pos\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        # A cell is walkable if there is nothing on it.\n        return grid[x, y].sum() == 0\n\n    # 3. Find all target cells: walkable cells adjacent to any workshop instance\n    target_adjacent_cells = set()\n    for wx, wy in workshop_coords:\n        # Check four neighbors\n        for move_dx, move_dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_pos = (wx + move_dx, wy + move_dy)\n            if is_walkable(adj_pos):\n                target_adjacent_cells.add(adj_pos)\n\n    if not target_adjacent_cells:\n        # No accessible spots next to any required workshop.\n        return []\n\n    # 4. BFS to find the shortest path of actions to an adjacent cell\n    # The state in the queue is (current_position, list_of_actions_to_get_here)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n\n    # Action codes and their corresponding (dx, dy) moves, based on CraftState.step\n    # pos = (x, y)\n    # Actions: DOWN:0, UP:1, LEFT:2, RIGHT:3, USE:4\n    moves = {\n        1: (0, 1),   # UP (+y)\n        0: (0, -1),  # DOWN (-y)\n        3: (1, 0),   # RIGHT (+x)\n        2: (-1, 0)   # LEFT (-x)\n    }\n    \n    while queue:\n        current_pos, actions = queue.popleft()\n\n        for action_code, (dx, dy) in moves.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n            if next_pos in visited:\n                continue\n\n            # Check if we have found a path to a target cell\n            if next_pos in target_adjacent_cells:\n                # The path is complete. The action `action_code` moves the agent\n                # to `next_pos` and makes it face the correct direction\n                # (towards the workshop).\n                final_actions = actions + [action_code, 4]  # Append last move, then USE\n                return final_actions\n\n            # If not a target, check if it's a valid intermediate step (must be walkable)\n            if is_walkable(next_pos):\n                visited.add(next_pos)\n                new_actions = actions + [action_code]\n                queue.append((next_pos, new_actions))\n\n    # If the queue becomes empty, no path was found to any target cell\n    return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}
