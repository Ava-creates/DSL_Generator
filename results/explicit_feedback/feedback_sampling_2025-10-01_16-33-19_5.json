{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a primitive item.\n\n    The strategy is as follows:\n    1.  Identify all non-traversable obstacles in the environment (e.g., water, stone).\n    2.  Find all instances of the target `primitive` on the grid.\n    3.  For each primitive, identify its valid adjacent, traversable cells. These are the \"target\"\n        cells for the agent to move to.\n    4.  Use Breadth-First Search (BFS) to find the shortest path of move actions from the agent's\n        current position to any of these target cells.\n    5.  Once at a target cell, determine the direction to face the primitive.\n    6.  Append a move action in that direction. This turns the agent to face the primitive. The agent\n        will \"bump\" into the primitive cell without moving, as it's non-traversable for movement.\n    7.  Append the 'USE' action to collect the primitive.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n    grid = state.grid\n    start_pos = tuple(state.pos)\n\n    # Step 1: Initialize mappings and get item/action indices\n    try:\n        primitive_idx = cookbook.index[primitive]\n    except KeyError:\n        return []  # Primitive does not exist in this world's cookbook\n\n    action_spec = env.action_specs()\n    ACTION_USE = action_spec['USE']\n    \n    # Map move actions to their corresponding (dx, dy) offsets\n    ACTION_OFFSETS = {\n        action_spec['DOWN']: (0, 1),\n        action_spec['UP']: (0, -1),\n        action_spec['LEFT']: (-1, 0),\n        action_spec['RIGHT']: (1, 0),\n    }\n\n    width, height, _ = grid.shape\n\n    # Step 2: Identify obstacles and target locations\n    # A cell is traversable if it does not contain any non-grabbable environmental items.\n    traversable_map = np.ones((width, height), dtype=bool)\n    for idx in world.non_grabbable_indices:\n        traversable_map[grid[:, :, idx] > 0] = False\n\n    # Find all locations of the primitive\n    primitive_locations = np.argwhere(grid[:, :, primitive_idx] > 0)\n    if primitive_locations.shape[0] == 0:\n        return []  # No instances of the primitive on the map\n\n    # Identify all valid adjacent cells to any primitive instance. These are our BFS targets.\n    target_positions = set()\n    for prim_pos in primitive_locations:\n        px, py = prim_pos\n        for dx, dy in ACTION_OFFSETS.values():\n            # The adjacent position is where the agent needs to stand\n            adj_pos = (px - dx, py - dy)\n            if 0 <= adj_pos[0] < width and 0 <= adj_pos[1] < height and traversable_map[adj_pos]:\n                target_positions.add(adj_pos)\n\n    if not target_positions:\n        return []  # The primitive is completely surrounded by obstacles\n\n    # Step 3: Pathfind with BFS\n    if start_pos in target_positions:\n        path_to_adjacent = []\n        final_pos = start_pos\n    else:\n        queue = deque([(start_pos, [])])  # (position, path_list)\n        visited = {start_pos}\n        path_to_adjacent = None\n        final_pos = None\n\n        while queue:\n            current_pos, path = queue.popleft()\n\n            if current_pos in target_positions:\n                path_to_adjacent = path\n                final_pos = current_pos\n                break  # Found the shortest path\n\n            for action, (dx, dy) in ACTION_OFFSETS.items():\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                if (0 <= next_pos[0] < width and 0 <= next_pos[1] < height and\n                        next_pos not in visited and traversable_map[next_pos]):\n                    visited.add(next_pos)\n                    queue.append((next_pos, path + [action]))\n        \n        if path_to_adjacent is None:\n            return []  # No path found to any target cell\n\n    # Step 4: Determine final turn and USE actions\n    # Find the primitive we are targeting from our final position to determine turn direction\n    turn_action = None\n    for action, (dx, dy) in ACTION_OFFSETS.items():\n        check_pos = (final_pos[0] + dx, final_pos[1] + dy)\n        if 0 <= check_pos[0] < width and 0 <= check_pos[1] < height:\n            if grid[check_pos[0], check_pos[1], primitive_idx] > 0:\n                turn_action = action\n                break\n    \n    if turn_action is None:\n        # Should not be reached if logic is correct, but is a safeguard\n        return []\n\n    # The final sequence: move, turn to face primitive, then collect\n    return path_to_adjacent + [turn_action, ACTION_USE]\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
