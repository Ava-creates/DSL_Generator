{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    Args:\n        env (CraftLab): The environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A sequence of actions to perform the craft task.\n    \"\"\"\n    # Action constants from the environment specification\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # Mapping from actions to coordinate changes (deltas) and vice-versa\n    action_to_delta = {\n        UP: (0, 1),\n        DOWN: (0, -1),\n        RIGHT: (1, 0),\n        LEFT: (-1, 0),\n    }\n    delta_to_action = {v: k for k, v in action_to_delta.items()}\n\n    # 1. Identify the correct workshop from the recipe\n    world = env.world\n    cookbook = world.cookbook\n    current_state = env._current_state\n    grid = current_state.grid\n    start_pos = tuple(current_state.pos)\n\n    item_idx = cookbook.index[item]\n    if item_idx not in cookbook.recipes:\n        # Item cannot be crafted (e.g., it's a primitive resource)\n        return []\n    \n    recipe = cookbook.recipes[item_idx]\n    if '_at' not in recipe:\n        # Item is crafted without a workshop, which is outside this function's scope.\n        return []\n    \n    required_workshop_idx = recipe['_at']\n\n    # 2. Find all valid target cells (empty cells adjacent to the required workshop)\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        # Required workshop does not exist on the map\n        return []\n\n    WIDTH, HEIGHT, _ = grid.shape\n    \n    def is_walkable(pos):\n        x, y = pos\n        if not (0 <= x < WIDTH and 0 <= y < HEIGHT):\n            return False\n        # A cell is walkable if it contains no objects.\n        return grid[x, y, :].sum() == 0\n\n    # Dictionary to map a valid target position to its corresponding workshop position\n    target_cells = {}\n    for pos in workshop_locations:\n        wx, wy = pos[0], pos[1]\n        for dx, dy in action_to_delta.values():\n            adj_pos = (wx + dx, wy + dy)\n            if is_walkable(adj_pos):\n                target_cells[adj_pos] = (wx, wy)\n\n    if not target_cells:\n        # No accessible cells next to any required workshop\n        return []\n\n    # 3. Pathfind to the nearest target cell using Breadth-First Search (BFS)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    path_to_target = None\n    final_pos = None\n\n    # Handle case where agent already starts at a target location\n    if start_pos in target_cells:\n        path_to_target = []\n        final_pos = start_pos\n    else:\n        while queue:\n            current_pos, path = queue.popleft()\n\n            for action, (dx, dy) in action_to_delta.items():\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                if next_pos in visited or not is_walkable(next_pos):\n                    continue\n\n                visited.add(next_pos)\n                new_path = path + [action]\n                \n                if next_pos in target_cells:\n                    path_to_target = new_path\n                    final_pos = next_pos\n                    queue.clear() # Stop searching once the shortest path is found\n                    break\n                \n                queue.append((next_pos, new_path))\n    \n    if path_to_target is None:\n        # No path exists to any target cell\n        return []\n\n    actions = list(path_to_target)\n    \n    # 4. Orient the agent to face the workshop\n    workshop_pos = target_cells[final_pos]\n    \n    # Determine the direction from the agent to the workshop\n    face_dx = workshop_pos[0] - final_pos[0]\n    face_dy = workshop_pos[1] - final_pos[1]\n    required_face_action = delta_to_action[(face_dx, face_dy)]\n\n    # Determine agent's direction after finishing the path\n    current_direction = current_state.dir\n    if actions:\n        current_direction = actions[-1]\n\n    # If not facing the workshop, perform a turn-in-place maneuver\n    if current_direction != required_face_action:\n        # Move one step away from the workshop, then one step back.\n        # This reorients the agent correctly while returning it to the target cell.\n        opposite_action = delta_to_action.get((-face_dx, -face_dy))\n        if opposite_action is not None:\n            # The cell opposite the workshop is where we came from, so it's walkable.\n            actions.append(opposite_action)\n            actions.append(required_face_action)\n\n    # 5. Add the USE action to craft the item\n    actions.append(USE)\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to execute.\n    \"\"\"\n    world = env.world\n    state = env._current_state\n    cookbook = world.cookbook\n\n    # 1. Find the recipe and required workshop for the item\n    goal_idx = cookbook.index[item]\n    if goal_idx is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook.\")\n\n    recipe = cookbook.recipes.get(goal_idx)\n    if not recipe or '_at' not in recipe:\n        raise ValueError(f\"No crafting recipe or workshop found for item '{item}'.\")\n\n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all locations of the required workshop and their valid adjacent cells\n    grid = state.grid\n    (width, height, _) = grid.shape\n    \n    workshop_positions = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_positions.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    # A cell is walkable if it has no items/terrain on it\n    walkable_mask = (np.sum(grid, axis=2) == 0)\n\n    # Add the agent's current position as walkable for the start of the path\n    start_pos = tuple(state.pos)\n    walkable_mask[start_pos[0], start_pos[1]] = True\n\n    # Identify all valid, walkable target cells adjacent to any required workshop\n    target_cells = {} # Map target cell -> corresponding workshop cell\n    for pos in workshop_positions:\n        wx, wy = pos\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_pos = (wx + dx, wy + dy)\n            if 0 <= adj_pos[0] < width and 0 <= adj_pos[1] < height:\n                if walkable_mask[adj_pos[0], adj_pos[1]]:\n                    target_cells[adj_pos] = tuple(pos)\n    \n    if not target_cells:\n        raise RuntimeError(f\"No accessible cells next to a '{workshop_name}'.\")\n\n    # 3. Pathfind from agent's position to the nearest target cell using BFS\n    queue = collections.deque([(start_pos, [])]) # (current_pos, path_to_here)\n    visited = {start_pos}\n    \n    path_to_target = None\n    \n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in target_cells:\n            path_to_target = path + [current_pos]\n            break\n\n        x, y = current_pos\n        for dx, dy, action in [(0, -1, 0), (0, 1, 1), (-1, 0, 2), (1, 0, 3)]: # UP, DOWN, LEFT, RIGHT\n            next_pos = (x + dx, y + dy)\n            if 0 <= next_pos[0] < width and 0 <= next_pos[1] < height and \\\n               walkable_mask[next_pos[0], next_pos[1]] and next_pos not in visited:\n                \n                visited.add(next_pos)\n                new_path = path + [current_pos]\n                queue.append((next_pos, new_path))\n\n    if path_to_target is None:\n        raise RuntimeError(f\"Cannot find a path to a '{workshop_name}'.\")\n\n    # 4. Convert the path of coordinates into a sequence of move actions\n    actions = []\n    # Path includes the start point, so iterate from the second element\n    for i in range(1, len(path_to_target)):\n        prev_pos = path_to_target[i-1]\n        curr_pos = path_to_target[i]\n        dx = curr_pos[0] - prev_pos[0]\n        dy = curr_pos[1] - prev_pos[1]\n\n        if dy == -1: actions.append(0) # UP\n        elif dy == 1: actions.append(1) # DOWN\n        elif dx == -1: actions.append(2) # LEFT\n        elif dx == 1: actions.append(3) # RIGHT\n\n    # 5. Add final actions: turn to face the workshop, then use it\n    final_pos = path_to_target[-1]\n    workshop_pos = target_cells[final_pos]\n\n    dx = workshop_pos[0] - final_pos[0]\n    dy = workshop_pos[1] - final_pos[1]\n    \n    if dy == -1: actions.append(0) # Face UP\n    elif dy == 1: actions.append(1) # Face DOWN\n    elif dx == -1: actions.append(2) # Face LEFT\n    elif dx == 1: actions.append(3) # Face RIGHT\n    \n    actions.append(4) # USE\n\n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of integer actions to be executed.\n    \"\"\"\n    # Action constants from the environment's action spec\n    ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n    \n    # --- 1. Recipe Lookup: Find the required workshop for the item ---\n    cookbook = env.world.cookbook\n    goal_idx = cookbook.index[item]\n    if goal_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' has no recipe and cannot be crafted.\")\n    \n    recipe = cookbook.recipes[goal_idx]\n    # The recipe specifies the workshop with the '_at' key\n    required_workshop_idx = recipe.get('_at')\n    if required_workshop_idx is None:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n\n    # --- 2. Identify Valid Destinations ---\n    grid = env._current_state.grid\n    height, width, _ = grid.shape\n    \n    # Create a mask of all walkable cells (where the sum of features is 0)\n    walkable_mask = grid.sum(axis=2) == 0\n    \n    # Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found on the map.\")\n\n    destinations = set()\n    # For each workshop, find its adjacent walkable cells\n    for y, x in workshop_locations:\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ny, nx = y + dy, x + dx\n            if 0 <= ny < height and 0 <= nx < width and walkable_mask[ny, nx]:\n                # Add as (x, y) tuple to match agent's position format\n                destinations.add((nx, ny))\n    \n    if not destinations:\n        raise ValueError(\"No accessible location next to the required workshop.\")\n\n    # --- 3. Robust Pathfinding (Breadth-First Search) ---\n    start_pos = env._current_state.pos # (x, y)\n    \n    # If already next to a workshop, no move actions needed.\n    if start_pos in destinations:\n        path = []\n        final_pos = start_pos\n    else:\n        queue = collections.deque([(start_pos, [])]) # ((x, y), path)\n        visited = {start_pos}\n        path = None\n        final_pos = None\n\n        while queue:\n            current_pos, current_path = queue.popleft()\n\n            if current_pos in destinations:\n                path = current_path\n                final_pos = current_pos\n                break # Found the shortest path\n\n            # Explore neighbors: UP, DOWN, LEFT, RIGHT\n            # Note: Position is (x,y), Grid is (y,x)\n            for move_action, (dx, dy) in zip(\n                [ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT],\n                [(0, -1), (0, 1), (-1, 0), (1, 0)]\n            ):\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                nx, ny = next_pos\n\n                if (0 <= nx < width and 0 <= ny < height and\n                        next_pos not in visited and walkable_mask[ny, nx]):\n                    visited.add(next_pos)\n                    new_path = current_path + [move_action]\n                    queue.append((next_pos, new_path))\n        \n        if path is None:\n            raise ValueError(\"Cannot find a path to the workshop.\")\n\n    # --- 4. Determine Final Orientation and USE Action ---\n    # Find the specific workshop this final_pos is adjacent to\n    workshop_pos = None\n    for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        ny, nx = final_pos[1] + dy, final_pos[0] + dx\n        if 0 <= ny < height and 0 <= nx < width and grid[ny, nx, required_workshop_idx]:\n            workshop_pos = (nx, ny)\n            break\n            \n    # Determine the direction from the agent to the workshop\n    delta_x = workshop_pos[0] - final_pos[0]\n    delta_y = workshop_pos[1] - final_pos[1]\n\n    # The \"turn\" action is a move towards the blocking workshop cell\n    if delta_y == -1: turn_action = ACTION_UP\n    elif delta_y == 1: turn_action = ACTION_DOWN\n    elif delta_x == -1: turn_action = ACTION_LEFT\n    elif delta_x == 1: turn_action = ACTION_RIGHT\n    else:\n        raise RuntimeError(\"Logic error: final position is not adjacent to workshop.\")\n\n    # Final action sequence: path to location -> turn to face -> use\n    actions = path + [turn_action, ACTION_USE]\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    orient the agent, and craft the specified item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to be executed.\n                   Returns an empty list if crafting is not possible.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n\n    # 1. Look up the recipe to find the required workshop type.\n    try:\n        goal_idx = cookbook.index[item]\n        if goal_idx not in cookbook.recipes:\n            # This item is a primitive or doesn't have a recipe.\n            return []\n        recipe = cookbook.recipes[goal_idx]\n        workshop_name = recipe['_at']\n        workshop_idx = cookbook.index[workshop_name]\n    except (KeyError, IndexError):\n        # The item or its recipe is unknown.\n        return []\n\n    # 2. Find all valid, empty target cells adjacent to the required workshop.\n    grid = state.grid\n    workshop_locs = np.argwhere(grid[:, :, workshop_idx])\n\n    if workshop_locs.shape[0] == 0:\n        # Required workshop does not exist in the current environment.\n        return []\n\n    # A cell is blocked if any object is on it.\n    occupancy_grid = grid.sum(axis=2) > 0\n    height, width = occupancy_grid.shape\n    \n    target_cells = set()\n    for w_x, w_y in workshop_locs:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = w_x + dx, w_y + dy\n            # Check if adjacent cell is within bounds and is empty.\n            if 0 <= adj_x < height and 0 <= adj_y < width and not occupancy_grid[adj_x, adj_y]:\n                target_cells.add((adj_x, adj_y))\n\n    if not target_cells:\n        # All workshops are surrounded by obstacles.\n        return []\n\n    # 3. Use Breadth-First Search (BFS) for obstacle-aware pathfinding.\n    start_pos = tuple(state.pos)\n    \n    # Action mapping: action_id -> (dx, dy)\n    # 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    action_deltas = {0: (0, -1), 1: (0, 1), 2: (-1, 0), 3: (1, 0)}\n    \n    queue = collections.deque([(start_pos, [])]) # (position, path_of_actions)\n    visited = {start_pos}\n    \n    path_to_target = []\n    final_pos = None\n\n    # Handle case where agent is already at a target cell\n    if start_pos in target_cells:\n        final_pos = start_pos\n    else:\n        while queue:\n            current_pos, path = queue.popleft()\n\n            for action, (dx, dy) in action_deltas.items():\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                \n                # Check bounds and visited\n                if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width) or next_pos in visited:\n                    continue\n\n                # If we found a path to a target cell\n                if next_pos in target_cells:\n                    path_to_target = path + [action]\n                    final_pos = next_pos\n                    queue.clear() # End search\n                    break\n                \n                # If it's a valid empty cell, add to queue\n                if not occupancy_grid[next_pos[0], next_pos[1]]:\n                    visited.add(next_pos)\n                    queue.append((next_pos, path + [action]))\n\n    if final_pos is None:\n        # No reachable path to any workshop.\n        return []\n\n    # 4. Determine final orientation and append turn + use actions.\n    # Find the workshop this final_pos is adjacent to.\n    target_workshop_pos = None\n    for w_x, w_y in workshop_locs:\n        if abs(final_pos[0] - w_x) + abs(final_pos[1] - w_y) == 1:\n            target_workshop_pos = (w_x, w_y)\n            break\n            \n    # Calculate direction from agent to workshop to determine turn action.\n    # We assume bumping into a wall changes direction without moving.\n    dx = target_workshop_pos[0] - final_pos[0]\n    dy = target_workshop_pos[1] - final_pos[1]\n    \n    turn_action = -1\n    if dx == 1:  turn_action = 3 # RIGHT\n    elif dx == -1: turn_action = 2 # LEFT\n    elif dy == 1:  turn_action = 1 # UP\n    elif dy == -1: turn_action = 0 # DOWN\n\n    final_actions = path_to_target\n    if turn_action != -1:\n      final_actions.append(turn_action)\n      \n    final_actions.append(4)  # USE action\n\n    return final_actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specific item.\n    The plan is as follows:\n    1.  Identify the recipe and the specific workshop required for the item.\n    2.  Find all instances of that workshop on the grid.\n    3.  Determine the closest workshop instance to the agent's current position.\n    4.  Identify all empty, walkable cells adjacent to this workshop. These are the target destinations.\n    5.  Use Breadth-First Search (BFS) to find the shortest, obstacle-avoiding path to one of these target cells.\n    6.  If a path is found, determine the agent's orientation after following the path.\n    7.  If the agent is not facing the workshop, append a 2-move sequence (e.g., LEFT then RIGHT) to turn the agent in place.\n    8.  Append the 'USE' action to perform the crafting.\n    9.  Return the complete list of actions.\n    \"\"\"\n    # Action constants from the environment's action_specs\n    ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n    # Direction constants (assuming they match action constants for simplicity)\n    DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT = 0, 1, 2, 3\n\n    world = env.world\n    cookbook = world.cookbook\n    state = env._current_state\n    grid = state.grid\n    start_pos = tuple(state.pos)\n\n    # 1. Find the required workshop from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx not in cookbook.recipes:\n        return []  # Item is a primitive or has no recipe\n    \n    recipe = cookbook.recipes[item_idx]\n    if '_at' not in recipe:\n        return []  # Recipe does not require a workshop\n    \n    required_workshop_idx = recipe['_at']\n\n    # 2. Find all locations of the required workshop\n    # np.argwhere returns (row, col) i.e., (y, x). We convert to (x, y) for consistency with agent position.\n    workshop_locations_yx = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations_yx.shape[0] == 0:\n        return []  # Required workshop does not exist on the map\n\n    # 3. Find the closest workshop to the agent\n    min_dist = float('inf')\n    closest_workshop_pos = None\n    agent_pos_arr = np.array(start_pos)\n    for pos_yx in workshop_locations_yx:\n        pos_xy = pos_yx[::-1]  # Flip to (x, y)\n        dist = np.sum(np.abs(agent_pos_arr - pos_xy))  # Manhattan distance\n        if dist < min_dist:\n            min_dist = dist\n            closest_workshop_pos = tuple(pos_xy)\n\n    # 4. Use BFS to find a path to a cell adjacent to the workshop\n    # Create a walkability grid. A cell is blocked if it contains any non-grabbable item.\n    walkable = np.ones(grid.shape[:2], dtype=bool)\n    for i in world.non_grabbable_indices:\n        walkable[grid[:, :, i] == 1] = False\n\n    # Define target cells: walkable cells adjacent to the workshop\n    target_cells = set()\n    ws_x, ws_y = closest_workshop_pos\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_x, adj_y = ws_x + dx, ws_y + dy\n        if 0 <= adj_x < grid.shape[1] and 0 <= adj_y < grid.shape[0] and walkable[adj_y, adj_x]:\n            target_cells.add((adj_x, adj_y))\n\n    if not target_cells:\n        return []  # No accessible cell next to the workshop\n\n    # 5. Run BFS to find the shortest path\n    queue = collections.deque([(start_pos, [])])  # (position, path)\n    visited = {start_pos}\n    path_to_dest = None\n    final_pos = None\n\n    if start_pos in target_cells:\n        path_to_dest = []\n        final_pos = start_pos\n    else:\n        while queue:\n            current_pos, path = queue.popleft()\n            # Moves defined as (dx, dy, action)\n            moves = [(0, -1, ACTION_UP), (0, 1, ACTION_DOWN), (-1, 0, ACTION_LEFT), (1, 0, ACTION_RIGHT)]\n            for dx, dy, action in moves:\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                nx, ny = next_pos\n                if (0 <= nx < grid.shape[1] and 0 <= ny < grid.shape[0] and\n                        walkable[ny, nx] and next_pos not in visited):\n                    \n                    new_path = path + [action]\n                    if next_pos in target_cells:\n                        path_to_dest = new_path\n                        final_pos = next_pos\n                        queue.clear()  # Path found, stop searching\n                        break\n                    \n                    visited.add(next_pos)\n                    queue.append((next_pos, new_path))\n    \n    if path_to_dest is None:\n        return []  # No path found\n\n    actions = path_to_dest\n\n    # 6. Determine the required orientation to face the workshop from the final position\n    final_x, final_y = final_pos\n    ws_x, ws_y = closest_workshop_pos\n    \n    required_dir = -1\n    if ws_x > final_x: required_dir = DIR_RIGHT\n    elif ws_x < final_x: required_dir = DIR_LEFT\n    elif ws_y > final_y: required_dir = DIR_DOWN  # Assuming y increases downwards (standard for grids)\n    else: required_dir = DIR_UP # ws_y < final_y\n\n    # 7. Determine current orientation and add turning actions if necessary\n    if not actions:  # Agent started at the destination\n        current_dir = state.dir\n    else:\n        current_dir = actions[-1]  # Direction is the same as the last move action\n\n    if current_dir != required_dir:\n        # A 2-move sequence can turn the agent without net displacement.\n        # e.g., to face LEFT, move RIGHT then LEFT.\n        turn_sequences = {\n            DIR_UP: [ACTION_DOWN, ACTION_UP],\n            DIR_DOWN: [ACTION_UP, ACTION_DOWN],\n            DIR_LEFT: [ACTION_RIGHT, ACTION_LEFT],\n            DIR_RIGHT: [ACTION_LEFT, ACTION_RIGHT],\n        }\n        actions.extend(turn_sequences[required_dir])\n    \n    # 8. Add the USE action to craft the item\n    actions.append(ACTION_USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function implements a Breadth-First Search (BFS) algorithm to find the \n    shortest path to a valid cell adjacent to the required workshop. It then\n    ensures the agent is facing the workshop before issuing the craft command.\n    \"\"\"\n    \n    # Action constants from the DSL and environment behavior\n    ACTION_DOWN = 0\n    ACTION_UP = 1\n    ACTION_LEFT = 2\n    ACTION_RIGHT = 3\n    ACTION_USE = 4\n\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # 1. Get Goal Info: Find the required workshop for the item from the cookbook.\n    try:\n        goal_idx = cookbook.index[item]\n        if goal_idx not in cookbook.recipes:\n             raise ValueError(f\"Item '{item}' has no recipe and cannot be crafted.\")\n        recipe = cookbook.recipes[goal_idx]\n        if '_at' not in recipe:\n            raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n        workshop_name = recipe['_at']\n        workshop_idx = cookbook.index[workshop_name]\n    except KeyError:\n        raise ValueError(f\"Item '{item}' or its recipe/workshop not found in cookbook.\")\n\n    # 2. Find Target Locations: Identify all empty cells adjacent to the required workshop type.\n    grid = state.grid\n    height, width, _ = grid.shape\n    \n    # np.argwhere returns (row, col), which corresponds to (y, x)\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"No workshop '{workshop_name}' found on the map.\")\n\n    # Find all valid, empty, adjacent cells to serve as potential destinations\n    possible_destinations = set()\n    for wy, wx in workshop_locations:\n        # Check neighbors: up, down, left, right\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ny, nx = wy + dy, wx + dx\n            # A cell is a valid destination if it's within bounds and is empty\n            if 0 <= ny < height and 0 <= nx < width and grid[ny, nx, :].sum() == 0:\n                possible_destinations.add((ny, nx))\n    \n    if not possible_destinations:\n        raise ValueError(f\"No accessible empty cells next to a '{workshop_name}' workshop.\")\n\n    # 3. Run BFS to find the shortest path to a target cell.\n    # Agent position is (x, y), but numpy indexing is (y, x), so we reverse it.\n    start_pos = tuple(reversed(state.pos)) # (y, x)\n    \n    queue = collections.deque([(start_pos, [start_pos])]) # Queue stores (pos, path_list)\n    visited = {start_pos}\n    final_path = None\n\n    # Optimization: if agent is already at a valid destination, path is just its current position\n    if start_pos in possible_destinations:\n        final_path = [start_pos]\n    else:\n        while queue:\n            current_pos, path = queue.popleft()\n\n            # Explore neighbors in a fixed order: UP, DOWN, LEFT, RIGHT moves\n            cy, cx = current_pos\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]: \n                neighbor_pos = (cy + dy, cx + dx)\n\n                # If neighbor is a destination, we found the shortest path\n                if neighbor_pos in possible_destinations:\n                    final_path = path + [neighbor_pos]\n                    break \n                \n                # If neighbor is a valid empty cell for path continuation, add to queue\n                if (0 <= neighbor_pos[0] < height and 0 <= neighbor_pos[1] < width and\n                        neighbor_pos not in visited and\n                        grid[neighbor_pos[0], neighbor_pos[1], :].sum() == 0):\n                    visited.add(neighbor_pos)\n                    queue.append((neighbor_pos, path + [neighbor_pos]))\n            if final_path:\n                break\n    \n    if final_path is None:\n        raise RuntimeError(f\"Could not find a path to a '{workshop_name}' workshop.\")\n\n    # 4. Convert the list of coordinates (path) to a list of action integers.\n    actions = []\n    # The path includes the start position, so we iterate from the first move.\n    for i in range(len(final_path) - 1):\n        y1, x1 = final_path[i]\n        y2, x2 = final_path[i+1]\n        \n        dy, dx = y2 - y1, x2 - x1\n        \n        if dy == 1: actions.append(ACTION_DOWN)\n        elif dy == -1: actions.append(ACTION_UP)\n        elif dx == 1: actions.append(ACTION_RIGHT)\n        elif dx == -1: actions.append(ACTION_LEFT)\n\n    # 5. Ensure Agent Faces the Workshop and Add USE Action.\n    # The USE action is directional. We must ensure the agent faces the workshop.\n    # This is achieved by adding a final move action if the agent isn't already oriented correctly.\n    # It is assumed that attempting to move into a blocked cell (the workshop) changes the agent's\n    # direction without changing its position.\n    \n    # Identify the specific workshop we are moving next to.\n    fy, fx = final_path[-1]\n    target_workshop_pos = None\n    for wy, wx in workshop_locations:\n        if abs(fy - wy) + abs(fx - wx) == 1:\n            target_workshop_pos = (wy, wx)\n            break\n    \n    # Determine the action that corresponds to facing the workshop from the final position.\n    wy, wx = target_workshop_pos\n    required_face_action = -1\n    if wx > fx: required_face_action = ACTION_RIGHT # Workshop is to the right\n    elif wx < fx: required_face_action = ACTION_LEFT  # Workshop is to the left\n    elif wy > fy: required_face_action = ACTION_DOWN  # Workshop is below\n    elif wy < fy: required_face_action = ACTION_UP    # Workshop is above\n    \n    # The last move in the path sets the agent's orientation. If it's not the correct one,\n    # we add an extra \"turn\" move.\n    last_move_action = actions[-1] if actions else None\n    \n    if last_move_action != required_face_action:\n        actions.append(required_face_action)\n\n    actions.append(ACTION_USE)\n    \n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1.  Looking up the recipe to identify the specific workshop required for the item.\n    2.  Identifying all valid, empty cells adjacent to all instances of that workshop type.\n    3.  Using a Breadth-First Search (BFS) algorithm to find the shortest, obstacle-free\n        path from the agent's current position to the nearest of these target cells.\n    4.  Generating the action sequence for movement, turning to face the workshop, and\n        finally using it to craft the item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to be crafted.\n\n    Returns:\n        list[int]: A list of integer actions to be executed sequentially.\n\n    Raises:\n        ValueError: If the item has no recipe, the recipe is invalid, or the\n                    required workshop does not exist or is completely inaccessible.\n        RuntimeError: If no path can be found to an accessible workshop.\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    item_idx = cookbook.index[item]\n\n    # 1. Look up the recipe to find the required workshop\n    if item_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' cannot be crafted (no recipe found).\")\n    \n    recipe = cookbook.recipes[item_idx]\n    required_workshop_name = recipe.get('_at')\n    if not required_workshop_name:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n    \n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 2. Identify all reachable target cells adjacent to the required workshops\n    grid = state.grid\n    h, w, _ = grid.shape\n    \n    # A cell is blocked if it contains any object. The sum over the one-hot\n    # encoded 'kinds' dimension will be > 0 for blocked cells.\n    is_blocked = grid.sum(axis=2) > 0\n    \n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"No '{required_workshop_name}' found in the environment.\")\n        \n    # Target cells are empty cells adjacent to any instance of the required workshop\n    target_cells = set()\n    # This map stores which workshop a target cell is adjacent to, needed for final orientation\n    target_map = {} \n    \n    for ws_pos in workshop_locations:\n        r, c = tuple(ws_pos)\n        # Check 4 cardinal neighbors (UP, DOWN, LEFT, RIGHT)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w and not is_blocked[nr, nc]:\n                neighbor_pos = (nr, nc)\n                if neighbor_pos not in target_cells:\n                    target_cells.add(neighbor_pos)\n                    target_map[neighbor_pos] = (r, c)\n\n    if not target_cells:\n        raise ValueError(f\"All instances of '{required_workshop_name}' are surrounded and inaccessible.\")\n\n    # 3. Use BFS to find the shortest path to a target cell\n    start_pos = tuple(state.pos)\n    \n    # If agent is already at a valid location, no movement is needed\n    if start_pos in target_cells:\n        path = []\n        destination = start_pos\n    else:\n        queue = collections.deque([start_pos])\n        visited = {start_pos}\n        # parent dict stores {child_pos: (parent_pos, action_to_reach_child)} for path reconstruction\n        parent = {start_pos: (None, None)}\n        \n        destination = None\n        \n        while queue:\n            curr_pos = queue.popleft()\n            \n            if curr_pos in target_cells:\n                destination = curr_pos\n                break # Found the closest target cell\n                \n            r, c = curr_pos\n            # Moves defined as (dr, dc, action_id) corresponding to DOWN, UP, LEFT, RIGHT\n            moves = [(-1, 0, 0), (1, 0, 1), (0, -1, 2), (0, 1, 3)]\n            \n            for dr, dc, action in moves:\n                next_pos = (r + dr, c + dc)\n                nr, nc = next_pos\n                \n                # Check bounds, if it's walkable, and if we've visited it\n                if 0 <= nr < h and 0 <= nc < w and not is_blocked[nr, nc] and next_pos not in visited:\n                    visited.add(next_pos)\n                    parent[next_pos] = (curr_pos, action)\n                    queue.append(next_pos)\n\n        if destination is None:\n            raise RuntimeError(f\"Could not find a path to an accessible '{required_workshop_name}'.\")\n            \n        # Reconstruct path by backtracking from the destination\n        path = []\n        curr = destination\n        while curr != start_pos:\n            prev, action = parent[curr]\n            path.append(action)\n            curr = prev\n        path.reverse()\n\n    # 4. Determine final orientation and USE action\n    final_actions = list(path)\n    \n    workshop_pos = target_map[destination]\n    dest_r, dest_c = destination\n    ws_r, ws_c = workshop_pos\n    \n    # Calculate difference to determine which way to face\n    dr, dc = ws_r - dest_r, ws_c - dest_c\n    \n    turn_action = -1\n    if dr == -1: turn_action = 0 # Face DOWN\n    elif dr == 1: turn_action = 1 # Face UP\n    elif dc == -1: turn_action = 2 # Face LEFT\n    elif dc == 1: turn_action = 3 # Face RIGHT\n    else:\n        # This case should not be reached if target_map logic is correct\n        raise RuntimeError(\"Pathfinding error: destination is not adjacent to the workshop.\")\n\n    final_actions.append(turn_action)\n    final_actions.append(4) # USE action\n\n    return final_actions\n",
  "evaluation_result": [
    1.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop, face it, and craft an item.\n\n    This function implements a robust strategy to solve the crafting task by:\n    1.  **Recipe Lookup:** Identifying the specific workshop required to craft the given `item` by consulting the environment's cookbook.\n    2.  **Target Identification:** Finding all valid, empty cells adjacent to every instance of the required workshop. These become the pathfinding goals.\n    3.  **Pathfinding:** Using a Breadth-First Search (BFS) algorithm to find the shortest, obstacle-free path from the agent's current position to the nearest valid target cell.\n    4.  **Orientation:** Calculating the necessary turn action to make the agent face the workshop from its final position.\n    5.  **Action Generation:** Assembling the complete action sequence: movement, turning, and the final 'USE' action.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of integer actions to be executed in sequence. Returns an empty\n                   list if crafting is not possible (e.g., no path, no workshop).\n    \"\"\"\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    start_pos = tuple(env._current_state.pos)\n\n    # 1. Find the required workshop from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' has no recipe.\")\n    \n    recipe = cookbook.recipes[item_idx]\n    if '_at' not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop (_at).\")\n        \n    workshop_name = recipe['_at']\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all empty, accessible cells adjacent to the required workshop type\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        # Required workshop does not exist in the world\n        return []\n\n    # Map target adjacent cells to their corresponding workshop\n    # This helps later in determining which way to face\n    target_to_workshop = {}\n    h, w, _ = grid.shape\n    for wx, wy in workshop_locations:\n        # Check four neighbors (up, down, left, right)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = wx + dx, wy + dy\n            # Ensure neighbor is within bounds and is an empty cell\n            if 0 <= nx < w and 0 <= ny < h and grid[nx, ny, :].sum() == 0:\n                if (nx, ny) not in target_to_workshop:\n                    target_to_workshop[(nx, ny)] = (wx, wy)\n    \n    if not target_to_workshop:\n        # No empty cells next to any required workshop\n        return []\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path to a target cell\n    # Check if we are already at a valid target location\n    if start_pos in target_to_workshop:\n        path = []\n        final_pos = start_pos\n    else:\n        queue = collections.deque([(start_pos, [])]) # (position, path_list)\n        visited = {start_pos}\n        path = None\n        final_pos = None\n\n        # Action mapping: action_code -> (dx, dy)\n        moves = {\n            0: (0, -1),  # DOWN\n            1: (0, 1),   # UP\n            2: (-1, 0),  # LEFT\n            3: (1, 0),   # RIGHT\n        }\n\n        while queue:\n            (cx, cy), current_path = queue.popleft()\n\n            if (cx, cy) in target_to_workshop:\n                path = current_path\n                final_pos = (cx, cy)\n                break  # Found the shortest path\n\n            for action, (dx, dy) in moves.items():\n                nx, ny = cx + dx, cy + dy\n\n                if 0 <= nx < w and 0 <= ny < h and (nx, ny) not in visited:\n                    # Pathfind only through empty cells\n                    if grid[nx, ny, :].sum() == 0:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), current_path + [action]))\n    \n    if path is None:\n        # No path found from agent's position to any target cell\n        return []\n\n    # 4. Determine final orientation and USE action\n    actions = list(path)\n    workshop_pos = np.array(target_to_workshop[final_pos])\n    agent_final_pos = np.array(final_pos)\n    \n    delta = workshop_pos - agent_final_pos\n    \n    turn_action = -1\n    if tuple(delta) == (0, -1): turn_action = 0  # Face DOWN\n    elif tuple(delta) == (0, 1): turn_action = 1   # Face UP\n    elif tuple(delta) == (-1, 0): turn_action = 2  # Face LEFT\n    elif tuple(delta) == (1, 0): turn_action = 3   # Face RIGHT\n\n    if turn_action != -1:\n        actions.append(turn_action)\n    \n    actions.append(4)  # USE action to craft\n\n    return actions\n",
  "evaluation_result": [
    6.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find the correct workshop, move to a\n    cell adjacent to it, turn to face it, and then use it to craft the item.\n\n    This implementation uses Breadth-First Search (BFS) to find the shortest\n    obstacle-avoiding path to the workshop.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A sequence of action integers to be executed.\n\n    Raises:\n        ValueError: If the item has no recipe, no required workshop is found,\n                    or no path to a workshop exists.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n    grid = state.grid\n    height, width, _ = grid.shape\n\n    # 1. Find the required workshop for the item from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx is None or item_idx not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    recipe = cookbook.recipes[item_idx]\n    if \"_at\" not in recipe:\n        raise ValueError(f\"Recipe for {item} does not specify a workshop (_at).\")\n\n    workshop_name = recipe[\"_at\"]\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Identify all valid target cells (empty cells adjacent to the workshop)\n    # np.argwhere returns (row, col), which corresponds to (y, x)\n    workshop_locations_yx = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations_yx.size == 0:\n        raise ValueError(f\"No '{workshop_name}' found in the environment.\")\n\n    target_cells = set()\n    # A map to find which workshop a target cell is adjacent to\n    workshop_for_target = {}\n\n    for y, x in workshop_locations_yx:\n        # Check 4 adjacent cells (UP, DOWN, LEFT, RIGHT)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            # Check if the adjacent cell is within grid bounds\n            if 0 <= nx < width and 0 <= ny < height:\n                # A cell is empty if its feature vector sums to 0\n                if grid[ny, nx, :].sum() == 0:\n                    target_pos = (nx, ny)\n                    target_cells.add(target_pos)\n                    # Store the original workshop pos for the final turn\n                    workshop_for_target[target_pos] = (x, y)\n\n    if not target_cells:\n        raise ValueError(f\"No accessible empty location next to a '{workshop_name}' found.\")\n\n    # 3. Pathfinding using Breadth-First Search (BFS)\n    start_pos = tuple(state.pos)\n    \n    # Pre-calculate a boolean grid of blocked cells for faster lookups\n    blocked_grid = grid.sum(axis=2) > 0\n\n    queue = collections.deque([start_pos])\n    visited = {start_pos}\n    # parent dictionary to reconstruct the path\n    parent = {start_pos: None}\n    found_target = None\n\n    while queue:\n        current_pos = queue.popleft()\n\n        if current_pos in target_cells:\n            found_target = current_pos\n            break\n\n        cx, cy = current_pos\n        # Explore neighbors: DOWN(y+1), UP(y-1), LEFT(x-1), RIGHT(x+1)\n        for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            neighbor_pos = (nx, ny)\n\n            if 0 <= nx < width and 0 <= ny < height and neighbor_pos not in visited:\n                if not blocked_grid[ny, nx]:\n                    visited.add(neighbor_pos)\n                    parent[neighbor_pos] = current_pos\n                    queue.append(neighbor_pos)\n\n    if found_target is None:\n        raise ValueError(f\"Cannot find a path to a '{workshop_name}'.\")\n\n    # 4. Reconstruct the path from the parent pointers\n    path = []\n    curr = found_target\n    while curr is not None:\n        path.append(curr)\n        curr = parent.get(curr)\n    path.reverse()\n\n    # 5. Convert the path of coordinates into a sequence of move actions\n    actions = []\n    # The path includes the start pos, so iterate from the second element\n    for i in range(1, len(path)):\n        prev_x, prev_y = path[i-1]\n        curr_x, curr_y = path[i]\n\n        if curr_y > prev_y:\n            actions.append(0)  # DOWN\n        elif curr_y < prev_y:\n            actions.append(1)  # UP\n        elif curr_x < prev_x:\n            actions.append(2)  # LEFT\n        elif curr_x > prev_x:\n            actions.append(3)  # RIGHT\n\n    # 6. Add an action to turn and face the workshop\n    # This is done by attempting to move into the workshop's (blocked) cell.\n    # The move fails, but correctly orients the agent.\n    workshop_pos = workshop_for_target[found_target]\n    dest_x, dest_y = found_target\n    workshop_x, workshop_y = workshop_pos\n\n    if workshop_y > dest_y:\n        actions.append(0)  # Face DOWN\n    elif workshop_y < dest_y:\n        actions.append(1)  # Face UP\n    elif workshop_x < dest_x:\n        actions.append(2)  # Face LEFT\n    elif workshop_x > dest_x:\n        actions.append(3)  # Face RIGHT\n\n    # 7. Add the final USE action to perform the craft\n    actions.append(4)  # USE\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A sequence of integer actions to be executed.\n    \"\"\"\n    actions = []\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # 1. Find the required workshop from the item's recipe\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' has no recipe and cannot be crafted.\")\n    \n    recipe = cookbook.recipes[goal_index]\n    if \"_at\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n        \n    workshop_name = recipe[\"_at\"]\n    workshop_index = cookbook.index[workshop_name]\n\n    # 2. Find the geographically closest instance of the required workshop\n    agent_pos = np.array(state.pos)  # Current agent position (x, y)\n    grid = state.grid\n\n    # np.argwhere returns coordinates as (row, col), which corresponds to (y, x)\n    workshop_locations_yx = np.argwhere(grid[:, :, workshop_index])\n    if workshop_locations_yx.shape[0] == 0:\n        raise ValueError(f\"No '{workshop_name}' workshop found in the environment.\")\n\n    min_dist = float('inf')\n    target_workshop_pos = None\n    for loc_yx in workshop_locations_yx:\n        # Convert (y, x) to (x, y) for distance calculation with agent_pos\n        loc_xy = np.array([loc_yx[1], loc_yx[0]])\n        # Use Manhattan distance, which is natural for grid-based movement\n        dist = np.sum(np.abs(agent_pos - loc_xy))\n        if dist < min_dist:\n            min_dist = dist\n            target_workshop_pos = loc_xy\n            \n    # 3. Find the best empty cell adjacent to the target workshop to move to\n    tx, ty = target_workshop_pos\n    adjacent_cells = [\n        (tx, ty - 1),  # Up\n        (tx, ty + 1),  # Down\n        (tx - 1, ty),  # Left\n        (tx + 1, ty),  # Right\n    ]\n\n    width, height, _ = grid.shape\n    valid_destinations = []\n    for x, y in adjacent_cells:\n        if 0 <= x < width and 0 <= y < height:\n            # An empty cell has no features set\n            if np.sum(grid[y, x, :]) == 0:\n                valid_destinations.append(np.array([x, y]))\n    \n    if not valid_destinations:\n        raise RuntimeError(f\"Workshop at {target_workshop_pos} is completely blocked.\")\n\n    # Find the closest valid adjacent cell to the agent\n    min_adj_dist = float('inf')\n    destination_pos = None\n    for dest in valid_destinations:\n        dist = np.sum(np.abs(agent_pos - dest))\n        if dist < min_adj_dist:\n            min_adj_dist = dist\n            destination_pos = dest\n\n    # 4. Generate movement actions to navigate to the destination cell\n    # Action mapping: DOWN:0, UP:1, LEFT:2, RIGHT:3, USE:4\n    current_pos = agent_pos.copy()\n    while not np.array_equal(current_pos, destination_pos):\n        dx = destination_pos[0] - current_pos[0]\n        dy = destination_pos[1] - current_pos[1]\n\n        # Prioritize movement along the axis with the greater distance\n        if abs(dx) > abs(dy):\n            if dx > 0:\n                actions.append(3)  # RIGHT\n                current_pos[0] += 1\n            else:\n                actions.append(2)  # LEFT\n                current_pos[0] -= 1\n        else:\n            if dy > 0:\n                actions.append(0)  # DOWN\n                current_pos[1] += 1\n            else:\n                actions.append(1)  # UP\n                current_pos[1] -= 1\n    \n    # 5. Generate action to turn and face the workshop\n    face_dx = target_workshop_pos[0] - current_pos[0]\n    face_dy = target_workshop_pos[1] - current_pos[1]\n    \n    if face_dx > 0:\n        actions.append(3)  # Face RIGHT\n    elif face_dx < 0:\n        actions.append(2)  # Face LEFT\n    elif face_dy > 0:\n        actions.append(0)  # Face DOWN\n    elif face_dy < 0:\n        actions.append(1)  # Face UP\n\n    # 6. Generate the USE action to perform the craft\n    actions.append(4)\n    \n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item.\n\n    The strategy involves:\n    1. Verifying the recipe and checking if the agent has the required ingredients.\n    2. Identifying the specific workshop needed for the recipe.\n    3. Finding the closest instance of that workshop in the environment.\n    4. Locating the nearest valid (empty and in-bounds) cell adjacent to that workshop.\n    5. Generating a path of move actions to a position from which the final move\n       will place the agent on the adjacent cell, facing the workshop.\n    6. Appending the final move action and the 'USE' action to complete the crafting process.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of low-level action integers to be executed, or an empty list\n                   if crafting is not possible (e.g., missing ingredients, no workshop).\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n    grid = state.grid\n    inventory = state.inventory\n    agent_pos = np.array(state.pos)\n\n    # 1. Look up the item's recipe\n    goal_idx = cookbook.index[item]\n    if goal_idx is None:\n        # Item doesn't exist in the game's index.\n        return []\n\n    recipe = cookbook.recipes.get(goal_idx)\n    if not recipe:\n        # The item has no recipe (e.g., it's a primitive resource).\n        return []\n\n    # 2. Check for required ingredients in the inventory\n    for ingredient_idx, required_count in recipe.items():\n        if isinstance(ingredient_idx, str):  # Skip metadata like '_at'\n            continue\n        if inventory[ingredient_idx] < required_count:\n            # Not enough ingredients, cannot craft.\n            return []\n\n    # 3. Identify the required workshop\n    required_workshop_name = recipe.get('_at')\n    if not required_workshop_name:\n        # Recipe is malformed, does not specify a workshop.\n        return []\n    required_workshop_idx = cookbook.index[required_workshop_name]\n\n    # 4. Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        # The required workshop does not exist on the map.\n        return []\n\n    # 5. Find the best target: the closest, accessible, adjacent cell to any workshop instance\n    min_dist = float('inf')\n    best_workshop_pos = None\n    best_adjacent_pos = None\n\n    for ws_pos in workshop_locations:  # ws_pos is in (y, x) format\n        # Check the four cardinal adjacent cells\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # UP, DOWN, LEFT, RIGHT neighbors\n            adj_pos = ws_pos + np.array([dy, dx])\n\n            # Check if the adjacent position is within grid bounds\n            if not (0 <= adj_pos[0] < grid.shape[0] and 0 <= adj_pos[1] < grid.shape[1]):\n                continue\n            \n            # Check if the cell is empty (nothing occupies it)\n            if grid[adj_pos[0], adj_pos[1], :].sum() > 0:\n                continue\n\n            # This is a valid target cell. Calculate its distance from the agent.\n            dist = np.sum(np.abs(agent_pos - adj_pos)) # Manhattan distance\n            if dist < min_dist:\n                min_dist = dist\n                best_workshop_pos = ws_pos\n                best_adjacent_pos = adj_pos\n    \n    if best_adjacent_pos is None:\n        # No accessible adjacent cell was found for any workshop of the required type.\n        return []\n\n    # 6. Plan the path to end up on `best_adjacent_pos` while facing `best_workshop_pos`\n    \n    # Determine the vector from the agent's final standing spot to the workshop.\n    # This tells us which way the agent must be facing.\n    face_vec = best_workshop_pos - best_adjacent_pos\n\n    # Map the facing vector to the required final action to achieve that facing direction.\n    final_action = -1\n    move_vectors = {\n        ACTION_DOWN: np.array([1, 0]),\n        ACTION_UP: np.array([-1, 0]),\n        ACTION_LEFT: np.array([0, -1]),\n        ACTION_RIGHT: np.array([0, 1]),\n    }\n    \n    if np.array_equal(face_vec, [1, 0]): # Workshop is DOWN\n        final_action = ACTION_DOWN\n    elif np.array_equal(face_vec, [-1, 0]): # Workshop is UP\n        final_action = ACTION_UP\n    elif np.array_equal(face_vec, [0, 1]): # Workshop is RIGHT\n        final_action = ACTION_RIGHT\n    elif np.array_equal(face_vec, [0, -1]): # Workshop is LEFT\n        final_action = ACTION_LEFT\n\n    # To execute `final_action` and land on `best_adjacent_pos`, we must start from\n    # the cell `best_adjacent_pos - move_vector`. This is our penultimate target.\n    penultimate_pos = best_adjacent_pos - move_vectors[final_action]\n\n    # 7. Generate move actions to get from the agent's current position to the penultimate position.\n    actions = []\n\n    # Move vertically to align with penultimate_pos\n    dy = penultimate_pos[0] - agent_pos[0]\n    if dy > 0:\n        actions.extend([ACTION_DOWN] * dy)\n    elif dy < 0:\n        actions.extend([ACTION_UP] * abs(dy))\n    \n    # Move horizontally to align with penultimate_pos\n    dx = penultimate_pos[1] - agent_pos[1]\n    if dx > 0:\n        actions.extend([ACTION_RIGHT] * dx)\n    elif dx < 0:\n        actions.extend([ACTION_LEFT] * abs(dx))\n\n    # 8. Add the final orienting move and the USE action\n    actions.append(final_action)\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find the correct workshop, navigate to it,\n    face it, and craft the specified item.\n    \"\"\"\n    # Action constants for clarity, matching the environment's specification.\n    ACTION_DOWN = 0\n    ACTION_UP = 1\n    ACTION_LEFT = 2\n    ACTION_RIGHT = 3\n    ACTION_USE = 4\n\n    # 1. Look up the recipe to find the specific workshop required.\n    cookbook = env.world.cookbook\n    try:\n        goal_index = cookbook.index[item]\n        recipe = cookbook.recipes[goal_index]\n        workshop_name = recipe['_at']\n        required_workshop_idx = cookbook.index[workshop_name]\n    except (KeyError, TypeError):\n        raise ValueError(f\"Item '{item}' or its recipe/workshop not found in the cookbook.\")\n\n    # 2. Find all grid locations for the required workshop type.\n    grid = env._current_state.grid\n    # np.argwhere returns coordinates as (row, col), which corresponds to (y, x).\n    workshop_locations_yx = np.argwhere(grid[:, :, required_workshop_idx])\n\n    if workshop_locations_yx.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found on the map.\")\n\n    # 3. Find the single closest workshop instance to the agent.\n    # The agent's position is a tuple (x, y).\n    agent_pos = np.array(env._current_state.pos)\n    \n    # Convert workshop locations from (y, x) to (x, y) for consistent distance calculation.\n    workshop_locations_xy = workshop_locations_yx[:, ::-1]\n    \n    distances = np.linalg.norm(workshop_locations_xy - agent_pos, axis=1)\n    closest_workshop_pos = workshop_locations_xy[np.argmin(distances)]\n\n    # 4. Find the best valid (empty) cell adjacent to the workshop to navigate to.\n    width, height, _ = grid.shape\n    adjacent_cells = []\n    wx, wy = closest_workshop_pos\n    \n    # Define potential adjacent cells in (x, y) coordinates.\n    candidate_coords = [(wx, wy - 1), (wx, wy + 1), (wx - 1, wy), (wx + 1, wy)]\n\n    for x, y in candidate_coords:\n        # Check if the cell is within grid boundaries.\n        if 0 <= x < width and 0 <= y < height:\n            # Check if the cell is empty by summing its one-hot feature vector.\n            # Grid must be indexed with (y, x).\n            if np.sum(grid[y, x, :]) == 0:\n                adjacent_cells.append(np.array([x, y]))\n\n    if not adjacent_cells:\n        raise RuntimeError(f\"No empty adjacent cell found for workshop at {closest_workshop_pos}\")\n    \n    # From the valid adjacent cells, pick the one closest to the agent's current position.\n    adj_distances = [np.linalg.norm(cell - agent_pos) for cell in adjacent_cells]\n    target_pos = adjacent_cells[np.argmin(adj_distances)]\n\n    # 5. Generate a sequence of movement actions to reach the target adjacent cell.\n    actions = []\n    sim_pos = agent_pos.copy()\n\n    while not np.array_equal(sim_pos, target_pos):\n        dx = target_pos[0] - sim_pos[0]\n        dy = target_pos[1] - sim_pos[1]\n\n        # Prioritize horizontal movement, then vertical.\n        if dx != 0:\n            if dx > 0:\n                actions.append(ACTION_RIGHT)\n                sim_pos[0] += 1\n            else:\n                actions.append(ACTION_LEFT)\n                sim_pos[0] -= 1\n        elif dy != 0:\n            if dy > 0:\n                actions.append(ACTION_DOWN)\n                sim_pos[1] += 1\n            else:\n                actions.append(ACTION_UP)\n                sim_pos[1] -= 1\n    \n    # 6. Generate a final action to turn and face the workshop.\n    # The agent is now at target_pos, and the workshop is at closest_workshop_pos.\n    face_dx = closest_workshop_pos[0] - target_pos[0]\n    face_dy = closest_workshop_pos[1] - target_pos[1]\n\n    if face_dx == 1:\n        actions.append(ACTION_RIGHT)\n    elif face_dx == -1:\n        actions.append(ACTION_LEFT)\n    elif face_dy == 1:\n        actions.append(ACTION_DOWN)\n    elif face_dy == -1:\n        actions.append(ACTION_UP)\n    \n    # 7. Add the USE action to perform the craft.\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specified item.\n\n    The strategy involves:\n    1.  Verifying the recipe and checking if the agent has the required ingredients.\n    2.  Identifying the specific type of workshop required from the recipe.\n    3.  Finding the closest physically accessible instance of that workshop. An accessible \n        instance is one with at least one empty, adjacent cell.\n    4.  Calculating the optimal adjacent cell (the navigation target) which has the\n        shortest Manhattan distance to the agent's current position.\n    5.  Generating a simple greedy path (horizontal then vertical moves) to the target cell.\n    6.  Generating a final 'turn' action to face the workshop.\n    7.  Appending the 'USE' action to perform the craft.\n\n    If crafting is not possible (e.g., no recipe, missing ingredients, no accessible \n    workshop), it returns an empty list of actions.\n    \"\"\"\n    # Action constants for clarity\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n    \n    actions = []\n    state = env._current_state\n    cookbook = env.world.cookbook\n\n    # 1. Get recipe and check prerequisites\n    goal_idx = cookbook.index[item]\n    if goal_idx is None or goal_idx not in cookbook.recipes:\n        # Item doesn't exist or is a primitive that cannot be crafted.\n        return []\n\n    recipe = cookbook.recipes[goal_idx]\n    \n    # Check inventory for required ingredients before starting any movement\n    for ingr_idx, required_count in recipe.items():\n        if ingr_idx == \"_at\":\n            continue\n        if state.inventory[ingr_idx] < required_count:\n            # Missing ingredients, so crafting is impossible.\n            return []\n    \n    # 2. Identify the required workshop from the recipe\n    required_workshop_idx = recipe[\"_at\"]\n    \n    # 3. Find all locations of this workshop type on the grid\n    grid = state.grid\n    HEIGHT, WIDTH, _ = grid.shape\n    # np.argwhere returns coordinates in (row, col) format, which corresponds to (y, x)\n    workshop_locations_yx = np.argwhere(grid[:, :, required_workshop_idx])\n\n    if workshop_locations_yx.shape[0] == 0:\n        # Required workshop does not exist in the current scenario.\n        return []\n\n    # 4. Find the closest accessible workshop and the best adjacent cell to navigate to\n    agent_pos = np.array(state.pos) # Stored as (x, y)\n    \n    min_dist_to_nav_target = float('inf')\n    best_nav_target = None\n    closest_ws_pos = None\n\n    for ws_pos_yx in workshop_locations_yx:\n        ws_pos_xy = ws_pos_yx[::-1] # Convert from (y, x) to (x, y) for consistency\n        \n        # Check the four adjacent cells to find a valid, empty navigation target\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_pos_xy = ws_pos_xy + np.array([dx, dy])\n            \n            # Check if the adjacent cell is within grid bounds\n            if not (0 <= adj_pos_xy[0] < WIDTH and 0 <= adj_pos_xy[1] < HEIGHT):\n                continue\n            \n            # A cell is empty if its one-hot encoding vector is all zeros\n            is_empty = np.sum(grid[adj_pos_xy[1], adj_pos_xy[0], :]) == 0\n            \n            if is_empty:\n                # This is a valid target. Check if it's the best one found so far.\n                dist = np.sum(np.abs(agent_pos - adj_pos_xy)) # Manhattan distance\n                if dist < min_dist_to_nav_target:\n                    min_dist_to_nav_target = dist\n                    best_nav_target = adj_pos_xy\n                    closest_ws_pos = ws_pos_xy\n\n    if best_nav_target is None:\n        # No workshop is accessible (e.g., all are walled in).\n        return []\n\n    # 5. Generate navigation actions to move to the best_nav_target\n    sim_pos = agent_pos.copy()\n\n    # Move horizontally until x-coordinates match\n    while sim_pos[0] != best_nav_target[0]:\n        action = RIGHT if best_nav_target[0] > sim_pos[0] else LEFT\n        actions.append(action)\n        sim_pos[0] += 1 if action == RIGHT else -1\n\n    # Move vertically until y-coordinates match\n    while sim_pos[1] != best_nav_target[1]:\n        action = DOWN if best_nav_target[1] > sim_pos[1] else UP\n        actions.append(action)\n        sim_pos[1] += 1 if action == DOWN else -1\n    \n    # 6. Generate a single action to turn and face the workshop\n    face_dx = closest_ws_pos[0] - best_nav_target[0]\n    face_dy = closest_ws_pos[1] - best_nav_target[1]\n\n    if face_dx == 1:\n        face_action = RIGHT\n    elif face_dx == -1:\n        face_action = LEFT\n    elif face_dy == 1:\n        face_action = DOWN\n    else: # face_dy == -1\n        face_action = UP\n    \n    actions.append(face_action)\n\n    # 7. Add the final USE action to perform the craft\n    actions.append(USE)\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specified item.\n\n    This expert strategy proceeds in several steps:\n    1.  It consults the cookbook to find the recipe for the item, which specifies\n        the required ingredients and the correct workshop type.\n    2.  It checks the agent's current inventory to ensure all prerequisite\n        ingredients for the recipe are available. If not, it returns an empty\n        plan as crafting is impossible.\n    3.  It scans the grid to find all instances of the required workshop type.\n    4.  For each workshop, it identifies valid, empty adjacent cells that the\n        agent can stand on to perform the craft action.\n    5.  It calculates the distance to all valid adjacent cells and selects the one\n        closest to the agent's current position as the target destination.\n    6.  It generates a simple and direct path of move actions (UP, DOWN, LEFT,\n        RIGHT) to navigate the agent to this target destination.\n    7.  Once at the destination, it adds a final move action directed at the\n        workshop. This orients the agent to face the workshop (assuming an\n        attempt to move into a blocked cell results in a turn without changing\n        position, a common mechanic in grid-world environments).\n    8.  Finally, it appends the USE action to the sequence to perform the craft.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # Action constants for clarity, based on the environment's action spec.\n    ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n\n    # 1. Look up the recipe to find the required workshop.\n    try:\n        goal_index = cookbook.index[item]\n        recipe = cookbook.recipes[goal_index]\n        workshop_name = recipe['_at']\n        workshop_index = cookbook.index[workshop_name]\n    except (KeyError, TypeError):\n        raise ValueError(f\"Item '{item}' or its recipe is not defined in the cookbook.\")\n\n    # 2. Check inventory for required primitive ingredients.\n    required_primitives = cookbook.primitives_for(goal_index)\n    for prim_idx, count in required_primitives.items():\n        if state.inventory[prim_idx] < count:\n            # Prerequisite not met, crafting is impossible.\n            return []\n\n    # 3. Find all locations of the required workshop on the grid.\n    grid = state.grid\n    workshop_locations = np.argwhere(grid[:, :, workshop_index])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found on the map.\")\n\n    # 4. Find the closest valid (empty) cell adjacent to any workshop instance.\n    agent_pos = np.array(state.pos)\n    best_target_pos = None\n    corresponding_workshop_pos = None\n    min_dist = float('inf')\n\n    for workshop_pos in workshop_locations:\n        # Check the four cardinal neighbors of the workshop.\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right\n            neighbor_pos = workshop_pos + np.array([dy, dx])\n\n            # Ensure the neighbor is within grid bounds.\n            if not (0 <= neighbor_pos[0] < grid.shape[0] and 0 <= neighbor_pos[1] < grid.shape[1]):\n                continue\n\n            # Check if the neighbor cell is empty (i.e., walkable).\n            if np.sum(grid[neighbor_pos[0], neighbor_pos[1], :]) == 0:\n                dist = np.sum(np.abs(agent_pos - neighbor_pos)) # Manhattan distance\n                if dist < min_dist:\n                    min_dist = dist\n                    best_target_pos = neighbor_pos\n                    corresponding_workshop_pos = workshop_pos\n    \n    if best_target_pos is None:\n        raise ValueError(f\"No reachable empty cell found next to a '{workshop_name}'.\")\n\n    # 5. Generate a path to the chosen adjacent cell.\n    actions = []\n    \n    # Move vertically to align the y-coordinate.\n    dy = best_target_pos[0] - agent_pos[0]\n    if dy > 0:\n        actions.extend([ACTION_DOWN] * dy)\n    else:\n        actions.extend([ACTION_UP] * abs(dy))\n    \n    # Move horizontally to align the x-coordinate.\n    dx = best_target_pos[1] - agent_pos[1]\n    if dx > 0:\n        actions.extend([ACTION_RIGHT] * dx)\n    else:\n        actions.extend([ACTION_LEFT] * abs(dx))\n\n    # 6. Add a final action to turn and face the workshop.\n    face_dy = corresponding_workshop_pos[0] - best_target_pos[0]\n    face_dx = corresponding_workshop_pos[1] - best_target_pos[1]\n\n    if face_dy == 1:\n        actions.append(ACTION_DOWN)\n    elif face_dy == -1:\n        actions.append(ACTION_UP)\n    elif face_dx == 1:\n        actions.append(ACTION_RIGHT)\n    elif face_dx == -1:\n        actions.append(ACTION_LEFT)\n\n    # 7. Append the USE action to perform the craft.\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n    This expert strategy includes:\n    1. Verifying the recipe and required ingredients are in the inventory.\n    2. Identifying the specific workshop type required by the recipe.\n    3. Finding the geographically closest instance of that workshop.\n    4. Pathfinding to a valid, empty cell adjacent to the workshop.\n    5. Generating a 'turn' action to face the workshop.\n    6. Generating the 'USE' action to perform the craft.\n    \"\"\"\n    # Action constants for clarity\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # Get world and state information from the environment\n    world = env.world\n    cookbook = world.cookbook\n    state = env._current_state\n    grid = state.grid\n    inventory = state.inventory\n    \n    # 1. Get recipe and check for required ingredients\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item '{item}'\")\n\n    # Check inventory for prerequisites\n    for ingredient_idx, required_count in recipe.items():\n        if isinstance(ingredient_idx, str) and ingredient_idx.startswith('_'):\n            continue  # Skip metadata like '_at'\n        if inventory[ingredient_idx] < required_count:\n            ingredient_name = cookbook.index.get(ingredient_idx)\n            raise ValueError(\n                f\"Cannot craft '{item}'. Missing ingredient: {ingredient_name}. \"\n                f\"Have {inventory[ingredient_idx]}, need {required_count}.\"\n            )\n\n    # 2. Identify the required workshop from the recipe\n    required_workshop_idx = recipe.get('_at')\n    if required_workshop_idx is None:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n        \n    # 3. Find all locations of the required workshop type\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        workshop_name = cookbook.index.get(required_workshop_idx)\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n    \n    # Find the single closest workshop instance to the agent using Manhattan distance\n    agent_pos = np.array(state.pos)\n    distances = np.sum(np.abs(workshop_locations - agent_pos), axis=1)\n    closest_workshop_pos = workshop_locations[np.argmin(distances)]\n\n    # 4. Find the best adjacent cell to move to.\n    # The agent must be next to the workshop, not on it.\n    height, width, _ = grid.shape\n    potential_targets = []\n    \n    # Check four neighbors of the workshop\n    for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Relative pos: Up, Down, Left, Right\n        ny, nx = closest_workshop_pos[0] + dy, closest_workshop_pos[1] + dx\n        \n        # Check if neighbor is within bounds and is an empty cell\n        if 0 <= ny < height and 0 <= nx < width and np.sum(grid[ny, nx, :]) == 0:\n            potential_targets.append((ny, nx))\n    \n    if not potential_targets:\n        raise RuntimeError(f\"The closest workshop for '{item}' is inaccessible (surrounded).\")\n        \n    # From the valid adjacent cells, find the one closest to the agent\n    distances_to_targets = [np.sum(np.abs(np.array(p) - agent_pos)) for p in potential_targets]\n    target_pos = np.array(potential_targets[np.argmin(distances_to_targets)])\n\n    # 5. Generate pathfinding actions to move to the target adjacent cell\n    actions = []\n    sim_pos = agent_pos.copy() # Use a simulated position for path generation\n\n    while not np.array_equal(sim_pos, target_pos):\n        # Note: pos is (y, x), where y is row and x is column\n        dy = target_pos[0] - sim_pos[0]\n        dx = target_pos[1] - sim_pos[1]\n\n        if abs(dx) > abs(dy): # Move horizontally (x-axis)\n            if dx > 0:\n                actions.append(RIGHT)\n                sim_pos[1] += 1\n            else:\n                actions.append(LEFT)\n                sim_pos[1] -= 1\n        else: # Move vertically (y-axis)\n            if dy > 0:\n                actions.append(DOWN)\n                sim_pos[0] += 1\n            else:\n                actions.append(UP)\n                sim_pos[0] -= 1\n\n    # 6. Generate action to face the workshop from the target position\n    # At this point, sim_pos == target_pos\n    dy_face = closest_workshop_pos[0] - sim_pos[0]\n    dx_face = closest_workshop_pos[1] - sim_pos[1]\n\n    if dy_face == -1: # Workshop is above agent (smaller y)\n        actions.append(UP)\n    elif dy_face == 1: # Workshop is below agent (larger y)\n        actions.append(DOWN)\n    elif dx_face == -1: # Workshop is to the left of agent (smaller x)\n        actions.append(LEFT)\n    elif dx_face == 1: # Workshop is to the right of agent (larger x)\n        actions.append(RIGHT)\n    \n    # 7. Generate the USE action\n    actions.append(USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1. Consulting the cookbook to find the specific workshop required for the item.\n    2. Searching the grid for all instances of that workshop.\n    3. Identifying the closest, empty, accessible cell adjacent to any of these workshops.\n    4. Generating a correct sequence of movement actions to reach that cell.\n    5. Appending the correct turning action to face the workshop.\n    6. Appending the final 'USE' action to perform the craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A sequence of integer actions (0-4 for DOWN, UP, LEFT, RIGHT, USE) \n              to be executed by the environment.\n              \n    Raises:\n        ValueError: If the item has no recipe, the recipe doesn't specify a\n                    workshop, or if no accessible workshop is found on the map.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n    agent_pos = state.pos  # Current agent position as (x, y)\n\n    # 1. Identify the correct workshop from the recipe\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item: {item}\")\n    \n    recipe = cookbook.recipes[goal_index]\n    if '_at' not in recipe:\n        raise ValueError(f\"Recipe for {item} does not specify a workshop.\")\n    \n    workshop_kind_index = recipe['_at']\n\n    # 2. Find all locations of the required workshop\n    # np.argwhere returns coordinates as (row, col), which corresponds to (y, x)\n    workshop_locations = np.argwhere(grid[:, :, workshop_kind_index])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop for {item} not found in the environment.\")\n\n    # 3. Find the closest reachable, empty cell adjacent to any workshop instance\n    min_dist = float('inf')\n    best_target_pos = None    # The empty adjacent cell to move to, format (x, y)\n    best_workshop_pos = None  # The workshop cell to face, format (x, y)\n\n    grid_height, grid_width, _ = grid.shape\n\n    for w_pos_yx in workshop_locations:\n        w_y, w_x = w_pos_yx\n        # Check the 4 cardinal neighbors of the workshop\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            n_y, n_x = w_y + dy, w_x + dx\n\n            # Check if the neighbor is within grid bounds\n            if 0 <= n_y < grid_height and 0 <= n_x < grid_width:\n                # An empty cell's one-hot vector sums to 0\n                is_empty = np.sum(grid[n_y, n_x, :]) == 0\n                if is_empty:\n                    # Calculate Manhattan distance from agent to this empty neighbor\n                    dist = abs(n_x - agent_pos[0]) + abs(n_y - agent_pos[1])\n                    if dist < min_dist:\n                        min_dist = dist\n                        # Store positions in (x, y) format to match agent_pos\n                        best_target_pos = (n_x, n_y)\n                        best_workshop_pos = (w_x, w_y)\n\n    if best_target_pos is None:\n        raise ValueError(f\"No accessible empty cell found next to a workshop for {item}.\")\n\n    # 4. Generate pathfinding actions to move to the target position\n    actions = []\n    \n    # Horizontal movement (X-axis)\n    # Action 3: RIGHT, Action 2: LEFT\n    delta_x = best_target_pos[0] - agent_pos[0]\n    if delta_x > 0:\n        actions.extend([3] * delta_x)\n    elif delta_x < 0:\n        actions.extend([2] * abs(delta_x))\n\n    # Vertical movement (Y-axis)\n    # Action 0: DOWN, Action 1: UP\n    delta_y = best_target_pos[1] - agent_pos[1]\n    if delta_y > 0:\n        actions.extend([0] * delta_y)\n    elif delta_y < 0:\n        actions.extend([1] * abs(delta_y))\n\n    # 5. Generate the final \"face\" and \"use\" actions\n    # The agent is now at best_target_pos and needs to face best_workshop_pos\n    face_dx = best_workshop_pos[0] - best_target_pos[0]\n    face_dy = best_workshop_pos[1] - best_target_pos[1]\n\n    if face_dx == 1:       # Workshop is to the right\n        actions.append(3)  # Face RIGHT\n    elif face_dx == -1:    # Workshop is to the left\n        actions.append(2)  # Face LEFT\n    elif face_dy == 1:     # Workshop is below\n        actions.append(0)  # Face DOWN\n    elif face_dy == -1:    # Workshop is above\n        actions.append(1)  # Face UP\n    \n    actions.append(4) # USE action\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find the correct workshop and craft an item.\n\n    This function implements a robust strategy by:\n    1.  Looking up the recipe to identify the specific workshop required.\n    2.  Finding all instances of that workshop on the grid.\n    3.  Evaluating all accessible cells adjacent to all workshop instances to find the optimal target.\n        An optimal target is one that minimizes the travel distance for the agent.\n    4.  Generating a path to a position *from which* a final move can be made to land on the\n        target cell, correctly oriented towards the workshop.\n    5.  Appending the final move action and the 'USE' action.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n    width, height, _ = grid.shape\n\n    # Action constants and utility mappings\n    ACTION_USE = 4\n    ACTION_DELTAS = {\n        0: np.array([0, 1]),   # DOWN\n        1: np.array([0, -1]),  # UP\n        2: np.array([-1, 0]),  # LEFT\n        3: np.array([1, 0]),   # RIGHT\n    }\n    \n    # --- Step 1: Look up the recipe to find the required workshop ---\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' has no recipe and cannot be crafted.\")\n    \n    recipe = cookbook.recipes[goal_index]\n    workshop_name = recipe.get('_at')\n    if not workshop_name:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop ('_at').\")\n    \n    required_workshop_index = cookbook.index[workshop_name]\n\n    # --- Step 2: Find all instances of the required workshop on the grid ---\n    workshop_locations_yx = np.argwhere(grid[:, :, required_workshop_index])\n    if workshop_locations_yx.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found on the map.\")\n    \n    # Convert numpy's (row, col) i.e., (y, x) to our standard (x, y)\n    workshop_locations = workshop_locations_yx[:, ::-1]\n\n    agent_pos = np.array(state.pos)\n\n    # --- Step 3: Find the best reachable adjacent cell to any workshop instance ---\n    best_candidate = None\n    min_path_len = float('inf')\n\n    for workshop_pos in workshop_locations:\n        # Check all four adjacent cells to this workshop\n        for final_action, delta in ACTION_DELTAS.items():\n            # target_pos is where the agent should stand\n            # pre_target_pos is the cell from which the final move is made\n            target_pos = workshop_pos - delta\n            pre_target_pos = target_pos - ACTION_DELTAS[final_action]\n\n            # A) Validate the target position\n            x_t, y_t = target_pos\n            if not (0 <= x_t < width and 0 <= y_t < height):\n                continue\n            # It must be empty, unless the agent is already there\n            if grid[x_t, y_t, :].sum() > 0 and not np.array_equal(target_pos, agent_pos):\n                continue\n            \n            # Estimate path length: Manhattan distance from agent to pre_target_pos,\n            # plus one for the final move.\n            path_len = np.sum(np.abs(pre_target_pos - agent_pos)) + 1\n            \n            if path_len < min_path_len:\n                min_path_len = path_len\n                best_candidate = {\n                    \"pre_target_pos\": pre_target_pos,\n                    \"final_action\": final_action\n                }\n\n    if best_candidate is None:\n        raise RuntimeError(f\"Could not find any accessible cell to use workshop '{workshop_name}'.\")\n\n    pre_target_pos = best_candidate[\"pre_target_pos\"]\n    final_action = best_candidate[\"final_action\"]\n    \n    actions = []\n    sim_pos = agent_pos.copy()\n\n    # --- Step 4: Generate path from agent's position to the pre_target_pos ---\n    # The pathfinding logic ensures we don't move onto the final target cell yet.\n    # Simple greedy path: move along x-axis, then y-axis.\n    \n    # Move horizontally\n    while sim_pos[0] != pre_target_pos[0]:\n        dx = pre_target_pos[0] - sim_pos[0]\n        action = 3 if dx > 0 else 2  # RIGHT or LEFT\n        actions.append(action)\n        sim_pos += ACTION_DELTAS[action]\n\n    # Move vertically\n    while sim_pos[1] != pre_target_pos[1]:\n        dy = pre_target_pos[1] - sim_pos[1]\n        action = 0 if dy > 0 else 1  # DOWN or UP\n        actions.append(action)\n        sim_pos += ACTION_DELTAS[action]\n\n    # --- Step 5: Add the final move and the USE action ---\n    # This move takes the agent from pre_target_pos to target_pos, facing the workshop.\n    actions.append(final_action)\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find the correct workshop and craft an item.\n\n    The strategy is as follows:\n    1.  Look up the recipe for the given 'item' to determine the required workshop type.\n    2.  Scan the grid to find all instances of that workshop.\n    3.  Identify the specific workshop instance closest to the agent's current position.\n    4.  Find a valid (empty) cell adjacent to the target workshop. This will be the agent's\n        destination, as the workshop itself is a blocked cell. From all valid adjacent\n        cells, the one closest to the agent is chosen.\n    5.  To interact with the workshop, the agent must be in the adjacent cell and facing it.\n        Since movement actions also set the agent's direction, the path must be constructed\n        such that the final move places the agent in the destination cell with the correct\n        orientation.\n    6.  This is achieved by calculating a \"pre-destination\" cell\u2014the cell from which the\n        final move is made. A simple path (horizontal moves, then vertical moves) is\n        generated from the agent's current position to this pre-destination cell.\n    7.  The final move action (to get to the destination and face the workshop) is appended,\n        followed by the 'USE' action to perform the craft.\n    \"\"\"\n    cookbook = env.world.cookbook\n    agent_state = env._current_state\n\n    # 1. Look up the recipe to find the required workshop\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(goal_index)\n    if recipe is None:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    workshop_name = recipe.get('_at')\n    if workshop_name is None:\n        raise ValueError(f\"Recipe for {item} does not specify a workshop (_at).\")\n\n    workshop_index = cookbook.index[workshop_name]\n    if workshop_index is None:\n        raise ValueError(f\"Unknown workshop in recipe: {workshop_name}\")\n\n    # 2. Find the closest instance of the required workshop\n    agent_pos = np.array(agent_state.pos, dtype=int)  # Current position (y, x)\n    workshop_locations = np.argwhere(agent_state.grid[:, :, workshop_index])\n\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Workshop '{workshop_name}' not found in the environment.\")\n\n    # Calculate Manhattan distances to all workshops of the correct type\n    distances = np.sum(np.abs(workshop_locations - agent_pos), axis=1)\n    closest_workshop_pos = workshop_locations[np.argmin(distances)]\n\n    # 3. Find the best empty adjacent cell to navigate to\n    y, x = closest_workshop_pos\n    grid_height, grid_width, _ = agent_state.grid.shape\n    potential_adj_cells = [(y - 1, x), (y + 1, x), (y, x - 1), (y, x + 1)]\n\n    valid_adj_cells = []\n    for r, c in potential_adj_cells:\n        # Check if the cell is within grid bounds\n        if 0 <= r < grid_height and 0 <= c < grid_width:\n            # Check if the cell is empty (sum of one-hot vector is 0)\n            if np.sum(agent_state.grid[r, c, :]) == 0:\n                valid_adj_cells.append(np.array([r, c]))\n\n    if not valid_adj_cells:\n        raise RuntimeError(f\"No empty cell adjacent to workshop '{workshop_name}' at {closest_workshop_pos}.\")\n\n    # From the valid options, choose the one closest to the agent\n    adj_distances = [np.sum(np.abs(cell - agent_pos)) for cell in valid_adj_cells]\n    final_destination = valid_adj_cells[np.argmin(adj_distances)]\n\n    # 4. Determine the final move to arrive at the destination facing the workshop\n    dy_face = closest_workshop_pos[0] - final_destination[0]\n    dx_face = closest_workshop_pos[1] - final_destination[1]\n\n    # Action constants: DOWN=0, UP=1, LEFT=2, RIGHT=3, USE=4\n    final_move_action = -1\n    pre_destination = final_destination.copy()\n\n    if dy_face == 1:  # To face DOWN, must come from UP\n        final_move_action = 0\n        pre_destination[0] -= 1\n    elif dy_face == -1:  # To face UP, must come from DOWN\n        final_move_action = 1\n        pre_destination[0] += 1\n    elif dx_face == 1:  # To face RIGHT, must come from LEFT\n        final_move_action = 3\n        pre_destination[1] -= 1\n    elif dx_face == -1:  # To face LEFT, must come from RIGHT\n        final_move_action = 2\n        pre_destination[1] += 1\n\n    # 5. Generate path from agent's position to the pre-destination cell\n    actions = []\n    sim_pos = agent_pos.copy()\n\n    # First, align horizontally (x-coordinate)\n    while sim_pos[1] != pre_destination[1]:\n        if pre_destination[1] > sim_pos[1]:\n            action = 3  # RIGHT\n            sim_pos[1] += 1\n        else:\n            action = 2  # LEFT\n            sim_pos[1] -= 1\n        actions.append(action)\n\n    # Second, align vertically (y-coordinate)\n    while sim_pos[0] != pre_destination[0]:\n        if pre_destination[0] > sim_pos[0]:\n            action = 0  # DOWN\n            sim_pos[0] += 1\n        else:\n            action = 1  # UP\n            sim_pos[0] -= 1\n        actions.append(action)\n    \n    # 6. Append the final move and the USE action\n    actions.append(final_move_action)\n    actions.append(4)  # USE\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    face it, and craft the specified item.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n    grid = state.grid\n    inventory = state.inventory\n\n    # 1. Get the integer index for the item name from the cookbook.\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    # 2. Look up the recipe for the goal item.\n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    # 3. Check if the agent's inventory has the required ingredients.\n    required_primitives = {k: v for k, v in recipe.items() if isinstance(k, int)}\n    for primitive_idx, required_count in required_primitives.items():\n        if inventory[primitive_idx] < required_count:\n            raise ValueError(\n                f\"Not enough {cookbook.index.get(primitive_idx)} to craft {item}. \"\n                f\"Have {inventory[primitive_idx]}, need {required_count}.\"\n            )\n\n    # 4. Find the specific workshop type required by the recipe.\n    if '_at' not in recipe:\n        raise ValueError(f\"Recipe for {item} does not specify a workshop.\")\n    workshop_kind_index = recipe['_at']\n\n    # 5. Find all grid locations of the required workshop type.\n    workshop_locations = np.argwhere(grid[:, :, workshop_kind_index])\n    if workshop_locations.shape[0] == 0:\n        workshop_name = cookbook.index.get(workshop_kind_index)\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    # 6. Find the closest, empty, accessible cell adjacent to any instance of the workshop.\n    agent_pos = np.array(state.pos)  # Agent's position is (x, y)\n    HEIGHT, WIDTH, _ = grid.shape\n\n    min_dist = float('inf')\n    best_destination = None  # The target (y, x) cell to move to\n    best_workshop_loc = None # The (y, x) of the workshop to face\n\n    for workshop_loc in workshop_locations:  # Each workshop_loc is (y, x)\n        y, x = workshop_loc\n        # Check four cardinal neighbors\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ny, nx = y + dy, x + dx\n            # Check if neighbor is within grid bounds\n            if 0 <= ny < HEIGHT and 0 <= nx < WIDTH:\n                # A cell is empty if its feature vector sums to 0\n                if grid[ny, nx, :].sum() == 0:\n                    # Calculate Manhattan distance from agent to this neighbor cell\n                    dist = abs(nx - agent_pos[0]) + abs(ny - agent_pos[1])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_destination = np.array([ny, nx])\n                        best_workshop_loc = workshop_loc\n\n    if best_destination is None:\n        raise ValueError(\"No accessible empty cell found next to any required workshop.\")\n\n    # 7. Generate a sequence of movement actions to reach the destination.\n    actions = []\n    sim_pos = agent_pos.copy().astype(int) # Simulated position (x, y)\n\n    target_x, target_y = best_destination[1], best_destination[0]\n\n    while sim_pos[0] != target_x or sim_pos[1] != target_y:\n        dx = target_x - sim_pos[0]\n        dy = target_y - sim_pos[1]\n\n        # Greedily move along the axis with the greater distance\n        if abs(dx) > abs(dy):\n            if dx > 0:\n                actions.append(3)  # RIGHT\n                sim_pos[0] += 1\n            else:\n                actions.append(2)  # LEFT\n                sim_pos[0] -= 1\n        else:\n            if dy > 0:\n                actions.append(0)  # DOWN\n                sim_pos[1] += 1\n            else:\n                actions.append(1)  # UP\n                sim_pos[1] -= 1\n    \n    # 8. Add an action to turn and face the workshop.\n    dy_face = best_workshop_loc[0] - best_destination[0]\n    dx_face = best_workshop_loc[1] - best_destination[1]\n\n    if dx_face > 0:\n        actions.append(3)  # Face RIGHT\n    elif dx_face < 0:\n        actions.append(2)  # Face LEFT\n    elif dy_face > 0:\n        actions.append(0)  # Face DOWN\n    elif dy_face < 0:\n        actions.append(1)  # Face UP\n\n    # 9. Add the USE action to perform the craft.\n    actions.append(4) # USE\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}

