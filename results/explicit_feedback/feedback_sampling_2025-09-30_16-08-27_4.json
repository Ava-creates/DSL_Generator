{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find, move adjacent to, and collect a primitive.\n    This function uses a Breadth-First Search (BFS) to find the shortest action sequence.\n\n    The state in the BFS is represented by (position, direction), ensuring that the\n    agent's orientation is tracked, which is critical for the final 'USE' action.\n\n    The algorithm works as follows:\n    1. Identify all locations of the target primitive on the grid.\n    2. Initialize a queue for BFS with the agent's starting state (pos, dir, empty_path).\n    3. Use a 'visited' set to avoid redundant explorations of the same (pos, dir) state.\n    4. Before exploring moves from the current state, check if the goal is already met:\n       - The goal is to be positioned and oriented such that the target primitive is\n         in the single adjacent cell the agent is currently facing.\n       - If this condition is met, the path is complete. Append the 'USE' action and return.\n    5. Explore all possible next states resulting from a move action (UP, DOWN, LEFT, RIGHT).\n       A move action changes both the agent's position and its direction.\n    6. If a move leads to a valid, unvisited, and traversable new state, add it to the queue.\n       - A cell is considered traversable if it does not contain any non-grabbable entities (like walls).\n    7. If the queue becomes empty and the target hasn't been reached, no path exists.\n\n    This implementation correctly solves the main issues from the feedback:\n    - It paths to a cell *adjacent* to the primitive, not onto it.\n    - It correctly manages the agent's facing direction to ensure the final 'USE' action is successful.\n    \"\"\"\n    grid = env._current_state.grid\n    h, w, _ = grid.shape\n    \n    try:\n        target_idx = env.world.cookbook.index[primitive]\n    except KeyError:\n        # Primitive name is not in the cookbook, so it can't be found.\n        return []\n\n    target_locs = set(zip(*np.where(grid[:, :, target_idx] > 0)))\n    if not target_locs:\n        # Primitive does not exist on the map.\n        return []\n\n    # Map actions/directions to their corresponding vector changes.\n    # Note: In this environment, the action taken (e.g., craft.UP) becomes the new direction.\n    ACTION_VECTORS = {\n        craft.UP: (0, 1),\n        craft.DOWN: (0, -1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n    MOVE_ACTIONS = list(ACTION_VECTORS.keys())\n\n    # The BFS queue will store tuples of (position, direction, path_list).\n    start_pos = env._current_state.pos\n    start_dir = env._current_state.dir\n    queue = collections.deque([(start_pos, start_dir, [])])\n\n    # Visited set stores (position, direction) tuples to avoid cycles and redundant work.\n    visited = {(start_pos, start_dir)}\n\n    while queue:\n        pos, direction, path = queue.popleft()\n        x, y = pos\n\n        # --- 1. Goal Check ---\n        # Check if the cell we are currently facing contains the target primitive.\n        if direction in ACTION_VECTORS:\n            dx, dy = ACTION_VECTORS[direction]\n            facing_pos = (x + dx, y + dy)\n\n            if facing_pos in target_locs:\n                # Success! We are positioned and oriented correctly. The plan is to USE.\n                return path + [craft.USE]\n\n        # --- 2. Explore Next Moves ---\n        for move_action in MOVE_ACTIONS:\n            dx, dy = ACTION_VECTORS[move_action]\n            next_pos = (x + dx, y + dy)\n            next_dir = move_action  # A move sets the new direction.\n\n            # Check if the new state is valid to explore.\n            if not (0 <= next_pos[0] < w and 0 <= next_pos[1] < h):\n                continue  # Out of bounds.\n\n            if (next_pos, next_dir) in visited:\n                continue  # Already been in this state (position and direction).\n\n            # Check if the destination cell is traversable (not blocked by a wall).\n            is_blocked = False\n            for kind_idx in env.world.non_grabbable_indices:\n                if grid[next_pos[0], next_pos[1], kind_idx] > 0:\n                    is_blocked = True\n                    break\n            \n            if not is_blocked:\n                # This is a valid new state to visit. Add it to the queue.\n                visited.add((next_pos, next_dir))\n                new_path = path + [move_action]\n                queue.append((next_pos, next_dir, new_path))\n\n    # If the queue is exhausted, no path could be found.\n    return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a cell adjacent to the target primitive. The search space includes\n  not only the agent's (x, y) position but also its direction, as turning\n  is essential for the final 'USE' action.\n\n  The core assumptions about the action space are:\n  - An action like craft.RIGHT will turn the agent to face right if it's not\n    already facing right.\n  - If the agent is already facing right, craft.RIGHT will move it one step\n    in that direction.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of integer actions (e.g., craft.UP, craft.USE) to execute,\n    or an empty list if the primitive is unreachable.\n  \"\"\"\n\n  # --- 1. Setup and Definitions ---\n\n  # Define direction vectors and their mapping to actions and internal dir ints.\n  # We assume a standard mapping for the internal direction integer `state.dir`:\n  # 0: North (-y), 1: East (+x), 2: South (+y), 3: West (-x)\n  DIRECTIONS = {\n      \"NORTH\": (0, -1),\n      \"EAST\": (1, 0),\n      \"SOUTH\": (0, 1),\n      \"WEST\": (-1, 0),\n  }\n  \n  INT_TO_DIR_VECTOR = [DIRECTIONS[\"NORTH\"], DIRECTIONS[\"EAST\"], DIRECTIONS[\"SOUTH\"], DIRECTIONS[\"WEST\"]]\n  \n  ACTION_TO_DIR_VECTOR = {\n      craft.UP: DIRECTIONS[\"NORTH\"],\n      craft.RIGHT: DIRECTIONS[\"EAST\"],\n      craft.DOWN: DIRECTIONS[\"SOUTH\"],\n      craft.LEFT: DIRECTIONS[\"WEST\"],\n  }\n\n  DIR_VECTOR_TO_ACTION = {v: k for k, v in ACTION_TO_DIR_VECTOR.items()}\n\n  grid = env._current_state.grid\n  width, height, _ = grid.shape\n  non_grabbable_indices = env.world.non_grabbable_indices\n  target_idx = env.world.cookbook.index[primitive]\n\n  def is_walkable(pos):\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is walkable if it contains no non-grabbable entities.\n    for kind_idx in non_grabbable_indices:\n      if grid[x, y, kind_idx] > 0:\n        return False\n    return True\n\n  # --- 2. Identify Target and Goal States ---\n\n  # Find all locations of the target primitive.\n  primitive_locs = np.argwhere(grid[:, :, target_idx] > 0)\n  if primitive_locs.shape[0] == 0:\n    return []  # Primitive not found on the map.\n\n  # A goal state is a tuple of ((agent_x, agent_y), agent_dir_vector)\n  # where the agent is adjacent to the primitive and facing it.\n  goal_states = set()\n  for loc in primitive_locs:\n    px, py = loc\n    for dir_vector in ACTION_TO_DIR_VECTOR.values():\n      # The required position is adjacent to the primitive.\n      goal_pos = (px - dir_vector[0], py - dir_vector[1])\n      # The required direction is facing the primitive from that position.\n      goal_dir = dir_vector\n      if is_walkable(goal_pos):\n        goal_states.add((goal_pos, goal_dir))\n\n  if not goal_states:\n    return [] # No accessible cells next to the primitive.\n\n  # --- 3. Breadth-First Search (BFS) ---\n\n  start_pos = env._current_state.pos\n  start_dir_vector = INT_TO_DIR_VECTOR[env._current_state.dir]\n  start_state = (start_pos, start_dir_vector)\n\n  # The queue stores tuples of: ( (current_pos, current_dir_vector), path_so_far )\n  queue = collections.deque([(start_state, [])])\n  # Visited set stores states to prevent cycles and redundant exploration.\n  visited = {start_state}\n\n  while queue:\n    (current_pos, current_dir_vector), path = queue.popleft()\n\n    # Check if the current state is a goal state.\n    if (current_pos, current_dir_vector) in goal_states:\n      return path + [craft.USE]\n\n    # Explore the 4 possible actions from the current state.\n    for action, action_dir_vector in ACTION_TO_DIR_VECTOR.items():\n      \n      # Determine the next state based on the action.\n      # Case 1: The action is a turn (agent changes direction on the spot).\n      if current_dir_vector != action_dir_vector:\n        next_pos = current_pos\n        next_dir_vector = action_dir_vector\n        is_move_valid = True\n      # Case 2: The action is a move forward.\n      else:\n        next_pos = (current_pos[0] + current_dir_vector[0], \n                    current_pos[1] + current_dir_vector[1])\n        next_dir_vector = current_dir_vector\n        is_move_valid = is_walkable(next_pos)\n\n      # If the resulting state is valid and has not been visited, add it to the queue.\n      if is_move_valid:\n        next_state = (next_pos, next_dir_vector)\n        if next_state not in visited:\n          visited.add(next_state)\n          queue.append((next_state, path + [action]))\n\n  return [] # No path found to any goal state.\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, navigate to, and collect a primitive item.\n  This function uses Dijkstra's algorithm to find the shortest path in terms of actions.\n  It can handle clearing obstacles with tools if they are available in the inventory.\n  \"\"\"\n  # Assuming standard directions: 0:UP (+y), 1:RIGHT (+x), 2:DOWN (-y), 3:LEFT (-x)\n  DIR_TO_VEC = {\n      0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)\n  }\n  VEC_TO_DIR = {v: k for k, v in DIR_TO_VEC.items()}\n  DIR_TO_ACTION = {\n      0: craft.UP, 1: craft.RIGHT, 2: craft.DOWN, 3: craft.LEFT\n  }\n\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  inventory = state.inventory\n  width, height, _ = grid.shape\n\n  # --- 1. Setup: Tool capabilities and target identification ---\n\n  # Define what tools can clear which obstacles based on game logic.\n  tool_map = {}\n  # Safely get indices to prevent errors if items don't exist in the cookbook\n  try:\n      tool_map[world.cookbook.index['AXE']] = {world.cookbook.index['WOOD']}\n  except KeyError: pass\n  try:\n      tool_map[world.cookbook.index['BRIDGE']] = {world.cookbook.index['WATER']}\n  except KeyError: pass\n\n  # Identify obstacles the agent can currently remove.\n  removable_obstacles = set()\n  for tool_idx, obstacles in tool_map.items():\n      if inventory[tool_idx] > 0:\n          removable_obstacles.update(obstacles)\n  \n  try:\n      target_idx = world.cookbook.index[primitive]\n  except KeyError:\n      return [] # Primitive does not exist in this world.\n\n  # --- 2. Identify Goal Positions ---\n\n  # Create a boolean mask of all non-traversable locations.\n  non_grabbable_mask = np.sum(grid[:, :, list(world.non_grabbable_indices)], axis=2) > 0\n  \n  primitive_locs = {tuple(loc) for loc in np.argwhere(grid[:, :, target_idx] > 0)}\n  if not primitive_locs:\n      return []\n\n  # Goal positions are empty/passable cells adjacent to any primitive instance.\n  goal_positions = set()\n  for x, y in primitive_locs:\n      for dx, dy in DIR_TO_VEC.values():\n          nx, ny = x + dx, y + dy\n          if 0 <= nx < width and 0 <= ny < height and not non_grabbable_mask[nx, ny]:\n              goal_positions.add((nx, ny))\n\n  if not goal_positions:\n      return [] # Primitive is completely surrounded and unreachable.\n\n  # --- 3. Dijkstra's Algorithm for Shortest Path ---\n\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  # Priority Queue state: (cost, pos, dir, path_list, removed_obstacles_frozenset)\n  pq = [(0, start_pos, start_dir, [], frozenset())]\n  \n  # Visited dictionary: {(pos, dir, removed_fs): min_cost}\n  visited = {}\n\n  while pq:\n      cost, pos, dir, path, removed_fs = heapq.heappop(pq)\n\n      state_key = (pos, dir, removed_fs)\n      if visited.get(state_key, float('inf')) <= cost:\n          continue\n      visited[state_key] = cost\n\n      # ** Goal Check: If agent has arrived at a valid position **\n      if pos in goal_positions:\n          # Determine which primitive we are next to in order to face it.\n          for vec in DIR_TO_VEC.values():\n              check_pos = (pos[0] + vec[0], pos[1] + vec[1])\n              if check_pos in primitive_locs:\n                  primitive_pos = check_pos\n                  break\n          \n          final_vec = (primitive_pos[0] - pos[0], primitive_pos[1] - pos[1])\n          target_dir = VEC_TO_DIR[final_vec]\n\n          # Calculate the shortest sequence of turns to face the target.\n          turns = []\n          dir_diff = (target_dir - dir + 4) % 4\n          if dir_diff == 1: turns = [craft.RIGHT]\n          elif dir_diff == 2: turns = [craft.RIGHT, craft.RIGHT]\n          elif dir_diff == 3: turns = [craft.LEFT]\n          \n          return path + turns + [craft.USE]\n\n      # --- 4. Explore Successor States ---\n\n      # Actions: Turn Left/Right\n      for turn_action, dir_change in [(craft.LEFT, -1), (craft.RIGHT, 1)]:\n          new_dir = (dir + dir_change + 4) % 4\n          new_cost = cost + 1\n          if visited.get((pos, new_dir, removed_fs), float('inf')) > new_cost:\n              heapq.heappush(pq, (new_cost, pos, new_dir, path + [turn_action], removed_fs))\n      \n      # Actions involving the forward cell: Move or Use Tool\n      fwd_vec = DIR_TO_VEC[dir]\n      fwd_pos = (pos[0] + fwd_vec[0], pos[1] + fwd_vec[1])\n\n      if not (0 <= fwd_pos[0] < width and 0 <= fwd_pos[1] < height):\n          continue\n\n      is_traversable = fwd_pos in removed_fs or not non_grabbable_mask[fwd_pos[0], fwd_pos[1]]\n      \n      if is_traversable:\n          # Action: Move Forward\n          move_action = DIR_TO_ACTION[dir]\n          new_cost = cost + 1\n          if visited.get((fwd_pos, dir, removed_fs), float('inf')) > new_cost:\n               heapq.heappush(pq, (new_cost, fwd_pos, dir, path + [move_action], removed_fs))\n      else:\n          # Action: Use Tool (if cell is blocked by a removable obstacle)\n          obstacle_idx = np.argmax(grid[fwd_pos[0], fwd_pos[1], :])\n          if obstacle_idx in removable_obstacles:\n              new_removed_fs = removed_fs.union({fwd_pos})\n              new_cost = cost + 1  # Cost of the USE action\n              if visited.get((pos, dir, new_removed_fs), float('inf')) > new_cost:\n                  # Agent position/direction do not change after using a tool\n                  heapq.heappush(pq, (new_cost, pos, dir, path + [craft.USE], new_removed_fs))\n\n  return [] # No path found\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, approach, and collect a primitive item.\n\n  This function implements a Breadth-First Search (BFS) over the game state space\n  to find the shortest action sequence. It can plan paths around obstacles and\n  also generate plans to clear obstacles using the appropriate tools from the\n  agent's inventory.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of integer actions (e.g., [UP, RIGHT, USE]) to collect the primitive,\n    or an empty list if it's not possible.\n  \"\"\"\n  \n  # Action constants are defined by the environment's action specs.\n  # DOWN=0, UP=1, LEFT=2, RIGHT=3, USE=4\n  actions = env.action_specs()\n  UP, DOWN, LEFT, RIGHT, USE = actions['UP'], actions['DOWN'], actions['LEFT'], actions['RIGHT'], actions['USE']\n  MOVE_ACTIONS = [UP, DOWN, LEFT, RIGHT]\n\n  initial_state = env._current_state\n  primitive_idx = env.world.cookbook.index[primitive]\n  \n  # Define which tools can clear which obstacles. This would typically be part\n  # of the game's rule definitions but is hardcoded here for clarity.\n  obstacle_to_tool = {}\n  # Using .get to avoid errors if items like 'WOOD' or 'AXE' don't exist in the cookbook\n  wood_idx = env.world.cookbook.index.get('WOOD')\n  axe_idx = env.world.cookbook.index.get('AXE')\n  if wood_idx is not None and axe_idx is not None:\n      obstacle_to_tool[wood_idx] = axe_idx\n  \n  # The BFS queue stores tuples of (CraftState, path_of_actions).\n  queue = collections.deque([(initial_state, [])])\n  \n  # The visited set stores hashes of states (position and grid) to avoid cycles\n  # and redundant exploration. This is crucial for handling states where the\n  # grid changes, e.g., after an obstacle is removed.\n  visited = {(initial_state.pos, initial_state.grid.tobytes())}\n\n  # This mapping is an assumption about the environment's internal logic,\n  # where direction `dir` (0-3) maps to a coordinate change (dx, dy).\n  # Assuming 0:Up, 1:Right, 2:Down, 3:Left (clockwise).\n  dir_deltas = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\n  while queue:\n    current_state, path = queue.popleft()\n    \n    # --- 1. Explore MOVE actions ---\n    for action in MOVE_ACTIONS:\n      # The step function is non-mutating and returns a new state object.\n      _reward, next_state = current_state.step(action)\n      \n      # Proceed only if the move was successful (i.e., the agent's position changed).\n      if next_state.pos != current_state.pos:\n        \n        # Check for GOAL condition: Is the agent now facing the target primitive?\n        new_dir = next_state.dir\n        dx, dy = dir_deltas[new_dir]\n        faced_pos = (next_state.pos[0] + dx, next_state.pos[1] + dy)\n        \n        width, height, _ = next_state.grid.shape\n        if 0 <= faced_pos[0] < width and 0 <= faced_pos[1] < height:\n          if next_state.grid[faced_pos[0], faced_pos[1], primitive_idx] > 0:\n            # SUCCESS: The path followed by this move and a final USE collects the item.\n            return path + [action, USE]\n\n        # If not a goal, add the new state to the queue if it hasn't been visited.\n        state_tuple = (next_state.pos, next_state.grid.tobytes())\n        if state_tuple not in visited:\n          visited.add(state_tuple)\n          queue.append((next_state, path + [action]))\n\n    # --- 2. Explore USE action (for clearing obstacles) ---\n    current_dir = current_state.dir\n    dx, dy = dir_deltas[current_dir]\n    faced_pos = (current_state.pos[0] + dx, current_state.pos[1] + dy)\n\n    width, height, _ = current_state.grid.shape\n    if 0 <= faced_pos[0] < width and 0 <= faced_pos[1] < height:\n      # Check if the faced cell contains a known, clearable obstacle.\n      for obstacle_idx, tool_idx in obstacle_to_tool.items():\n        if current_state.grid[faced_pos[0], faced_pos[1], obstacle_idx] > 0:\n          # Check if the agent possesses the required tool.\n          if current_state.inventory[tool_idx] > 0:\n            # Simulate the USE action to clear the obstacle.\n            _reward, next_state = current_state.step(USE)\n            state_tuple = (next_state.pos, next_state.grid.tobytes())\n            \n            # Add the resulting state to the queue if it's new.\n            if state_tuple not in visited:\n              visited.add(state_tuple)\n              queue.append((next_state, path + [USE]))\n            # Only one type of obstacle can be in a cell, so we can break early.\n            break\n\n  # If the queue empties and no solution has been found, it's impossible.\n  return []\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a cell adjacent to the target primitive. The key insight is that the\n  agent must not only be adjacent to the primitive but also be *facing* it\n  to perform the 'USE' action. Therefore, the BFS search goal is not just a\n  position, but a state tuple of (position, orientation). The orientation is\n  determined by the last move action taken to reach the position.\n\n  The algorithm works as follows:\n  1.  Identify all locations of the target primitive on the grid.\n  2.  For each primitive location, determine the valid \"goal states\". A goal\n      state is a tuple `(position, action)`, where `position` is an empty\n      cell adjacent to the primitive, and `action` is the move that would\n      make the agent face the primitive from that position.\n  3.  Perform a BFS starting from the agent's current position. The queue\n      stores tuples of `(current_position, path_of_actions)`.\n  4.  The search explores the grid, expanding to neighboring passable cells. A\n      cell is passable only if it is completely empty.\n  5.  A solution is found when the BFS reaches a position `p` with a final\n      move `a` such that `(p, a)` is one of the pre-calculated goal states.\n  6.  The final action sequence is the path found by the BFS, with the 'USE'\n      action appended.\n  7.  If the agent already starts in a position to collect the primitive,\n      it returns `[craft.USE]` immediately.\n  8.  If no path is found, it returns an empty list.\n  \"\"\"\n  # Action constants and mappings for converting between actions and 2D vectors\n  actions = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # Get current state information from the environment\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  width, height, _ = grid.shape\n\n  # Get the integer index for the primitive name from the world's cookbook\n  try:\n      target_idx = env.world.cookbook.index[primitive]\n  except KeyError:\n      # The requested primitive does not exist in this world's configuration\n      return []\n\n  # Helper function to check if a cell is passable (within bounds and empty)\n  def is_passable(pos):\n      x, y = pos\n      if not (0 <= x < width and 0 <= y < height):\n          return False\n      # According to the game rules, any non-empty cell is blocked.\n      return np.sum(grid[x, y, :]) == 0\n\n  # 1. Identify all goal states: (position_to_stand, required_final_action)\n  goals = set()\n  for y in range(height):\n      for x in range(width):\n          if grid[x, y, target_idx] > 0:\n              target_pos = (x, y)\n              # Check 4 adjacent cells as potential standing spots\n              for action, vec in actions.items():\n                  # The goal position is adjacent to the target.\n                  # The 'action' is the direction from the goal_pos to the target_pos.\n                  goal_pos = (target_pos[0] - vec[0], target_pos[1] - vec[1])\n                  if is_passable(goal_pos):\n                      # The goal is to arrive at 'goal_pos' having just performed 'action'\n                      goals.add((goal_pos, action))\n\n  if not goals:\n      return []  # No accessible primitives of this type exist\n\n  # 2. Handle edge case: agent might already be in a position to collect\n  agent_dir_vec = actions.get(state.dir)\n  if agent_dir_vec:\n      pos_in_front = (start_pos[0] + agent_dir_vec[0], start_pos[1] + agent_dir_vec[1])\n      if (0 <= pos_in_front[0] < width and 0 <= pos_in_front[1] < height):\n          if grid[pos_in_front[0], pos_in_front[1], target_idx] > 0:\n              return [craft.USE]\n\n  # 3. Perform Breadth-First Search to find the shortest path to a goal state\n  queue = collections.deque([(start_pos, [])])  # (position, path_list)\n  visited = {start_pos}\n\n  while queue:\n      current_pos, path = queue.popleft()\n\n      # Explore neighbors\n      for action, vec in actions.items():\n          next_pos = (current_pos[0] + vec[0], current_pos[1] + vec[1])\n\n          # Check if this move leads to a solution\n          if (next_pos, action) in goals:\n              return path + [action, craft.USE]\n\n          # If not a solution, check if it's a valid next step for the search\n          if next_pos not in visited and is_passable(next_pos):\n              visited.add(next_pos)\n              new_path = path + [action]\n              queue.append((next_pos, new_path))\n\n  # 4. No path found\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a primitive.\n\n    This function implements a Breadth-First Search (BFS) algorithm to find the\n    shortest path of actions. The search space is the state of the agent,\n    defined by its position, direction, and the set of cleared obstacles on the map.\n\n    The BFS explores possible sequences of actions (moving and using tools to\n    clear obstacles) until it finds a state where the agent is facing the\n    target primitive. It then appends the 'USE' action to collect it.\n\n    This approach correctly handles:\n    1. Pathfinding to an adjacent cell, not onto the primitive's cell.\n    2. Agent orientation, ensuring the agent faces the primitive before collection.\n    3. Dynamic environments, where using a tool (e.g., an axe on wood) changes\n       the walkability of the grid for subsequent pathfinding steps.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    grid = state.grid\n    width, height, _ = grid.shape\n    inventory = state.inventory\n    cookbook = world.cookbook\n\n    try:\n        primitive_index = cookbook.index[primitive]\n    except KeyError:\n        return []  # Primitive name is not valid\n\n    # --- Mappings and Tool Definitions ---\n\n    # Define tool-to-obstacle relationships. This mapping is inferred from\n    # common game mechanics as the API does not provide it directly.\n    tool_obstacle_map = {\n        'AXE': {'WOOD'},\n        'HAMMER': {'STONE', 'ROCK'},\n    }\n\n    # Convert string names to integer indices and identify tools the agent has.\n    agent_tools = {}\n    for tool_name, obstacle_names in tool_obstacle_map.items():\n        if tool_name in cookbook.index and inventory[cookbook.index[tool_name]] > 0:\n            tool_idx = cookbook.index[tool_name]\n            obstacle_indices = {cookbook.index[obs] for obs in obstacle_names if obs in cookbook.index}\n            if obstacle_indices:\n                agent_tools[tool_idx] = obstacle_indices\n    \n    # Pre-scan grid for obstacles the agent can clear with their current tools.\n    clearable_obstacles = {}\n    for x in range(width):\n        for y in range(height):\n            # An obstacle is a non-grabbable item.\n            for obstacle_idx in world.non_grabbable_indices:\n                if grid[x, y, obstacle_idx] > 0:\n                    for tool_idx, valid_obstacles in agent_tools.items():\n                        if obstacle_idx in valid_obstacles:\n                            clearable_obstacles[(x, y)] = obstacle_idx\n                            break\n\n    # Action mappings: action_constant -> {delta_position, new_direction}\n    # Directions: 0:Up(N), 1:Right(E), 2:Down(S), 3:Left(W)\n    action_map = {\n        craft.UP:    {'delta': (0, -1), 'dir': 0},\n        craft.DOWN:  {'delta': (0, 1),  'dir': 2},\n        craft.LEFT:  {'delta': (-1, 0), 'dir': 3},\n        craft.RIGHT: {'delta': (1, 0),  'dir': 1},\n    }\n    dir_to_delta = {v['dir']: v['delta'] for v in action_map.values()}\n\n    def is_cell_walkable(pos, cleared_obstacles):\n        x, y = pos\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        if pos in cleared_obstacles:\n            return True\n        # A cell is walkable if it is empty (contains no items of any kind).\n        return np.sum(grid[x, y, :]) == 0\n\n    # --- BFS Initialization ---\n\n    # State: (position, direction, path_list, cleared_obstacles_frozenset)\n    start_pos = state.pos\n    start_dir = state.dir\n    initial_state = (start_pos, start_dir, [], frozenset())\n\n    queue = collections.deque([initial_state])\n    # Visited: {(position, direction, cleared_obstacles_frozenset)} to prevent cycles.\n    visited = {(start_pos, start_dir, frozenset())}\n\n    # --- BFS Execution ---\n\n    while queue:\n        pos, direction, path, cleared = queue.popleft()\n\n        # 1. GOAL CHECK: Is the agent facing the target primitive?\n        if direction in dir_to_delta:\n            delta = dir_to_delta[direction]\n            front_pos = (pos[0] + delta[0], pos[1] + delta[1])\n            \n            if (0 <= front_pos[0] < width and 0 <= front_pos[1] < height) and \\\n               grid[front_pos[0], front_pos[1], primitive_index] > 0:\n                return path + [craft.USE]\n\n        # 2. EXPAND STATE: Try all possible actions from the current state.\n\n        # 2a. Try moving (UP, DOWN, LEFT, RIGHT)\n        for action, move_info in action_map.items():\n            new_pos = (pos[0] + move_info['delta'][0], pos[1] + move_info['delta'][1])\n            new_dir = move_info['dir']\n\n            if is_cell_walkable(new_pos, cleared):\n                new_state_tuple = (new_pos, new_dir, cleared)\n                if new_state_tuple not in visited:\n                    visited.add(new_state_tuple)\n                    new_path = path + [action]\n                    queue.append((new_pos, new_dir, new_path, cleared))\n        \n        # 2b. Try clearing an obstacle in front of the agent\n        if direction in dir_to_delta:\n            delta = dir_to_delta[direction]\n            front_pos = (pos[0] + delta[0], pos[1] + delta[1])\n            \n            if front_pos in clearable_obstacles and front_pos not in cleared:\n                # The USE action clears the obstacle but doesn't move the agent.\n                # This creates a new state at the same position/direction but with an\n                # updated set of cleared obstacles.\n                new_cleared = cleared.union({front_pos})\n                new_state_tuple = (pos, direction, new_cleared)\n                \n                if new_state_tuple not in visited:\n                    visited.add(new_state_tuple)\n                    new_path = path + [craft.USE]\n                    queue.append((pos, direction, new_path, new_cleared))\n\n    # If the queue becomes empty and no solution was found\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) to find the shortest path\n  to a state where the agent is adjacent to and facing the target primitive.\n  The search space includes both the agent's position and its direction, as\n  direction can only be changed by moving.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the optimal plan, or an empty\n    list if the primitive is unreachable.\n  \"\"\"\n  # --- 1. Setup and Mappings ---\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n\n  # Define relationships between actions, direction vectors, and direction indices.\n  # We assume a standard mapping for direction indices (0:UP, 1:RIGHT, 2:DOWN, 3:LEFT).\n  ACTION_VECTORS = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  \n  DIR_MAP = {\n      0: craft.UP,\n      1: craft.RIGHT,\n      2: craft.DOWN,\n      3: craft.LEFT,\n  }\n  ACTION_TO_DIR = {v: k for k, v in DIR_MAP.items()}\n\n  # --- 2. Identify Target and Obstacles ---\n  try:\n    target_idx = world.cookbook.index[primitive]\n  except KeyError:\n    return [] # Primitive name not found in cookbook\n\n  # Find all grid locations containing the target primitive.\n  # np.where returns (row_indices, col_indices), matching (y, x) for a grid[x, y] access pattern.\n  prim_ys, prim_xs = np.where(grid[:, :, target_idx].T > 0)\n  primitive_locations = set(zip(prim_xs, prim_ys))\n\n  if not primitive_locations:\n    return [] # Primitive does not exist in the world.\n\n  # Pre-calculate a boolean map of all impassable cells.\n  non_grabbable_mask = np.sum(grid[:, :, list(world.non_grabbable_indices)], axis=2) > 0\n\n  # --- 3. Breadth-First Search (BFS) ---\n  # The state in our search is (position, direction, path_to_state).\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  # Initial queue and set to track visited (position, direction) pairs.\n  queue = collections.deque([(start_pos, start_dir, [])])\n  visited = {(start_pos, start_dir)}\n\n  while queue:\n    pos, dir_idx, path = queue.popleft()\n\n    # Expand search to neighbors by trying every possible move action.\n    for move_action, vec in ACTION_VECTORS.items():\n      # The position the agent will move to.\n      next_pos = (pos[0] + vec[0], pos[1] + vec[1])\n\n      # --- Boundary and Obstacle Checks ---\n      if not (0 <= next_pos[0] < width and 0 <= next_pos[1] < height):\n        continue\n      if non_grabbable_mask[next_pos[0], next_pos[1]]:\n        continue\n\n      # The agent's new direction is determined by the move it just made.\n      next_dir_idx = ACTION_TO_DIR[move_action]\n      \n      if (next_pos, next_dir_idx) in visited:\n        continue\n      \n      # The cell the agent will be facing after the move.\n      faced_pos = (next_pos[0] + vec[0], next_pos[1] + vec[1])\n      new_path = path + [move_action]\n\n      # --- Goal Check ---\n      # The goal is reached if the agent is facing a cell with the primitive.\n      if faced_pos in primitive_locations:\n        # Found the shortest path to a valid collection state.\n        return new_path + [craft.USE]\n\n      # This is a valid, non-goal state; add it to the queue and visited set.\n      visited.add((next_pos, next_dir_idx))\n      queue.append((next_pos, next_dir_idx, new_path))\n            \n  # If the queue is exhausted, no path exists.\n  return []\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move to, and collect a specified primitive.\n\n  The strategy involves:\n  1. Identifying all locations of the target primitive on the grid.\n  2. Determining valid \"goal\" positions, which are empty cells adjacent to the primitive.\n  3. Using Breadth-First Search (BFS) to find the shortest path of moves from the agent's\n     current position to one of these goal positions, traversing only through empty cells.\n  4. Once a path is found, appending an action to turn the agent towards the primitive.\n     This is achieved by attempting to move into the primitive's cell, which updates the\n     agent's direction without changing its position.\n  5. Appending the 'USE' action to collect the primitive.\n  \"\"\"\n  state = env._current_state\n  world = env.world\n  grid = state.grid\n  start_pos = state.pos\n\n  try:\n    primitive_idx = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the game's vocabulary.\n    return []\n\n  grid_w, grid_h, _ = grid.shape\n\n  # Define movement vectors and their corresponding action constants.\n  # Assumes a grid where (dx, dy) corresponds to (change_in_x, change_in_y).\n  moves = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (1, 0): craft.RIGHT,\n      (-1, 0): craft.LEFT,\n  }\n  deltas = list(moves.keys())\n\n  # --- Step 1 & 2: Find all target locations and their adjacent, traversable goal cells ---\n  \n  # This dictionary maps a valid goal position to the primitive location it's adjacent to.\n  goal_map = {}\n  \n  # Find all coordinates where the target primitive exists.\n  target_locations = np.argwhere(grid[:, :, primitive_idx] > 0)\n\n  if target_locations.shape[0] == 0:\n    return [] # Primitive not found on the map.\n\n  # Pre-calculate a boolean mask for all non-traversable cells for efficiency.\n  non_grabbable_indices_list = list(world.non_grabbable_indices)\n  non_traversable_mask = np.sum(grid[:, :, non_grabbable_indices_list], axis=2) > 0\n\n  for tx, ty in target_locations:\n    for dx, dy in deltas:\n      # ax, ay are coordinates of a cell adjacent to the primitive\n      ax, ay = tx + dx, ty + dy\n      \n      if 0 <= ax < grid_w and 0 <= ay < grid_h:\n        # A cell is a valid goal if it's traversable.\n        if not non_traversable_mask[ax, ay]:\n          goal_map[(ax, ay)] = (tx, ty)\n\n  if not goal_map:\n    return [] # No accessible cells next to any instance of the primitive.\n\n  # --- Step 3: BFS to find the shortest path to a goal cell ---\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n    current_pos, path = queue.popleft()\n\n    # If the current position is one of our goals, we have found the shortest path.\n    if current_pos in goal_map:\n      final_actions = list(path)\n      target_pos = goal_map[current_pos]\n      \n      # --- Step 4: Add the action to turn and face the primitive ---\n      dx = target_pos[0] - current_pos[0]\n      dy = target_pos[1] - current_pos[1]\n      \n      # This move action will be blocked but will correctly orient the agent.\n      turn_action = moves[(dx, dy)]\n      final_actions.append(turn_action)\n      \n      # --- Step 5: Add the USE action to perform the collection ---\n      final_actions.append(craft.USE)\n      \n      return final_actions\n\n    # Explore neighbors to expand the search.\n    cx, cy = current_pos\n    for dx, dy in deltas:\n      nx, ny = cx + dx, cy + dy\n      neighbor_pos = (nx, ny)\n\n      if (0 <= nx < grid_w and 0 <= ny < grid_h and\n          neighbor_pos not in visited and\n          not non_traversable_mask[nx, ny]):\n        \n        visited.add(neighbor_pos)\n        move_action = moves[(dx, dy)]\n        new_path = path + [move_action]\n        queue.append((neighbor_pos, new_path))\n\n  # If the queue empties, no path exists.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find, navigate to, and collect a primitive item.\n\n    This function implements a two-stage process:\n    1. Pathfinding: A Breadth-First Search (BFS) finds the shortest path of grid\n       positions from the agent's start to a cell adjacent to the target primitive.\n       The BFS can path through obstacles if the agent possesses the required tool.\n    2. Action Generation: The list of positions is converted into a sequence of low-level\n       actions (turn, move forward, use tool), correctly managing the agent's orientation\n       at each step.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    grid = state.grid\n    start_pos = state.pos\n    start_dir = state.dir\n    inventory = state.inventory\n    width, height, _ = grid.shape\n\n    # DIRS[dir] = (dx, dy) mapping an agent's direction index to a coordinate change.\n    # Assumes standard orientation: 0:North(Up), 1:East(Right), 2:South(Down), 3:West(Left).\n    DIRS = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\n    # This map defines which tools can clear which obstacles. This information is not\n    # explicitly available in the provided API, so it's defined here based on game logic.\n    tool_map = {\n        'axe': {'wood'},\n        'hammer': {'rock'},\n    }\n    \n    # Convert item string names to their corresponding indices for efficient lookups.\n    tool_indices_map = {}\n    for tool, obstacles in tool_map.items():\n        try:\n            tool_idx = world.cookbook.index[tool]\n            obstacle_indices = {world.cookbook.index[obs] for obs in obstacles if obs in world.cookbook.index}\n            if obstacle_indices:\n                tool_indices_map[tool_idx] = obstacle_indices\n        except KeyError:\n            # The tool or obstacle might not be defined in this specific recipe file.\n            continue\n\n    agent_tools = {idx for idx, count in enumerate(inventory) if count > 0 and idx in tool_indices_map}\n\n    def is_clearable(pos):\n        \"\"\"Checks if an obstacle at a given position can be cleared with current tools.\"\"\"\n        for tool_idx in agent_tools:\n            for obstacle_idx in tool_indices_map[tool_idx]:\n                if grid[pos[0], pos[1], obstacle_idx] > 0:\n                    return True\n        return False\n\n    def is_walkable(pos):\n        \"\"\"Checks if a cell is empty of non-grabbable items (i.e., permanent obstacles).\"\"\"\n        for ng_idx in world.non_grabbable_indices:\n            if grid[pos[0], pos[1], ng_idx] > 0:\n                return False\n        return True\n\n    # --- Stage 1: Pathfinding ---\n    primitive_idx = world.cookbook.index[primitive]\n    if primitive_idx is None:\n        return []\n\n    # Find all locations of the primitive and identify adjacent, valid target cells for the agent.\n    primitive_locs = np.argwhere(grid[:, :, primitive_idx] > 0)\n    goal_positions = set()\n    goal_to_primitive_map = {} \n\n    for p_loc in primitive_locs:\n        px, py = p_loc\n        # Check all 4 neighboring cells\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            gx, gy = px + dx, py + dy\n            goal_pos = (gx, gy)\n            if 0 <= gx < width and 0 <= gy < height:\n                # A goal is valid if the agent can stand there (either empty or clearable).\n                if is_walkable(goal_pos) or is_clearable(goal_pos):\n                    goal_positions.add(goal_pos)\n                    goal_to_primitive_map[goal_pos] = tuple(p_loc)\n    \n    if not goal_positions:\n        return []\n\n    # BFS to find the shortest path of positions.\n    queue = collections.deque([(start_pos, [start_pos])])\n    visited = {start_pos}\n    path_of_positions = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in goal_positions:\n            path_of_positions = path\n            break\n\n        for dx, dy in DIRS:\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            if 0 <= next_pos[0] < width and 0 <= next_pos[1] < height and next_pos not in visited:\n                # A path can go through an empty cell or a cell with a clearable obstacle.\n                if is_walkable(next_pos) or is_clearable(next_pos):\n                    visited.add(next_pos)\n                    queue.append((next_pos, path + [next_pos]))\n\n    if not path_of_positions:\n        return []\n\n    # --- Stage 2: Action Generation ---\n    actions = []\n    current_dir = start_dir\n    \n    def get_target_dir(p_from, p_to):\n        \"\"\"Calculates the direction index required to move from p_from to p_to.\"\"\"\n        dx, dy = p_to[0] - p_from[0], p_to[1] - p_from[1]\n        for i, (ddx, ddy) in enumerate(DIRS):\n            if (dx, dy) == (ddx, ddy):\n                return i\n        return -1\n\n    def append_turns(current_dir, target_dir):\n        \"\"\"Calculates and returns the shortest sequence of turning actions.\"\"\"\n        turn_actions = []\n        diff = (target_dir - current_dir + 4) % 4\n        if diff == 1:\n            turn_actions.append(craft.RIGHT)\n        elif diff == 2:\n            turn_actions.extend([craft.RIGHT, craft.RIGHT])\n        elif diff == 3:\n            turn_actions.append(craft.LEFT)\n        return turn_actions, target_dir\n\n    # Convert the position path into a sequence of agent actions.\n    for i in range(len(path_of_positions) - 1):\n        from_pos = path_of_positions[i]\n        to_pos = path_of_positions[i+1]\n        \n        target_dir = get_target_dir(from_pos, to_pos)\n        \n        # Turn to face the next cell in the path.\n        turn_acts, new_dir = append_turns(current_dir, target_dir)\n        actions.extend(turn_acts)\n        current_dir = new_dir\n\n        # If the destination cell contains an obstacle, use a tool to clear it.\n        if not is_walkable(to_pos):\n            actions.append(craft.USE)\n        \n        # Move forward into the (now clear) cell.\n        actions.append(craft.UP)\n\n    # Finally, align the agent to face the primitive and collect it.\n    final_pos = path_of_positions[-1]\n    primitive_pos = goal_to_primitive_map[final_pos]\n    \n    target_dir = get_target_dir(final_pos, primitive_pos)\n    turn_acts, _ = append_turns(current_dir, target_dir)\n    actions.extend(turn_acts)\n    \n    actions.append(craft.USE)\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move adjacent to, face, and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest path\n  to a state where the agent is positioned next to the target primitive and facing it.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of integer actions (e.g., [craft.UP, craft.LEFT, craft.USE]) to collect\n    the primitive, or an empty list if it's not possible.\n  \"\"\"\n\n  # --- Assumptions about Environment Mechanics ---\n  # Based on the provided documentation and common grid-world conventions, we assume:\n  # 1. Actions `UP`, `DOWN`, `LEFT`, `RIGHT` move the agent one cell in that cardinal direction\n  #    and simultaneously set the agent's direction to match the move.\n  # 2. The `USE` action interacts with the cell directly in front of the agent, based on its\n  #    current position and direction.\n  # 3. A cell is \"passable\" if and only if it is completely empty. Any item, resource,\n  #    or workshop on a cell makes it blocked for movement.\n\n  # Mapping from actions to coordinate changes (deltas).\n  # We assume a grid where (0,0) is top-left, +x is right, and +y is down.\n  ACTION_TO_DELTA = {\n      craft.UP: (0, -1),\n      craft.DOWN: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # Mapping from actions to the direction the agent will face after the action.\n  # We assume a direction representation that is consistent with the actions.\n  # Let's assume: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT, matching action values.\n  ACTION_TO_DIR = {\n      craft.DOWN: 0,\n      craft.UP: 1,\n      craft.LEFT: 2,\n      craft.RIGHT: 3,\n  }\n\n  # --- Helper Functions ---\n  def is_passable(pos, grid):\n    \"\"\"Checks if a grid cell is within bounds and empty.\"\"\"\n    x, y = pos\n    width, height, _ = grid.shape\n    if not (0 <= x < width and 0 <= y < height):\n        return False\n    # A cell is passable if it contains nothing (sum of its one-hot vector is 0).\n    return np.sum(grid[x, y, :]) == 0\n\n  # --- Main Logic ---\n\n  # 1. Initialization\n  state = env._current_state\n  world = env.world\n  grid = state.grid\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  try:\n    target_idx = world.cookbook.index[primitive]\n  except KeyError:\n    # The primitive name is not in the cookbook.\n    return []\n\n  # 2. Find all locations of the target primitive.\n  primitive_locs = np.argwhere(grid[:, :, target_idx] > 0)\n  if primitive_locs.size == 0:\n    return [] # Primitive does not exist on the map.\n\n  # 3. Define all possible goal states: (position, direction).\n  # A goal state is being in an empty cell adjacent to the primitive, facing it.\n  goals = set()\n  for tx, ty in primitive_locs:\n    for action, (dx, dy) in ACTION_TO_DELTA.items():\n      # The adjacent position from which we would collect.\n      adj_pos = (tx - dx, ty - dy)\n      \n      # The direction we need to be facing at adj_pos to target (tx, ty).\n      required_dir = ACTION_TO_DIR[action]\n      \n      if is_passable(adj_pos, grid):\n        goals.add((adj_pos, required_dir))\n\n  if not goals:\n    return [] # No accessible cells next to the primitive.\n\n  # 4. Perform Breadth-First Search (BFS) to find the shortest path.\n  # The state in the queue is (position, direction, path_so_far).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid cycles.\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # Check if the current state is one of the goal states.\n    if (pos, direction) in goals:\n      # Path found. The final action is to USE the object in front.\n      return path + [craft.USE]\n\n    # Explore neighbors by trying all possible move actions.\n    for action, delta in ACTION_TO_DELTA.items():\n      new_pos = (pos[0] + delta[0], pos[1] + delta[1])\n      new_dir = ACTION_TO_DIR[action]\n      \n      # A new state is valid if the destination is passable and we haven't\n      # been in this state (position and direction) before.\n      if is_passable(new_pos, grid) and (new_pos, new_dir) not in visited:\n        visited.add((new_pos, new_dir))\n        new_path = path + [action]\n        queue.append((new_pos, new_dir, new_path))\n        \n  # 5. If the queue becomes empty, no path was found.\n  return []\n\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find and collect a specified primitive.\n\n    This function uses a Breadth-First Search (BFS) to find the shortest\n    sequence of actions to move the agent next to a target primitive, orient\n    itself correctly, and then collect it using the 'USE' action.\n\n    The state in the BFS is represented by `(position, direction)`, ensuring that\n    the generated path correctly accounts for the agent's orientation, which is\n    critical for the 'USE' action. A cell is considered blocked if any object,\n    grabbable or not, is present, as the agent can only move into empty cells.\n\n    Args:\n        env: The environment instance, providing access to the current state\n             (grid, agent position, etc.) and world information.\n        primitive: The string name of the primitive to collect.\n\n    Returns:\n        A list of action integers representing the shortest plan to collect\n        the primitive. Returns an empty list if the primitive is unreachable.\n    \"\"\"\n    state = env._current_state\n    grid = state.grid\n    cookbook = env.world.cookbook\n    width, height, _ = grid.shape\n\n    try:\n        target_idx = cookbook.index[primitive]\n    except KeyError:\n        # The requested primitive does not exist in the world's cookbook.\n        return []\n\n    # --- Mappings for Directions and Actions ---\n    # Directions are represented as integers (0:Up, 1:Right, 2:Down, 3:Left),\n    # corresponding to North, East, South, West.\n    # Actions are integer constants defined in the `craft` module.\n    # We assume a move action (e.g., craft.UP) sets the agent's direction\n    # and moves it one step in that direction.\n\n    # Maps direction index to a (dx, dy) tuple for position changes.\n    dir_to_delta = {\n        0: (0, -1),  # Up (North)\n        1: (1, 0),   # Right (East)\n        2: (0, 1),   # Down (South)\n        3: (-1, 0),  # Left (West)\n    }\n\n    # Maps a move action to the direction it sets the agent to face.\n    action_to_dir = {\n        craft.UP: 0,    # UP action makes agent face Up (dir 0)\n        craft.RIGHT: 1, # RIGHT action makes agent face Right (dir 1)\n        craft.DOWN: 2,  # DOWN action makes agent face Down (dir 2)\n        craft.LEFT: 3,  # LEFT action makes agent face Left (dir 3)\n    }\n    move_actions = list(action_to_dir.keys())\n\n    def is_blocked(x, y):\n        \"\"\"Checks if a cell at (x, y) is blocked (impassable).\"\"\"\n        if not (0 <= x < width and 0 <= y < height):\n            return True  # Out-of-bounds cells are blocked.\n        # Any item on a cell makes it impassable for movement.\n        return np.any(grid[x, y, :] > 0)\n\n    # --- BFS Initialization ---\n    start_pos = state.pos\n    start_dir = state.dir\n    \n    # Queue stores tuples of: (position, direction, path_so_far)\n    queue = collections.deque([(start_pos, start_dir, [])])\n    \n    # Visited set stores (position, direction) tuples to prevent cycles and redundant work.\n    visited = set([(start_pos, start_dir)])\n\n    # --- BFS Main Loop ---\n    while queue:\n        (current_pos, current_dir, path) = queue.popleft()\n        x, y = current_pos\n\n        # --- Goal Condition Check ---\n        # Check if the cell directly in front of the agent contains the target primitive.\n        if current_dir in dir_to_delta:\n            dx, dy = dir_to_delta[current_dir]\n            front_x, front_y = x + dx, y + dy\n\n            # If the front cell is in bounds and has the target, the plan is complete.\n            if (0 <= front_x < width and 0 <= front_y < height and\n                    grid[front_x, front_y, target_idx] > 0):\n                return path + [craft.USE]\n\n        # --- State Expansion ---\n        # Explore states reachable by taking each possible move action.\n        for action in move_actions:\n            # A move action determines the next direction and position.\n            next_dir = action_to_dir[action]\n            dx, dy = dir_to_delta[next_dir]\n            next_pos = (x + dx, y + dy)\n            \n            # Add the new state to the queue if it's valid (not blocked) and unvisited.\n            if not is_blocked(next_pos[0], next_pos[1]):\n                if (next_pos, next_dir) not in visited:\n                    visited.add((next_pos, next_dir))\n                    new_path = path + [action]\n                    queue.append((next_pos, next_dir, new_path))\n                \n    # If the queue becomes empty, it means no path exists.\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
