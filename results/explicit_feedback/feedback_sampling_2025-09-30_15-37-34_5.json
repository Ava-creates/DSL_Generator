{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find the shortest path to a primitive,\n  navigate to an adjacent cell, face the primitive, and then collect it.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path from the agent's current position to a cell adjacent to the target\n  primitive. It correctly handles obstacles and ensures the agent is facing\n  the primitive before issuing the 'USE' command.\n\n  Args:\n      env: The CraftLab environment instance.\n      primitive: A string representing the name of the primitive to collect.\n\n  Returns:\n      A list of integer actions (e.g., [craft.RIGHT, craft.UP, craft.USE])\n      representing the plan to collect the primitive. Returns an empty list\n      if the primitive is unreachable or does not exist.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n\n  # 1. --- Setup and Pre-computation ---\n\n  # Convert the string name of the primitive to its integer index.\n  try:\n    primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n    # If the primitive name is not recognized, no plan can be made.\n    return []\n\n  # Define the agent's possible moves as changes in (x, y) coordinates\n  # and map them to the corresponding action constants.\n  # Based on action_specs: DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923\n  # And assuming a standard grid where (x,y) corresponds to (col, row):\n  # UP:    (0, -1) -> action 1\n  # DOWN:  (0,  1) -> action 0\n  # LEFT:  (-1, 0) -> action 2\n  # RIGHT: (1,  0) -> action 3\n  moves = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  # For iterating through neighbors\n  directions = moves.keys()\n\n  # Get grid dimensions. Assumes grid shape is (WIDTH, HEIGHT, n_kinds).\n  width, height = grid.shape[0], grid.shape[1]\n\n  # Identify all impassable cells. Any cell with a 'non_grabbable' entity\n  # (like stone or water) is considered an obstacle.\n  impassable_indices = current_state.world.non_grabbable_indices\n  \n  def is_passable(pos):\n    \"\"\"Checks if a cell at a given position is empty and can be moved into.\"\"\"\n    x, y = pos\n    # A cell is passable if it does not contain any non-grabbable items.\n    if np.any(grid[x, y, list(impassable_indices)]):\n      return False\n    return True\n\n  # 2. --- Breadth-First Search (BFS) for Shortest Path ---\n\n  # The queue stores tuples of: (current_position, path_to_get_there)\n  queue = collections.deque([(start_pos, [])])\n  # The visited set stores positions we have already queued to avoid cycles.\n  visited = {start_pos}\n\n  while queue:\n    (current_x, current_y), path = queue.popleft()\n\n    # Explore neighbors of the current cell\n    for dx, dy in directions:\n      action = moves[(dx, dy)]\n      \n      # The neighboring cell we are considering\n      next_pos = (current_x + dx, current_y + dy)\n      next_x, next_y = next_pos\n\n      # Ensure the neighbor is within the grid boundaries\n      if not (0 <= next_x < width and 0 <= next_y < height):\n        continue\n\n      # --- Goal Condition ---\n      # The goal is to be *adjacent* to the primitive. We check if the\n      # neighboring cell ('next_pos') contains the target primitive.\n      if grid[next_x, next_y, primitive_index] > 0:\n        # Success! The path to the current position is the correct movement plan.\n        # The final action is the one that makes the agent face the primitive,\n        # followed by the USE action to collect it.\n        return path + [action, craft.USE]\n\n      # --- Traversal Condition ---\n      # If the neighbor is not the goal, check if we can move into it.\n      # It must be a passable (empty) and previously unvisited cell.\n      if next_pos not in visited and is_passable(next_pos):\n        visited.add(next_pos)\n        new_path = path + [action]\n        queue.append((next_pos, new_path))\n\n  # If the queue becomes empty, it means no path to a cell adjacent\n  # to the primitive was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Finds the shortest sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) over the state space,\n  which includes the agent's position and direction. The goal is to find a\n  state where the agent is adjacent to the target primitive and facing it,\n  allowing for a final 'USE' action to collect it.\n\n  The implementation correctly handles:\n  - Pathfinding to an adjacent cell, not the resource cell itself.\n  - Ensuring the agent is facing the resource before collecting.\n  - Identifying impassable terrain using the world's non_grabbable_indices.\n  \"\"\"\n  # Get current state and world information from the environment wrapper.\n  current_state = env._current_state\n  world = current_state.world\n  grid = current_state.grid\n  start_pos = current_state.pos  # Assumed to be (x, y) coordinates\n  start_dir = current_state.dir\n\n  # Convert the primitive name (string) to its corresponding integer index.\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # If the primitive name is not in the cookbook, no plan can be made.\n    return []\n\n  # Define the mapping from action codes to (dx, dy) changes in coordinates.\n  # This is based on the environment's action spec: DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923\n  # and a standard Cartesian coordinate system (x increases right, y increases up).\n  ACTION_VECTORS = {\n      craft.DOWN:  (0, -1),  # Action 0\n      craft.UP:    (0, 1),   # Action 1\n      craft.LEFT:  (-1, 0),  # Action 2\n      craft.RIGHT: (1, 0),   # Action 3\n  }\n  \n  # The agent's direction `dir` is an integer (0-3) that corresponds to the\n  # action that would move the agent in that direction.\n  \n  # Initialize the queue for BFS. Each item is a tuple of the agent's current\n  # state (position, direction) and the path of actions taken to reach it.\n  queue = collections.deque([(start_pos, start_dir, [])])\n  \n  # The 'visited' set stores (position, direction) tuples to avoid cycles and\n  # redundant computations. This is crucial for finding the shortest path in\n  # state space, not just grid space.\n  visited = set([(start_pos, start_dir)])\n\n  grid_width, grid_height = grid.shape[0], grid.shape[1]\n  non_grabbable_indices = world.non_grabbable_indices\n\n  # --- Breadth-First Search Loop ---\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # --- GOAL CHECK ---\n    # The goal is reached if the cell directly in front of the agent\n    # contains the target primitive.\n\n    # The direction integer corresponds to the action that moves that way.\n    if direction in ACTION_VECTORS:\n      dir_vector = ACTION_VECTORS[direction]\n      front_pos = (pos[0] + dir_vector[0], pos[1] + dir_vector[1])\n\n      # Check if the cell in front is within the grid boundaries.\n      if 0 <= front_pos[0] < grid_width and 0 <= front_pos[1] < grid_height:\n        # Check for the primitive.\n        if grid[front_pos[0], front_pos[1], primitive_index] > 0:\n          # Success! Return the path of moves followed by the USE action.\n          return path + [craft.USE]\n\n    # --- EXPLORE NEIGHBORS (Generate next possible states) ---\n    # Iterate through all four possible move actions from the current state.\n    for action, move_vector in ACTION_VECTORS.items():\n      next_pos = (pos[0] + move_vector[0], pos[1] + move_vector[1])\n      # The agent's new direction is determined by the move it just made.\n      next_dir = action\n\n      # --- VALIDITY CHECKS for the new state (next_pos, next_dir) ---\n      \n      # 1. Have we already visited this state?\n      if (next_pos, next_dir) in visited:\n        continue\n\n      # 2. Is the new position within the grid boundaries?\n      if not (0 <= next_pos[0] < grid_width and 0 <= next_pos[1] < grid_height):\n        continue\n\n      # 3. Is the new position blocked by a non-grabbable obstacle?\n      is_blocked = False\n      for idx in non_grabbable_indices:\n        if grid[next_pos[0], next_pos[1], idx] > 0:\n          is_blocked = True\n          break\n      if is_blocked:\n        continue\n      \n      # If the new state is valid and unvisited, add it to the queue and visited set.\n      visited.add((next_pos, next_dir))\n      queue.append((next_pos, next_dir, path + [action]))\n\n  # If the queue is exhausted and the goal was not reached, no path exists.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a cell adjacent to the target primitive. The BFS state includes both\n  the agent's position and its direction to ensure correct orientation for\n  the final 'USE' action.\n\n  Args:\n    env: The environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the optimal plan, or an empty\n    list if the primitive is unreachable.\n  \"\"\"\n  # Get the current state from the environment wrapper.\n  current_state = env._current_state\n\n  # --- 1. Setup: Define actions and environment parameters ---\n  # These action constants are assumed to be defined in the craft module.\n  actions = {\n      craft.UP: {'vec': (0, -1), 'dir': 0},\n      craft.DOWN: {'vec': (0, 1), 'dir': 1},\n      craft.LEFT: {'vec': (-1, 0), 'dir': 2},\n      craft.RIGHT: {'vec': (1, 0), 'dir': 3},\n  }\n\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  world = current_state.world\n  width, height, _ = grid.shape\n\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    return [] # The primitive name does not exist in the cookbook.\n\n  # --- 2. Identify all valid target states ---\n  # A target state is a tuple of ((position), direction) where the agent is\n  # adjacent to the primitive and facing it.\n  target_states = set()\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  if primitive_locations.size == 0:\n    return []  # Primitive is not present on the map.\n\n  for p_pos in primitive_locations:\n    px, py = p_pos[0], p_pos[1]\n    \n    # Check the 4 adjacent cells for valid interaction points.\n    for action, effects in actions.items():\n      dx, dy = effects['vec']\n      # The adjacent cell from which to interact.\n      adj_x, adj_y = px - dx, py - dy\n      \n      if 0 <= adj_x < width and 0 <= adj_y < height:\n        # A cell is a valid target if it's not blocked by a non-grabbable entity.\n        is_blocked = any(grid[adj_x, adj_y, i] > 0 for i in world.non_grabbable_indices)\n        if not is_blocked:\n          # The required direction is the one that faces the primitive.\n          required_dir = effects['dir']\n          target_states.add(((adj_x, adj_y), required_dir))\n\n  if not target_states:\n    return [] # No accessible cells next to the primitive.\n\n  # --- 3. Find the shortest path using a directional BFS ---\n  # The queue stores tuples of: (current_position, current_direction, path_so_far).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores tuples of (position, direction) to avoid cycles.\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    current_pos, current_dir, path = queue.popleft()\n\n    # Check if the current state is one of our goal states.\n    if (current_pos, current_dir) in target_states:\n      return path + [craft.USE]\n\n    # Explore all possible moves from the current state.\n    for action, effects in actions.items():\n      dx, dy = effects['vec']\n      next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n      next_dir = effects['dir']\n      \n      if ((next_pos), next_dir) in visited:\n        continue\n\n      # Check if the move is within grid bounds.\n      if 0 <= next_pos[0] < width and 0 <= next_pos[1] < height:\n        # Check if the destination cell is blocked.\n        is_blocked = any(grid[next_pos[0], next_pos[1], i] > 0 for i in world.non_grabbable_indices)\n        if not is_blocked:\n          visited.add((next_pos, next_dir))\n          new_path = path + [action]\n          queue.append((next_pos, next_dir, new_path))\n  \n  # --- 4. No Path Found ---\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  The function works in three main steps:\n  1.  Identify all valid target locations on the grid. A target is a walkable,\n      empty cell immediately adjacent to the desired primitive.\n  2.  Use a Breadth-First Search (BFS) algorithm to find the shortest path of\n      movement actions from the agent's current position to one of the identified\n      target locations.\n  3.  Once a path is found, calculate the necessary turning actions to ensure\n      the agent is facing the primitive. Append these turns and the final\n      'USE' action to the movement path.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  WIDTH, HEIGHT = grid.shape[:2]\n\n  # --- Mappings for navigation and orientation ---\n  # Assumed mapping from agent direction integer to grid delta (row, col)\n  # 0: UP, 1: RIGHT, 2: DOWN, 3: LEFT\n  dir_to_delta = {0: (-1, 0), 1: (0, 1), 2: (1, 0), 3: (0, -1)}\n  delta_to_dir = {v: k for k, v in dir_to_delta.items()}\n  \n  # Mapping from action constants to grid deltas\n  action_to_delta = {\n      craft.UP: (-1, 0),\n      craft.DOWN: (1, 0),\n      craft.LEFT: (0, -1),\n      craft.RIGHT: (0, 1),\n  }\n  # Mapping from action constants to agent direction integers\n  action_to_dir = {\n      craft.UP: 0,\n      craft.RIGHT: 1,\n      craft.DOWN: 2,\n      craft.LEFT: 3,\n  }\n  \n  # --- Helper Functions ---\n  non_grabbable_indices = current_state.world.non_grabbable_indices\n  def is_walkable(pos):\n    \"\"\"Check if a grid cell is within bounds and not blocked.\"\"\"\n    x, y = pos\n    if not (0 <= x < WIDTH and 0 <= y < HEIGHT):\n      return False\n    # A cell is walkable if it contains no non-grabbable entities.\n    for i_kind in non_grabbable_indices:\n      if grid[x, y, i_kind] > 0:\n        return False\n    return True\n\n  # 1. Find all reachable cells adjacent to the primitive\n  try:\n    primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n    return [] # Primitive name is not valid\n\n  targets = {}  # Maps a reachable adjacent cell to the primitive's cell\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  \n  if primitive_locations.shape[0] == 0:\n    return []  # Primitive does not exist on the map\n\n  for prim_pos_arr in primitive_locations:\n    px, py = tuple(prim_pos_arr)\n    for delta in action_to_delta.values():\n      adj_pos = (px + delta[0], py + delta[1])\n      if is_walkable(adj_pos):\n        targets[adj_pos] = (px, py)\n\n  if not targets:\n    return []  # Primitive is inaccessible\n\n  # 2. BFS to find the shortest path to an adjacent cell\n  queue = collections.deque([(start_pos, [])])  # (current_pos, path_of_actions)\n  visited = {start_pos}\n\n  while queue:\n    pos, path = queue.popleft()\n\n    if pos in targets:\n      # Found a path to a cell next to the primitive. Now, plan final turns and use.\n      final_actions = list(path)\n      primitive_pos = targets[pos]\n\n      # Determine agent's direction after last move.\n      if not path:\n        # Agent starts next to the target, use initial direction.\n        current_dir = start_dir\n      else:\n        last_move_action = path[-1]\n        current_dir = action_to_dir[last_move_action]\n      \n      # Determine target direction to face the primitive.\n      dx = primitive_pos[0] - pos[0]\n      dy = primitive_pos[1] - pos[1]\n      target_dir = delta_to_dir[(dx, dy)]\n\n      # Add turning actions to align the agent.\n      # The number of right turns needed is (target - current + 4) % 4\n      turn_diff = (target_dir - current_dir + 4) % 4\n      if turn_diff == 1:\n        final_actions.append(craft.RIGHT)\n      elif turn_diff == 2:\n        final_actions.extend([craft.RIGHT, craft.RIGHT])\n      elif turn_diff == 3:\n        final_actions.append(craft.LEFT)\n      \n      # Add the final collection action.\n      final_actions.append(craft.USE)\n      return final_actions\n\n    # Expand search to neighbors.\n    for action, delta in action_to_delta.items():\n      next_pos = (pos[0] + delta[0], pos[1] + delta[1])\n      if next_pos not in visited and is_walkable(next_pos):\n        visited.add(next_pos)\n        queue.append((next_pos, path + [action]))\n        \n  return [] # No path found\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a primitive.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    path from the agent's current position to a location where it can collect\n    the specified primitive. It addresses key challenges identified from\n    previous attempts:\n    1.  **Correct Pathing Target:** The agent cannot occupy a cell with a resource.\n        The goal is to be adjacent to the resource and facing it. This is solved\n        by making the goal condition of the search \"is the agent facing the primitive?\".\n    2.  **Directional Actions:** The 'USE' action is directional. The BFS state\n        is augmented to include the agent's orientation `(position, direction)`\n        to ensure it is facing the primitive before attempting collection.\n    3.  **Obstacle Avoidance:** The agent can only move into empty cells. Any\n        cell containing an item, resource, or terrain is treated as an impassable\n        obstacle, which is checked via `grid[pos].sum() > 0`.\n\n    Args:\n        env (CraftLab): The environment instance.\n        primitive (str): The name of the primitive to collect (e.g., \"WOOD\").\n\n    Returns:\n        list[int]: A list of action integers representing the shortest plan\n                   to collect the primitive. Returns an empty list if the\n                   primitive is not on the map or is unreachable.\n    \"\"\"\n    current_state = env._current_state\n    grid = current_state.grid\n    start_pos = current_state.pos\n    start_dir = current_state.dir\n    world = current_state.world\n    grid_width, grid_height, _ = grid.shape\n\n    # 1. Get the integer index for the primitive from the cookbook.\n    try:\n        primitive_index = world.cookbook.index[primitive]\n    except KeyError:\n        return []  # Primitive name not found in the world's recipes.\n\n    # 2. Define mappings for actions, directions, and grid movements.\n    #    This assumes a standard mapping between action constants, grid deltas,\n    #    and the agent's resulting direction state.\n    #    Actions: As defined in the craft module (e.g., craft.UP, craft.DOWN)\n    #    Directions: 0:UP (+y), 1:RIGHT (+x), 2:DOWN (-y), 3:LEFT (-x)\n    ACTION_TO_DELTA = {\n        craft.UP: (0, 1),\n        craft.DOWN: (0, -1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n    # Moving in a direction sets the agent's new direction to match.\n    ACTION_TO_DIR = {\n        craft.UP: 0,\n        craft.RIGHT: 1,\n        craft.DOWN: 2,\n        craft.LEFT: 3,\n    }\n    # Delta for the cell the agent is currently facing.\n    FACING_DELTA = {\n        0: (0, 1),   # Facing UP\n        1: (1, 0),   # Facing RIGHT\n        2: (0, -1),  # Facing DOWN\n        3: (-1, 0),  # Facing LEFT\n    }\n\n    # 3. Find all locations of the target primitive on the grid.\n    primitive_coords = np.argwhere(grid[:, :, primitive_index] > 0)\n    if primitive_coords.size == 0:\n        return []  # Primitive not found on the map.\n    # Convert to a set of tuples for efficient O(1) lookups.\n    primitive_locations = set(map(tuple, primitive_coords))\n\n    # 4. Perform Breadth-First Search (BFS) to find the shortest path.\n    # The state in the queue is (position, direction, path_of_actions).\n    queue = collections.deque([(start_pos, start_dir, [])])\n    # The visited set must track both position and direction to avoid cycles.\n    visited = {(start_pos, start_dir)}\n\n    while queue:\n        pos, current_dir, path = queue.popleft()\n\n        # Check for goal condition: Is the agent facing a primitive?\n        dx, dy = FACING_DELTA[current_dir]\n        front_pos = (pos[0] + dx, pos[1] + dy)\n\n        if front_pos in primitive_locations:\n            # Success! Return the path plus the final USE action.\n            return path + [craft.USE]\n\n        # Explore neighbors by trying all possible move actions.\n        for action, (dx, dy) in ACTION_TO_DELTA.items():\n            new_pos = (pos[0] + dx, pos[1] + dy)\n            \n            # Check if the new position is valid and traversable.\n            if not (0 <= new_pos[0] < grid_width and 0 <= new_pos[1] < grid_height):\n                continue  # Out of bounds.\n\n            # Agent can only move into empty cells. A cell is non-empty if its\n            # feature vector sum is greater than 0.\n            if grid[new_pos].sum() > 0:\n                continue  # Cell is blocked.\n\n            # The agent's new direction is determined by the last move action.\n            new_dir = ACTION_TO_DIR[action]\n\n            if (new_pos, new_dir) not in visited:\n                visited.add((new_pos, new_dir))\n                new_path = path + [action]\n                queue.append((new_pos, new_dir, new_path))\n\n    # If the queue empties, the primitive is unreachable.\n    return []\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a location adjacent to the target primitive, with the correct\n  orientation to collect it.\n\n  The state in the BFS is represented by (position, direction, path_of_actions).\n  The search space includes the agent's direction because the 'USE' action is\n  directional, and turning requires a movement action.\n\n  Args:\n      env (CraftLab): The environment instance.\n      primitive (str): The name of the primitive to collect.\n\n  Returns:\n      list[int]: A list of action constants (e.g., craft.UP, craft.USE)\n                  representing the plan. Returns an empty list if no path is found.\n  \"\"\"\n  # 1. Initialization and Setup from the environment state\n  current_state = env._current_state\n  grid = current_state.grid\n  world = current_state.world\n  cookbook = world.cookbook\n\n  width, height, _ = grid.shape\n  try:\n    primitive_idx = cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the game's recipes.\n    return []\n\n  # Define action mappings based on craft's constants.\n  # craft.DOWN=0, craft.UP=1, craft.LEFT=2, craft.RIGHT=3\n  # This maps each movement action to its corresponding (dx, dy) vector.\n  ACTION_VECTORS = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  \n  # 2. Define a helper function to check if a grid cell is passable\n  non_grabbable_list = list(world.non_grabbable_indices)\n  def is_passable(pos):\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is not passable if it contains any non-grabbable entity (e.g., water, stone).\n    if np.any(grid[x, y, non_grabbable_list]):\n      return False\n    return True\n\n  # 3. Identify all valid target states for the BFS.\n  # A target state is a (position, direction) tuple where the agent is\n  # adjacent to the primitive and facing it.\n  target_states = set()\n  primitive_locations = np.argwhere(grid[:, :, primitive_idx] > 0)\n\n  if primitive_locations.shape[0] == 0:\n    return [] # Primitive does not exist on the map.\n\n  for loc in primitive_locations:\n    px, py = loc[0], loc[1]\n    \n    # Check all 4 adjacent cells to see if they are valid spots from which to collect.\n    for action, (dx, dy) in ACTION_VECTORS.items():\n      # The agent's position (ax, ay) must be adjacent to the primitive at (px, py).\n      agent_pos = (px - dx, py - dy)\n      \n      # The agent must face the primitive. The direction is the same as the action\n      # that would move the agent from its position onto the primitive's cell.\n      agent_dir = action\n      \n      # The state is valid only if the agent's target position is passable.\n      if is_passable(agent_pos):\n        target_states.add((agent_pos, agent_dir))\n            \n  if not target_states:\n    return [] # No accessible locations to collect the primitive from.\n\n  # 4. BFS Setup\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  \n  # The queue stores tuples of (position, direction, current_path).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid cycles.\n  visited = {(start_pos, start_dir)}\n\n  # 5. BFS Loop\n  while queue:\n    (x, y), direction, path = queue.popleft()\n\n    # Goal check: If the current state is a valid target state, we've found a path.\n    if ((x, y), direction) in target_states:\n      return path + [craft.USE]\n\n    # Explore neighbors by trying all four movement actions.\n    for action, (dx, dy) in ACTION_VECTORS.items():\n      new_pos = (x + dx, y + dy)\n      # The agent's new direction is determined by the last movement action.\n      new_dir = action\n      \n      if is_passable(new_pos) and (new_pos, new_dir) not in visited:\n        visited.add((new_pos, new_dir))\n        new_path = path + [action]\n        queue.append((new_pos, new_dir, new_path))\n  \n  # 6. No Path Found\n  # This is reached if the queue is exhausted and no target state was found.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to an empty cell adjacent to the target primitive. It then adds the\n  necessary actions to turn towards the primitive and collect it.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the plan, or an empty list if\n    the primitive cannot be collected.\n  \"\"\"\n  # Action constants are assumed to be defined in the craft module\n  # craft.UP=0, craft.DOWN=1, craft.LEFT=2, craft.RIGHT=3, craft.USE=4\n  # Agent direction `dir` is assumed to use the same encoding.\n  action_to_vector = {\n      craft.UP: (0, -1),\n      craft.DOWN: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  vector_to_action = {v: k for k, v in action_to_vector.items()}\n\n  # 1. Get current state information from the environment\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  world = current_state.world\n  width, height, _ = grid.shape\n  non_grabbable_indices = world.non_grabbable_indices\n\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    return []  # Primitive name is not valid\n\n  # 2. Identify all valid target cells for pathfinding.\n  # A target cell is an empty, passable cell adjacent to the primitive.\n  target_adjacent_cells = set()\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  if primitive_locations.shape[0] == 0:\n    return []  # Primitive does not exist on the map\n\n  for prim_pos in primitive_locations:\n    px, py = prim_pos[0], prim_pos[1]\n    for dx, dy in action_to_vector.values():\n      ax, ay = px + dx, py + dy\n\n      # Check if the adjacent cell is within bounds\n      if not (0 <= ax < width and 0 <= ay < height):\n        continue\n\n      # A cell is a valid target if it's completely empty.\n      # An empty cell has a sum of 0 across the 'kinds' axis.\n      if grid[ax, ay, :].sum() == 0:\n        target_adjacent_cells.add((ax, ay))\n\n  if not target_adjacent_cells:\n    return [] # No empty cells next to the primitive\n\n  # 3. Find the shortest path using Breadth-First Search (BFS)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n  shortest_path = None\n\n  # Handle the edge case where the agent starts at a target cell\n  if start_pos in target_adjacent_cells:\n    shortest_path = []\n\n  while queue and shortest_path is None:\n    (cx, cy), path = queue.popleft()\n\n    for action, (dx, dy) in action_to_vector.items():\n      nx, ny = cx + dx, cy + dy\n\n      if not (0 <= nx < width and 0 <= ny < height) or (nx, ny) in visited:\n        continue\n\n      # Agent can only move through completely empty cells\n      if grid[nx, ny, :].sum() > 0:\n        continue\n\n      visited.add((nx, ny))\n      new_path = path + [action]\n\n      if (nx, ny) in target_adjacent_cells:\n        shortest_path = new_path\n        break # Found the shortest path to an adjacent cell\n    \n  if shortest_path is None:\n    return []  # No path could be found\n\n  # 4. Determine final position and required orientation\n  final_pos = start_pos\n  for action in shortest_path:\n    dx, dy = action_to_vector[action]\n    final_pos = (final_pos[0] + dx, final_pos[1] + dy)\n\n  # Find the specific primitive location we are now next to\n  primitive_to_collect_pos = None\n  for dx, dy in action_to_vector.values():\n    check_pos = (final_pos[0] + dx, final_pos[1] + dy)\n    if (0 <= check_pos[0] < width and 0 <= check_pos[1] < height and\n        grid[check_pos[0], check_pos[1], primitive_index] > 0):\n      primitive_to_collect_pos = check_pos\n      break\n\n  if primitive_to_collect_pos is None:\n      # This case should ideally not be reached if logic is sound\n      return []\n\n  # Calculate the action needed to face the primitive\n  final_dx = primitive_to_collect_pos[0] - final_pos[0]\n  final_dy = primitive_to_collect_pos[1] - final_pos[1]\n  orient_action = vector_to_action[(final_dx, final_dy)]\n\n  # 5. Construct the final action sequence\n  current_dir_action = None\n  if not shortest_path: # Agent started adjacent to the primitive\n      # Assuming dir encoding matches action encoding (e.g., UP is 0 for both)\n      current_dir_action = current_state.dir\n  else: # Agent had to move, last move determines direction\n      current_dir_action = shortest_path[-1]\n\n  # If not already facing the correct direction, add an action to turn.\n  # We assume attempting to move into the blocked primitive cell will change\n  # the agent's direction without changing its position.\n  if current_dir_action != orient_action:\n    shortest_path.append(orient_action)\n  \n  # The final action is to use/collect the primitive\n  shortest_path.append(craft.USE)\n\n  return shortest_path\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function correctly solves the pathfinding problem by:\n  1. Identifying all empty, accessible cells adjacent to the target primitive.\n  2. Using Breadth-First Search (BFS) to find the shortest path to one of these\n     adjacent cells.\n  3. Treating any non-empty cell as an impassable obstacle, as per the\n     environment rules.\n  4. Appending the necessary actions to orient the agent towards the primitive\n     before issuing the final 'USE' command to collect it.\n\n  Args:\n    env: The simulation environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the plan, or an empty list if\n    the primitive is unreachable.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  width, height, _ = grid.shape\n\n  try:\n    primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the world's recipes.\n    return []\n\n  # Define movement actions and their corresponding (dx, dy) changes.\n  # This assumes a standard grid where y increases downwards (row index).\n  DIR_TO_ACTION = {\n      (0, -1): craft.UP,    # Move up one row\n      (0, 1):  craft.DOWN,  # Move down one row\n      (1, 0):  craft.RIGHT, # Move right one column\n      (-1, 0): craft.LEFT,  # Move left one column\n  }\n\n  # --- Step 1: Find all valid target positions ---\n  # A valid target is an empty cell adjacent to the primitive.\n  goal_positions = set()\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  if primitive_locations.shape[0] == 0:\n    return [] # Primitive not found on the map.\n\n  for prim_x, prim_y in primitive_locations:\n    for dx, dy in DIR_TO_ACTION.keys():\n      adj_x, adj_y = prim_x + dx, prim_y + dy\n\n      # Check if adjacent cell is within bounds\n      if 0 <= adj_x < width and 0 <= adj_y < height:\n        # A goal position must be empty for the agent to stand on it.\n        # Per the rules, any non-empty cell is blocked.\n        if grid[adj_x, adj_y].sum() == 0:\n          goal_positions.add((adj_x, adj_y))\n\n  if not goal_positions:\n    return [] # Primitive is inaccessible (e.g., completely surrounded).\n\n  # --- Step 2: Pathfinding using Breadth-First Search ---\n  # The state in the queue is (position, path_of_actions).\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n  \n  path_to_adjacent = None\n  final_pos = None\n\n  # Handle the case where the agent starts next to the primitive.\n  if start_pos in goal_positions:\n    path_to_adjacent = []\n    final_pos = start_pos\n  else:\n    while queue:\n      (x, y), path = queue.popleft()\n\n      for (dx, dy), action in DIR_TO_ACTION.items():\n        nx, ny = x + dx, y + dy\n\n        if not (0 <= nx < width and 0 <= ny < height) or (nx, ny) in visited:\n          continue\n\n        # Check if we have arrived at a valid standing position.\n        if (nx, ny) in goal_positions:\n          path_to_adjacent = path + [action]\n          final_pos = (nx, ny)\n          queue.clear() # Found shortest path, stop searching.\n          break\n        \n        # A cell is traversable only if it is completely empty.\n        if grid[nx, ny].sum() == 0:\n          visited.add((nx, ny))\n          queue.append(((nx, ny), path + [action]))\n      \n      if final_pos: # Break from outer while loop\n          break\n\n  if path_to_adjacent is None:\n    return [] # No path found.\n\n  # --- Step 3: Determine final orientation and USE action ---\n  # Find which specific primitive we pathed to.\n  target_primitive_pos = None\n  for prim_x, prim_y in primitive_locations:\n    # Check for adjacency (Manhattan distance of 1).\n    if abs(final_pos[0] - prim_x) + abs(final_pos[1] - prim_y) == 1:\n      target_primitive_pos = (prim_x, prim_y)\n      break\n  \n  if target_primitive_pos is None:\n    return [] # Should not be reached if path was found.\n\n  # Determine the direction from the agent's final position to the primitive.\n  face_dx = target_primitive_pos[0] - final_pos[0]\n  face_dy = target_primitive_pos[1] - final_pos[1]\n  \n  # Get the corresponding move action to face that direction.\n  face_action = DIR_TO_ACTION.get((face_dx, face_dy))\n  \n  if face_action is None:\n    return [] # Should be unreachable.\n\n  # The final plan: move to the adjacent cell, turn to face the primitive, then use.\n  # The \"turn\" is a move action that updates direction even if movement is blocked.\n  final_actions = path_to_adjacent + [face_action, craft.USE]\n  \n  return final_actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move adjacent to, face, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest path\n  to a state where the agent is positioned next to the target primitive and is\n  facing it. This approach correctly handles the directional nature of the 'USE' action\n  and avoids pathing into blocked cells by checking against the world's non-grabbable entities.\n\n  Args:\n      env: The environment instance, providing access to the current state.\n      primitive: The string name of the primitive to collect.\n\n  Returns:\n      A list of action integers representing the optimal plan, or an empty list\n      if the primitive is unreachable.\n  \"\"\"\n  # 1. Initialization and State Extraction from the environment\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos  # Format: (x, y)\n  start_dir = current_state.dir\n  \n  world = current_state.world\n  primitive_idx = world.cookbook.index[primitive]\n  non_grabbable_indices = world.non_grabbable_indices\n  \n  height, width = grid.shape[0], grid.shape[1]\n\n  # Define the effect of each movement action.\n  # Format: action_code -> (dx, dy, resulting_direction_code)\n  # Directions are coded as: 0=DOWN(S), 1=UP(N), 2=LEFT(W), 3=RIGHT(E)\n  moves = {\n      craft.UP:    (0, -1, 1),\n      craft.DOWN:  (0,  1, 0),\n      craft.LEFT:  (-1, 0, 2),\n      craft.RIGHT: (1,  0, 3),\n  }\n\n  # 2. BFS Setup\n  # The state in the queue includes position, direction, and the path taken.\n  # This is crucial for handling the directional 'USE' action correctly.\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set tracks both position and direction to find the shortest\n  # path to a cell *with a specific orientation*.\n  visited = {(start_pos, start_dir)}\n\n  # 3. Main BFS Loop\n  while queue:\n      (pos_x, pos_y), direction, path = queue.popleft()\n\n      # 4. Goal Condition Check\n      # Determine the coordinates of the cell the agent is currently facing.\n      facing_dx, facing_dy = 0, 0\n      if direction == 0: facing_dy = 1   # Facing Down\n      elif direction == 1: facing_dy = -1  # Facing Up\n      elif direction == 2: facing_dx = -1  # Facing Left\n      elif direction == 3: facing_dx = 1   # Facing Right\n      \n      facing_x, facing_y = pos_x + facing_dx, pos_y + facing_dy\n\n      # Check if the cell being faced is within bounds and contains the target primitive.\n      if 0 <= facing_x < width and 0 <= facing_y < height:\n          # Grid access uses (row, col), which corresponds to (y, x).\n          if grid[facing_y, facing_x, primitive_idx] > 0:\n              # Success! The plan is complete. Append the USE action.\n              return path + [craft.USE]\n\n      # 5. Expand Search to Neighboring States\n      for action, (dx, dy, new_dir) in moves.items():\n          next_x, next_y = pos_x + dx, pos_y + dy\n          next_pos = (next_x, next_y)\n          \n          new_state_key = (next_pos, new_dir)\n          if new_state_key in visited:\n              continue\n\n          # Check if the next position is within the grid boundaries.\n          if 0 <= next_x < width and 0 <= next_y < height:\n              # Check if the target cell is walkable (i.e., not blocked by\n              # any non-grabbable entity like water, stone, etc.).\n              is_blocked = any(grid[next_y, next_x, idx] > 0 for idx in non_grabbable_indices)\n              \n              if not is_blocked:\n                  # If the move is valid, mark the new state as visited and add it to the queue.\n                  visited.add(new_state_key)\n                  new_path = path + [action]\n                  queue.append((next_pos, new_dir, new_path))\n                  \n  # 6. No Path Found\n  # If the queue is exhausted and the goal was not reached, no path exists.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, approach, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a state (position and direction) from which the specified primitive\n  can be collected.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers (e.g., [craft.RIGHT, craft.UP, craft.USE])\n    representing the plan to collect the primitive. Returns an empty list\n    if the primitive is unreachable.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  world = current_state.world\n  \n  try:\n    primitive_idx = world.cookbook.index[primitive]\n  except KeyError:\n    # The primitive name is not in the cookbook\n    return []\n\n  # Grid dimensions (Note: grid shape is H, W, C)\n  height, width = grid.shape[0], grid.shape[1]\n\n  # Agent actions and their corresponding effects on position (dx, dy)\n  # The action constant (e.g., craft.UP) also serves as the new direction index.\n  # craft.UP=0, craft.DOWN=1, craft.LEFT=2, craft.RIGHT=3\n  moves = [\n      (craft.UP, (0, -1)),\n      (craft.DOWN, (0, 1)),\n      (craft.LEFT, (-1, 0)),\n      (craft.RIGHT, (1, 0)),\n  ]\n  \n  # The deltas corresponding to directions 0, 1, 2, 3\n  direction_deltas = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n  # BFS queue stores tuples of (position, direction, path_of_actions)\n  queue = collections.deque([(start_pos, start_dir, [])])\n  \n  # Visited set stores (position, direction) tuples to avoid cycles\n  visited = {(start_pos, start_dir)}\n\n  while queue:\n    pos, direction, path = queue.popleft()\n    x, y = pos\n\n    # Check if the agent can collect from the current state (pos, direction)\n    dx, dy = direction_deltas[direction]\n    facing_pos = (x + dx, y + dy)\n    \n    if 0 <= facing_pos[0] < width and 0 <= facing_pos[1] < height:\n      # Check if the cell the agent is facing contains the target primitive\n      if grid[facing_pos[1], facing_pos[0], primitive_idx] > 0:\n        # Found a valid state. Return the path plus the USE action.\n        return path + [craft.USE]\n\n    # If no collection is possible, explore next possible moves\n    for action, (dx, dy) in moves:\n      next_pos = (x + dx, y + dy)\n      next_dir = action  # A move action sets the new direction\n\n      # Check if the new state has already been visited\n      if (next_pos, next_dir) in visited:\n        continue\n      \n      nx, ny = next_pos\n      \n      # Check if the next position is within the grid bounds\n      if not (0 <= nx < width and 0 <= ny < height):\n        continue\n\n      # The agent can only move into empty cells. Any non-empty cell is blocked.\n      if grid[ny, nx].any():\n        continue\n      \n      # If the move is valid, add the new state to the queue and visited set\n      visited.add((next_pos, next_dir))\n      new_path = path + [action]\n      queue.append((next_pos, next_dir, new_path))\n      \n  # If the queue is exhausted and no path was found, the primitive is unreachable\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Finds the shortest path to a primitive, navigates to a cell adjacent to it,\n  faces it, and collects it.\n\n  This function implements a Breadth-First Search (BFS) to find the optimal\n  sequence of actions. The state in the BFS is represented by (position, direction),\n  ensuring that the agent is correctly oriented before attempting to collect.\n\n  Args:\n      env: The environment object, providing access to the current state.\n      primitive: The string name of the primitive to collect.\n\n  Returns:\n      A list of actions (integers) to collect the primitive, or an empty\n      list if it's not possible.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  width, height, _ = grid.shape\n  non_grabbable_indices = current_state.world.non_grabbable_indices\n\n  try:\n    primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive doesn't exist in the cookbook.\n    return []\n\n  # Mappings to translate between agent direction and position deltas (dx, dy).\n  # Based on environment conventions: DOWN=0, UP=1, LEFT=2, RIGHT=3\n  DIR_TO_DELTA = {\n      0: (0, 1),   # DOWN\n      1: (0, -1),  # UP\n      2: (-1, 0),  # LEFT\n      3: (1, 0),   # RIGHT\n  }\n  \n  # Mapping from a move action to the direction it sets.\n  ACTION_TO_DIR = {\n      craft.DOWN: 0,\n      craft.UP: 1,\n      craft.LEFT: 2,\n      craft.RIGHT: 3,\n  }\n\n  # The BFS queue stores tuples of (position, direction, path_of_actions).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) to avoid redundant exploration.\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # GOAL CHECK: Is the agent currently facing the target primitive?\n    # If so, the path is complete, and we just need to add the USE action.\n    if direction in DIR_TO_DELTA:\n      delta = DIR_TO_DELTA[direction]\n      facing_pos = (pos[0] + delta[0], pos[1] + delta[1])\n\n      # Check if the facing position is within bounds and contains the primitive.\n      if (0 <= facing_pos[0] < width and 0 <= facing_pos[1] < height and\n          grid[facing_pos[0], facing_pos[1], primitive_index] > 0):\n        return path + [craft.USE]\n\n    # EXPLORATION: Generate next possible states by taking each move action.\n    for action, next_dir in ACTION_TO_DIR.items():\n      # A move action determines both the next position and the next direction.\n      delta = DIR_TO_DELTA[next_dir]\n      next_pos = (pos[0] + delta[0], pos[1] + delta[1])\n\n      # Check if the move is valid.\n      # 1. Is it within the grid boundaries?\n      if not (0 <= next_pos[0] < width and 0 <= next_pos[1] < height):\n        continue\n\n      # 2. Is the cell blocked by a non-grabbable object (e.g., stone, water)?\n      is_blocked = any(grid[next_pos[0], next_pos[1], idx] > 0 for idx in non_grabbable_indices)\n      if is_blocked:\n        continue\n\n      # 3. Have we been in this state (position, direction) before?\n      if (next_pos, next_dir) not in visited:\n        visited.add((next_pos, next_dir))\n        new_path = path + [action]\n        queue.append((next_pos, next_dir, new_path))\n\n  # If the queue becomes empty, no path to the primitive was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a location adjacent to the target primitive, while also ensuring\n  the agent is facing the primitive before collecting.\n\n  The state in the BFS queue includes the agent's position, direction, and the\n  path taken so far. This ensures that the orientation is correctly handled.\n\n  Args:\n      env: The environment instance, providing access to the current state.\n      primitive (str): The name of the primitive to collect.\n\n  Returns:\n      list: A list of action constants (e.g., [craft.UP, craft.RIGHT, craft.USE])\n            representing the plan. Returns an empty list if the primitive is\n            unreachable or does not exist.\n  \"\"\"\n  # 1. SETUP: Get current state and define mappings\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  height, width, _ = grid.shape\n\n  try:\n    primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n    return []  # Primitive name not found in cookbook\n\n  # Define mappings based on common grid-world conventions.\n  # Assumes craft action constants correspond to movement directions.\n  # pos is (x, y), grid is indexed grid[y, x]. vec is (dx, dy).\n  action_to_vec = {\n      craft.RIGHT: (1, 0),\n      craft.DOWN: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.UP: (0, -1),\n  }\n\n  # Assumed mapping from action to the resulting agent direction index.\n  # This mapping is crucial and assumes a standard: 0:RIGHT, 1:DOWN, 2:LEFT, 3:UP\n  action_to_dir = {\n      craft.RIGHT: 0,\n      craft.DOWN: 1,\n      craft.LEFT: 2,\n      craft.UP: 3,\n  }\n\n  # 2. IDENTIFY TARGETS\n  # A target is a state (position, direction) where the agent is adjacent\n  # to the primitive and facing it.\n  targets = set()\n  for y in range(height):\n    for x in range(width):\n      # Check if the cell contains the primitive\n      if grid[y, x, primitive_index] > 0:\n        primitive_pos = (x, y)\n        # For each adjacent cell, determine if it's a valid target spot\n        for action, (dx, dy) in action_to_vec.items():\n          # The position the agent needs to be at\n          adj_pos = (primitive_pos[0] - dx, primitive_pos[1] - dy)\n          adj_x, adj_y = adj_pos\n\n          # Check if the adjacent cell is a valid standing spot (in bounds and empty)\n          if 0 <= adj_x < width and 0 <= adj_y < height and grid[adj_y, adj_x].sum() == 0:\n            # The direction required to face the primitive from the adjacent spot\n            required_dir = action_to_dir[action]\n            targets.add((adj_pos, required_dir))\n\n  if not targets:\n    return []  # No accessible locations next to the primitive\n\n  # 3. BREADTH-FIRST SEARCH\n  # The queue stores tuples of (current_position, current_direction, path_taken)\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid redundant searches\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # Goal check: Is the current state a valid target state?\n    if (pos, direction) in targets:\n      return path + [craft.USE]\n\n    # Explore neighbors by trying all 4 move actions\n    for action, move_vec in action_to_vec.items():\n      new_pos = (pos[0] + move_vec[0], pos[1] + move_vec[1])\n      new_dir = action_to_dir[action]\n\n      # Check if the new state is valid and has not been visited\n      if (new_pos, new_dir) not in visited:\n        nx, ny = new_pos\n        # Check if the new position is within bounds\n        if 0 <= nx < width and 0 <= ny < height:\n          # The agent can only move to completely empty cells.\n          if grid[ny, nx].sum() == 0:\n            visited.add((new_pos, new_dir))\n            new_path = path + [action]\n            queue.append((new_pos, new_dir, new_path))\n\n  # If the queue becomes empty, no path was found\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path from the agent's current position to a location where it is adjacent\n  to and facing the target primitive. The state space for the search includes\n  both the agent's position and its direction, as both are required to\n  correctly use the 'collect' action.\n\n  Args:\n    env: The simulation environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD', 'IRON').\n\n  Returns:\n    A list of action integers representing the shortest plan to collect the\n    primitive. Returns an empty list if the primitive is not found or is\n    unreachable.\n  \"\"\"\n  # 1. Initialization and Setup\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  world = current_state.world\n  width, height, _ = grid.shape\n\n  primitive_index = world.cookbook.index[primitive]\n  if primitive_index is None:\n      return []  # Primitive name is not valid\n\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  if not primitive_locations.size:\n      return []  # Primitive does not exist on the map\n  \n  # np.argwhere returns coordinates as (row, col), which maps to (x, y)\n  # for a grid of shape (WIDTH, HEIGHT, ...).\n  primitive_locations_set = {tuple(loc) for loc in primitive_locations}\n\n  # Action constants and their corresponding (dx, dy) movement vectors.\n  # Assumes craft.DOWN=0, craft.UP=1, craft.LEFT=2, craft.RIGHT=3.\n  ACTIONS = [craft.DOWN, craft.UP, craft.LEFT, craft.RIGHT]\n  DIRS = {\n      craft.DOWN: (0, 1),\n      craft.UP: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # 2. Breadth-First Search (BFS)\n  # The state in the queue is (position, direction, path_of_actions)\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid cycles\n  visited = {(start_pos, start_dir)}\n\n  while queue:\n      pos, direction, path = queue.popleft()\n\n      # Check for goal condition: is the agent facing the primitive?\n      face_dx, face_dy = DIRS[direction]\n      face_pos = (pos[0] + face_dx, pos[1] + face_dy)\n      \n      if face_pos in primitive_locations_set:\n          # Found a valid path. Append USE action and return the plan.\n          return path + [craft.USE]\n\n      # Expand to neighbor states by trying all possible move actions\n      for action in ACTIONS:\n          move_dx, move_dy = DIRS[action]\n          next_pos = (pos[0] + move_dx, pos[1] + move_dy)\n          # In this environment, the agent's direction becomes the last action taken.\n          next_dir = action\n\n          nx, ny = next_pos\n\n          # --- Check if the next state is valid ---\n          # a) Check if within grid bounds\n          if not (0 <= nx < width and 0 <= ny < height):\n              continue\n\n          # b) Check for non-grabbable obstacles (walls, water, etc.)\n          is_blocked = False\n          for i in world.non_grabbable_indices:\n              if grid[nx, ny, i] > 0:\n                  is_blocked = True\n                  break\n          if is_blocked:\n              continue\n\n          # c) If this state (pos, dir) has not been visited, add it to the queue\n          if (next_pos, next_dir) not in visited:\n              visited.add((next_pos, next_dir))\n              new_path = path + [action]\n              queue.append((next_pos, next_dir, new_path))\n  \n  # 3. No path found\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a state where the agent is adjacent to and facing the target primitive.\n  The state in the search includes the agent's position and direction,\n  ensuring the final orientation is correct for the 'USE' action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the plan, or an empty list if\n    no path is found.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n\n  # Get the integer index for the primitive from its name.\n  try:\n    primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n    # The primitive name doesn't exist in the cookbook.\n    return []\n\n  non_grabbable_indices = current_state.world.non_grabbable_indices\n  width, height = grid.shape[:2]\n\n  # Action constants are mapped to their (dx, dy) effects on position.\n  # Assumes (x, y) coordinates where (0,0) is top-left.\n  # craft.DOWN=0, craft.UP=1, craft.LEFT=2, craft.RIGHT=3\n  moves = {\n      craft.DOWN: (0, 1),\n      craft.UP: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # The BFS queue stores tuples of (position, direction, path).\n  # This correctly models the agent's full state.\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set prevents cycles and redundant exploration.\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    pos, direction, path = queue.popleft()\n    x, y = pos\n\n    # --- 1. GOAL CHECK ---\n    # Check if the cell the agent is currently facing contains the target primitive.\n    # This is the condition for a successful 'USE' action.\n    if direction in moves:\n      face_dx, face_dy = moves[direction]\n      face_x, face_y = x + face_dx, y + face_dy\n\n      if 0 <= face_x < width and 0 <= face_y < height:\n        if grid[face_x, face_y, primitive_index] > 0:\n          # If so, we've found the optimal path. Append 'USE' and return.\n          return path + [craft.USE]\n\n    # --- 2. EXPLORE NEIGHBORS (ACTIONS) ---\n    # Iterate through all possible movement actions.\n    for action in [craft.DOWN, craft.UP, craft.LEFT, craft.RIGHT]:\n      move_dx, move_dy = moves[action]\n      new_x, new_y = x + move_dx, y + move_dy\n      new_pos = (new_x, new_y)\n      # A move action updates the agent's direction to the direction of movement.\n      new_dir = action\n\n      # --- 3. VALIDATE NEW STATE ---\n      # Check if we've been in this state (position and direction) before.\n      if (new_pos, new_dir) in visited:\n        continue\n      \n      # Check if the new position is within the grid boundaries.\n      if not (0 <= new_x < width and 0 <= new_y < height):\n        continue\n      \n      # Check if the destination cell is blocked by a non-grabbable entity.\n      is_blocked = False\n      for idx in non_grabbable_indices:\n        if grid[new_x, new_y, idx] > 0:\n          is_blocked = True\n          break\n      if is_blocked:\n        continue\n\n      # If the new state is valid and unvisited, add it to the queue.\n      visited.add((new_pos, new_dir))\n      queue.append((new_pos, new_dir, path + [action]))\n\n  # If the queue becomes empty, it means no path to a valid collection state exists.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to a primitive and collect it.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a state where the agent is adjacent to and facing the target primitive.\n  The state in the BFS queue includes the agent's position, direction, and the\n  sequence of actions taken to reach that state. This approach correctly\n  handles the directional nature of the 'USE' action.\n\n  Args:\n      env: The CraftLab environment instance, providing access to the current state.\n      primitive: The string name of the primitive to collect.\n\n  Returns:\n      A list of integer actions (e.g., [craft.UP, craft.RIGHT, craft.USE])\n      to collect the primitive, or an empty list if it's unreachable.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  width, height, _ = grid.shape\n\n  # Define mappings from actions to their effects on position (dx, dy).\n  # Based on CraftLab.action_specs: DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n  # We assume the agent's direction is encoded with the same integers.\n  MOVES = {\n      craft.DOWN:  (0, 1),\n      craft.UP:    (0, -1),\n      craft.LEFT:  (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # 1. Get the integer index for the primitive from the cookbook.\n  try:\n      primitive_index = current_state.world.cookbook.index[primitive]\n  except KeyError:\n      # This primitive name doesn't exist in the game's recipes.\n      return []\n\n  # 2. Find all grid locations of the target primitive.\n  primitive_locations = set()\n  for x in range(width):\n      for y in range(height):\n          if grid[x, y, primitive_index] > 0:\n              primitive_locations.add((x, y))\n\n  if not primitive_locations:\n      # The primitive does not exist on the map in this scenario.\n      return []\n\n  # 3. Initialize BFS.\n  # The queue stores tuples of (current_position, current_direction, action_path).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid cycles.\n  visited = set([(start_pos, start_dir)])\n  \n  # Handle edge case: agent might already be in a position to collect.\n  if start_dir in MOVES:\n      dx, dy = MOVES[start_dir]\n      faced_pos = (start_pos[0] + dx, start_pos[1] + dy)\n      if faced_pos in primitive_locations:\n          return [craft.USE]\n\n  # 4. Run BFS to find the shortest path of actions.\n  while queue:\n      pos, direction, path = queue.popleft()\n\n      # Try all 4 possible move actions from the current state.\n      for action, (dx, dy) in MOVES.items():\n          new_pos = (pos[0] + dx, pos[1] + dy)\n          # The new direction is determined by the action taken.\n          new_dir = action\n          \n          if (new_pos, new_dir) in visited:\n              continue\n\n          # Check if the new position is within the grid boundaries.\n          nx, ny = new_pos\n          if not (0 <= nx < width and 0 <= ny < height):\n              continue\n          \n          # The agent cannot move into an occupied cell.\n          if grid[nx, ny].sum() > 0:\n              continue\n\n          # This is a valid move.\n          new_path = path + [action]\n          \n          # Check for goal condition: are we now facing the primitive?\n          face_dx, face_dy = MOVES[new_dir]\n          faced_pos = (new_pos[0] + face_dx, new_pos[1] + face_dy)\n\n          if faced_pos in primitive_locations:\n              # Success! Return the path to get here, plus the final USE action.\n              return new_path + [craft.USE]\n\n          # If not a goal state, add to queue and visited set for exploration.\n          visited.add((new_pos, new_dir))\n          queue.append((new_pos, new_dir, new_path))\n\n  # 5. If the queue becomes empty, no path was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Calculates the shortest sequence of actions to move to and collect a primitive.\n\n  This function performs a Breadth-First Search (BFS) over the state space,\n  where a state is defined by the agent's position and direction. This ensures\n  that the final action sequence not only moves the agent adjacent to the\n  primitive but also correctly orients it for collection.\n\n  Args:\n    env: The simulation environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n    A list of action integers representing the shortest plan to collect the\n    primitive. Returns an empty list if the primitive cannot be found or\n    is unreachable.\n  \"\"\"\n  # Get current state information from the environment\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  world = current_state.world\n  cookbook = world.cookbook\n  width, height, _ = grid.shape\n\n  # Convert the primitive's name to its corresponding integer index\n  try:\n    primitive_idx = cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the game's recipes\n    return []\n\n  # Identify all impassable cells. Non-grabbable items (terrain, workshops,\n  # and other resources) block movement.\n  impassable_indices = world.non_grabbable_indices\n\n  # Define mappings for actions, directions, and their corresponding effects\n  # Assumes directions are encoded: 0=DOWN, 1=UP, 2=LEFT, 3=RIGHT\n  # Assumes move actions (0-3) set the agent's direction accordingly\n  ACTION_DELTAS = {\n      craft.DOWN: (0, -1),\n      craft.UP:   (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT:(1, 0),\n  }\n  DIR_DELTAS = {\n      0: (0, -1),  # DOWN\n      1: (0, 1),   # UP\n      2: (-1, 0),  # LEFT\n      3: (1, 0),   # RIGHT\n  }\n  ACTION_TO_DIR = {\n      craft.DOWN: 0,\n      craft.UP: 1,\n      craft.LEFT: 2,\n      craft.RIGHT: 3,\n  }\n\n  # --- BFS Initialization ---\n  # The queue stores tuples of (position, direction, path_of_actions)\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid cycles\n  visited = {(start_pos, start_dir)}\n\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # --- Goal Check ---\n    # Before exploring new moves, check if the agent is already positioned\n    # and oriented correctly to collect the primitive.\n    facing_delta = DIR_DELTAS.get(direction)\n    if facing_delta:\n      facing_pos = (pos[0] + facing_delta[0], pos[1] + facing_delta[1])\n\n      if 0 <= facing_pos[0] < width and 0 <= facing_pos[1] < height:\n        # If the cell the agent is facing contains the target primitive, we're done.\n        if grid[facing_pos[0], facing_pos[1], primitive_idx] > 0:\n          return path + [craft.USE]\n\n    # --- Explore Actions ---\n    # Generate successor states by trying each possible move action.\n    for action, delta in ACTION_DELTAS.items():\n      new_pos = (pos[0] + delta[0], pos[1] + delta[1])\n      new_dir = ACTION_TO_DIR[action]\n\n      # Ensure the new state is valid and has not been visited\n      if not (0 <= new_pos[0] < width and 0 <= new_pos[1] < height):\n        continue\n      if (new_pos, new_dir) in visited:\n        continue\n\n      # Check if the destination cell is passable\n      is_passable = not any(grid[new_pos[0], new_pos[1], idx] > 0 for idx in impassable_indices)\n      \n      if is_passable:\n        visited.add((new_pos, new_dir))\n        new_path = path + [action]\n        queue.append((new_pos, new_dir, new_path))\n\n  # If the queue is exhausted, no path to the primitive exists\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a location from which a specified primitive can be collected.\n  The state in the BFS includes the agent's position and direction, as the\n  'USE' action is directional.\n\n  The search proceeds as follows:\n  1.  Identify all locations of the target primitive on the grid.\n  2.  Initialize a queue for BFS with the agent's starting state (position,\n      direction, empty action list).\n  3.  Use a 'visited' set to keep track of (position, direction) states to\n      avoid cycles and redundant exploration.\n  4.  In each step of the BFS, explore all possible next states by trying\n      each of the four movement actions (UP, DOWN, LEFT, RIGHT).\n  5.  A move is valid if the destination cell is within the grid boundaries,\n      is not an impassable obstacle (a non-grabbable entity), and the\n      resulting (position, direction) state has not been visited.\n  6.  The goal is reached when the agent is in a state (pos, dir) where the\n      cell it is facing contains the target primitive.\n  7.  Once such a state is found, the path of actions taken to reach it is\n      appended with the 'USE' action and returned.\n  8.  If the queue becomes empty and the goal has not been reached, it means\n      the primitive is unreachable, and an empty list is returned.\n  \"\"\"\n  # Get the current state and world configuration from the environment.\n  current_state = env._current_state\n  world = current_state.world\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  width, height, _ = grid.shape\n\n  # Mapping from action index to change in position (dx, dy).\n  # This must match the environment's internal logic.\n  ACTION_DELTAS = {\n      craft.DOWN: (0, -1),\n      craft.UP: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # Convert the primitive's string name to its integer index.\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The primitive name is not recognized by the cookbook.\n    return []\n\n  # Find all grid coordinates containing the target primitive.\n  primitive_locations = set(zip(*np.where(grid[:, :, primitive_index] > 0)))\n  if not primitive_locations:\n    # The primitive does not exist on the map.\n    return []\n\n  # Initialize the BFS queue with the starting state: (position, direction, path).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # Keep track of visited (position, direction) states to avoid cycles.\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # --- Goal Condition Check ---\n    # Determine the cell the agent is currently facing.\n    if direction in ACTION_DELTAS:\n      dx, dy = ACTION_DELTAS[direction]\n      facing_pos = (pos[0] + dx, pos[1] + dy)\n\n      # If the facing cell contains the primitive, a valid plan is found.\n      if facing_pos in primitive_locations:\n        return path + [craft.USE]\n\n    # --- Explore Neighbors (Next Possible States) ---\n    for action in [craft.UP, craft.DOWN, craft.LEFT, craft.RIGHT]:\n      # A movement action also sets the agent's new direction.\n      new_dir = action\n      dx, dy = ACTION_DELTAS[action]\n      new_pos = (pos[0] + dx, pos[1] + dy)\n      nx, ny = new_pos\n\n      new_state = (new_pos, new_dir)\n\n      # Check if this new state is valid and has not been visited.\n      if new_state not in visited:\n        # 1. Check if the new position is within the grid boundaries.\n        if 0 <= nx < width and 0 <= ny < height:\n          # 2. Check if the cell is passable (not blocked by a non-grabbable entity).\n          is_blocked = any(grid[nx, ny, i] > 0 for i in world.non_grabbable_indices)\n          \n          if not is_blocked:\n            # If the move is valid, mark the state as visited and add it to the queue.\n            visited.add(new_state)\n            new_path = path + [action]\n            queue.append((new_pos, new_dir, new_path))\n\n  # If the queue is exhausted, no path to collect the primitive was found.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, approach, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path to a position adjacent to the target primitive, with the correct \n  orientation to collect it.\n\n  The state in the BFS is (position, direction), ensuring that the final plan\n  not only reaches the correct location but also has the agent facing the\n  primitive before issuing the 'USE' command.\n\n  The pathfinding correctly identifies obstacles, treating any non-empty cell\n  (containing either grabbable or non-grabbable items) as impassable, as per\n  the environment rules.\n  \"\"\"\n  # 1. Setup: Extract current state information from the environment.\n  current_state = env._current_state\n  world = current_state.world\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  width, height = grid.shape[:2]\n\n  # Convert the primitive name (string) to its integer index.\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # If the primitive name is not in the cookbook, no plan can be made.\n    return []\n\n  # Define the mapping from action constants to movement vectors (dx, dy).\n  # We assume the `craft` module provides integer constants for actions.\n  # craft.DOWN: 0, craft.UP: 1, craft.LEFT: 2, craft.RIGHT: 3\n  moves = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # 2. BFS Initialization\n  # The queue stores tuples of (position, direction, current_path).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) tuples to avoid cycles and redundant exploration.\n  visited = {(start_pos, start_dir)}\n\n  # 3. BFS Main Loop\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # --- GOAL CHECK ---\n    # Determine the position in front of the agent based on its current direction.\n    if direction not in moves:\n        continue\n    fwd_dx, fwd_dy = moves[direction]\n    front_pos = (pos[0] + fwd_dx, pos[1] + fwd_dy)\n\n    # Check if the front position is within the grid boundaries.\n    if 0 <= front_pos[0] < width and 0 <= front_pos[1] < height:\n      # Check if the target primitive exists at the front position.\n      if grid[front_pos[0], front_pos[1], primitive_index] > 0:\n        # Success! Return the path followed by the USE action.\n        return path + [craft.USE]\n\n    # --- EXPLORE NEIGHBORS ---\n    # Iterate through all possible move actions to find the next states.\n    for action, (dx, dy) in moves.items():\n      next_pos = (pos[0] + dx, pos[1] + dy)\n      # A move action determines the agent's new direction.\n      next_dir = action\n      \n      # If this state has been visited, skip it.\n      if (next_pos, next_dir) in visited:\n        continue\n\n      # Check if the next position is within grid boundaries.\n      if not (0 <= next_pos[0] < width and 0 <= next_pos[1] < height):\n        continue\n\n      # An agent can only move into empty cells. A cell is blocked if it contains anything.\n      # The grid is a one-hot encoding, so a sum > 0 means it's not empty.\n      if grid[next_pos[0], next_pos[1]].sum() > 0:\n        continue\n\n      # If the move is valid, add the new state to the queue and visited set.\n      visited.add((next_pos, next_dir))\n      new_path = path + [action]\n      queue.append((next_pos, next_dir, new_path))\n\n  # If the queue becomes empty, it means no path to the primitive could be found.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path from the agent's current position to a location adjacent to the\n  target primitive. The generated plan includes movement, final orientation towards\n  the primitive, and the 'USE' action for collection.\n\n  Args:\n    env: The current environment instance (CraftLab).\n    primitive: The string name of the primitive to collect (e.g., \"wood\").\n\n  Returns:\n    A list of integer actions representing the optimal plan, or an empty list\n    if the primitive is unreachable.\n  \"\"\"\n  \n  # 1. Initialization\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  world = current_state.world\n\n  # Safely get the integer index for the primitive name.\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the world's cookbook.\n    return []\n\n  width, height, _ = grid.shape\n  non_grabbable_indices = world.non_grabbable_indices\n\n  # Map actions to coordinate changes (dx, dy).\n  # Assumes grid access via grid[x, y] and (0,0) is top-left.\n  # UP: y decreases, DOWN: y increases, LEFT: x decreases, RIGHT: x increases.\n  action_deltas = {\n      craft.UP:    (0, -1),\n      craft.DOWN:  (0, 1),\n      craft.LEFT:  (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  \n  # BFS queue stores tuples of (position, path_of_actions).\n  queue = collections.deque([(start_pos, [])])\n  # Visited set stores positions to avoid cycles and redundant exploration.\n  visited = {start_pos}\n\n  # 2. BFS Algorithm\n  while queue:\n    current_pos, path = queue.popleft()\n\n    # Explore applying each of the four movement actions from the current position.\n    for action, (dx, dy) in action_deltas.items():\n      # adj_pos is the cell the agent would be facing or attempting to move into.\n      adj_pos = (current_pos[0] + dx, current_pos[1] + dy)\n      ax, ay = adj_pos\n\n      # Continue if the adjacent position is out of the grid bounds.\n      if not (0 <= ax < width and 0 <= ay < height):\n        continue\n\n      # --- Goal Condition Check ---\n      # Check if the adjacent cell contains the target primitive.\n      if grid[ax, ay, primitive_index] > 0:\n        # If so, a path is found. The plan is:\n        # 1. The 'path' to get to the current_pos.\n        # 2. The 'action' to turn and face the primitive. The agent's move\n        #    into the blocked cell will fail, but its orientation will be set.\n        # 3. The 'USE' action to collect the primitive.\n        return path + [action, craft.USE]\n\n      # --- Expansion Step ---\n      # If not the target, check if it's a valid, empty cell to move into.\n      # A cell is blocked if it contains any non-grabbable entity.\n      is_blocked = any(grid[ax, ay, i] > 0 for i in non_grabbable_indices)\n\n      if not is_blocked and adj_pos not in visited:\n        visited.add(adj_pos)\n        new_path = path + [action]\n        queue.append((adj_pos, new_path))\n  \n  # 3. No Path Found\n  # If the queue is exhausted, the primitive is unreachable.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a cell adjacent to the target primitive. It correctly handles\n  obstacles and ensures the agent turns to face the primitive before\n  attempting to collect it.\n\n  Args:\n    env: The simulation environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\", \"IRON\").\n\n  Returns:\n    A list of integer actions (e.g., [craft.UP, craft.RIGHT, craft.USE])\n    representing the plan to collect the primitive. Returns an empty list\n    if the primitive is not on the map or is unreachable.\n  \"\"\"\n  # Get the current state and world parameters from the environment\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  world = current_state.world\n  \n  width, height, _ = grid.shape\n  \n  # Get the integer index for the primitive and non-passable terrain types\n  primitive_index = world.cookbook.index[primitive]\n  non_grabbable_indices = world.non_grabbable_indices\n  \n  # Define mappings from coordinate deltas to action constants\n  delta_to_action = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT\n  }\n  directions = list(delta_to_action.keys())\n\n  # Step 1: Find all locations of the target primitive\n  primitive_locations = []\n  for x in range(width):\n    for y in range(height):\n      if grid[x, y, primitive_index] > 0:\n        primitive_locations.append((x, y))\n  \n  if not primitive_locations:\n    return []  # Primitive not found on the map\n\n  # Step 2: Identify all valid, reachable cells adjacent to any primitive\n  # These are the goal cells for our pathfinding algorithm.\n  goal_cells = {}  # Maps an adjacent cell to its corresponding primitive's cell\n  for px, py in primitive_locations:\n    for dx, dy in directions:\n      ax, ay = px + dx, py + dy\n      \n      if 0 <= ax < width and 0 <= ay < height:\n        # A cell is a valid goal if it's not blocked by a non-grabbable object\n        is_blocked = any(grid[ax, ay, idx] > 0 for idx in non_grabbable_indices)\n        if not is_blocked:\n          goal_cells[(ax, ay)] = (px, py)\n\n  if not goal_cells:\n    return [] # No accessible cells next to the primitive\n\n  # Step 3: Use Breadth-First Search (BFS) to find the shortest path\n  # The queue stores tuples of (current_position, path_of_actions_so_far)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n  \n  path_to_adjacent_cell = None\n  final_agent_pos = None\n  target_primitive_pos = None\n  \n  # Handle the case where the agent already starts at a goal position\n  if start_pos in goal_cells:\n    path_to_adjacent_cell = []\n    final_agent_pos = start_pos\n    target_primitive_pos = goal_cells[start_pos]\n  else:\n    while queue:\n      (cx, cy), path = queue.popleft()\n      \n      for dx, dy in directions:\n        nx, ny = cx + dx, cy + dy\n        neighbor = (nx, ny)\n\n        if 0 <= nx < width and 0 <= ny < height and neighbor not in visited:\n          # Check if the neighbor cell is passable\n          is_blocked = any(grid[nx, ny, idx] > 0 for idx in non_grabbable_indices)\n          \n          if not is_blocked:\n            visited.add(neighbor)\n            action = delta_to_action[(dx, dy)]\n            new_path = path + [action]\n            \n            # Check if this neighbor is one of our goal cells\n            if neighbor in goal_cells:\n              path_to_adjacent_cell = new_path\n              final_agent_pos = neighbor\n              target_primitive_pos = goal_cells[neighbor]\n              queue.clear() # Path found, stop searching\n              break\n            \n            queue.append((neighbor, new_path))\n  \n  # Step 4: If a path was found, construct the full action sequence\n  if path_to_adjacent_cell is None:\n    return [] # No path exists\n    \n  actions = list(path_to_adjacent_cell)\n  \n  # Add an action to turn and face the primitive.\n  # The 'move' action will cause a turn even if the target cell is blocked.\n  px, py = target_primitive_pos\n  fx, fy = final_agent_pos\n  face_delta = (px - fx, py - fy)\n  face_action = delta_to_action[face_delta]\n  actions.append(face_action)\n  \n  # Finally, add the action to collect the primitive\n  actions.append(craft.USE)\n  \n  return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
