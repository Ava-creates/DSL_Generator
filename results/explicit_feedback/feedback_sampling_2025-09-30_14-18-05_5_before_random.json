{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, navigate to, and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) over the state space, which\n  includes both the agent's (x, y) position and its facing direction. This is\n  necessary because the 'USE' action is directional. The search finds the shortest\n  sequence of moves to position the agent adjacent to the target primitive while\n  facing it, and then appends the 'USE' action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of integer actions (e.g., [craft.UP, craft.RIGHT, craft.USE]) representing the\n    plan. Returns an empty list if no path is found.\n  \"\"\"\n  state = env._current_state\n  start_pos = state.pos\n  start_dir = state.dir\n  grid = state.grid\n  grid_shape = grid.shape\n  primitive_index = env.world.cookbook.index[primitive]\n\n  # Mappings from action constants to their effects on (x, y) coordinates.\n  # Based on the common structure of grid worlds, we assume a standard\n  # Cartesian system where UP is +y, RIGHT is +x.\n  action_deltas = {\n      craft.UP:    (0, 1),\n      craft.DOWN:  (0, -1),\n      craft.LEFT:  (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  move_actions = list(action_deltas.keys())\n\n  # State for the BFS queue: ( (x, y)_pos, direction, path_list )\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # Visited set stores states to prevent cycles: ( (x, y)_pos, direction )\n  visited = set([(start_pos, start_dir)])\n\n  def is_blocked(x, y):\n      \"\"\"A cell is considered blocked and untraversable if it is non-empty.\"\"\"\n      return np.any(grid[x, y] > 0)\n\n  # Edge case: Check if we can collect from the starting position without moving.\n  front_delta = action_deltas.get(start_dir)\n  if front_delta:\n      front_pos = (start_pos[0] + front_delta[0], start_pos[1] + front_delta[1])\n      if (0 <= front_pos[0] < grid_shape[0] and\n          0 <= front_pos[1] < grid_shape[1] and\n          grid[front_pos[0], front_pos[1], primitive_index] > 0):\n          return [craft.USE]\n\n  # Main BFS loop to find the shortest path in the (position, direction) state space.\n  while queue:\n      pos, dir, path = queue.popleft()\n\n      # Explore all possible moves from the current state.\n      for action in move_actions:\n          delta = action_deltas[action]\n          new_pos = (pos[0] + delta[0], pos[1] + delta[1])\n          # In this environment, the new direction is the move action that was taken.\n          new_dir = action\n\n          # --- Validity Checks for the new state ---\n\n          # 1. Is the destination cell within the grid boundaries?\n          if not (0 <= new_pos[0] < grid_shape[0] and 0 <= new_pos[1] < grid_shape[1]):\n              continue\n          \n          # 2. Is the destination cell blocked?\n          if is_blocked(new_pos[0], new_pos[1]):\n              continue\n          \n          # 3. Have we been in this exact state (position and direction) before?\n          if (new_pos, new_dir) in visited:\n              continue\n\n          # --- Goal Check ---\n          # The new state is valid and unvisited. Before adding it to the queue for\n          # further exploration, we check if it is a \"pre-goal\" state. A pre-goal\n          # state is one from which the 'USE' action will succeed.\n          \n          front_delta_from_new = action_deltas[new_dir]\n          front_pos_from_new = (new_pos[0] + front_delta_from_new[0], new_pos[1] + front_delta_from_new[1])\n\n          if (0 <= front_pos_from_new[0] < grid_shape[0] and\n              0 <= front_pos_from_new[1] < grid_shape[1] and\n              grid[front_pos_from_new[0], front_pos_from_new[1], primitive_index] > 0):\n              # Success! The path `path + [action]` gets us to the correct position\n              # and orientation. The final step is to USE.\n              return path + [action, craft.USE]\n          \n          # --- Enqueue for Exploration ---\n          # This state is not a goal state, but it's a valid step on a potential path.\n          visited.add((new_pos, new_dir))\n          queue.append((new_pos, new_dir, path + [action]))\n  \n  return [] # Return an empty list if no path to collect the primitive is found.\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path from the agent's current position to a location where it can\n  collect the specified primitive.\n\n  The core of the strategy is to search through a state space that includes not\n  only the agent's (x, y) position but also its direction (dir). This is\n  critical because the 'USE' action is directional and requires the agent to be\n  facing the target primitive.\n\n  The search proceeds as follows:\n  1.  Identify all locations of the target primitive on the grid.\n  2.  Initialize a queue for the BFS with the agent's starting state\n      (position, direction, and an empty path).\n  3.  Use a 'visited' set to keep track of (x, y, dir) states already\n      explored to avoid cycles and redundant computations.\n  4.  The BFS explores the grid by expanding states. For each state, it\n      checks if the agent is facing a cell containing the primitive. If so, a\n      valid path has been found.\n  5.  If not at a goal state, it generates new states by applying each\n      possible move action (UP, DOWN, LEFT, RIGHT). New states are added to\n      the queue if they lead to a traversable (empty) cell and have not\n      been visited before.\n  6.  The first complete path found is guaranteed to be one of the shortest\n      in terms of the number of actions. The 'USE' action is appended to this\n      path to perform the final collection.\n\n  This implementation correctly avoids the common pitfall of trying to move\n  into a blocked cell containing the primitive. Instead, it finds a path to\n  stand next to it and face it, which is consistent with the game's mechanics.\n  \"\"\"\n  from collections import deque\n\n  # 1. SETUP: Extract current state and identify target primitive\n  state = env._current_state\n  start_pos = state.pos\n  start_dir = state.dir\n  grid = state.grid\n  width, height, _ = grid.shape\n\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive does not exist in this world's cookbook.\n    return []\n\n  # Find all grid cells containing the target primitive.\n  target_coords = set(zip(*np.where(grid[:, :, primitive_index] > 0)))\n\n  if not target_coords:\n    return []  # Primitive not found on the map.\n\n  # 2. DEFINE STATE & ACTION-EFFECT MAPPINGS FOR BFS\n  # We establish an internal, consistent convention for directions.\n  # Convention: 0:UP, 1:RIGHT, 2:DOWN, 3:LEFT\n  dir_to_vector = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # Maps dir index to (dx, dy)\n\n  # Map environment actions to their effects on position and direction.\n  # This assumes a standard grid world behavior where a move action\n  # changes both position and makes the agent face the direction of movement.\n  action_effects = {\n      craft.UP:    {'dpos': (0, 1),  'new_dir': 0},\n      craft.RIGHT: {'dpos': (1, 0),  'new_dir': 1},\n      craft.DOWN:  {'dpos': (0, -1), 'new_dir': 2},\n      craft.LEFT:  {'dpos': (-1, 0), 'new_dir': 3},\n  }\n\n  # Helper to check if a cell is traversable. According to the rules,\n  # any non-empty cell is blocked for movement.\n  def is_traversable(x, y):\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    return np.sum(grid[x, y]) == 0\n\n  # 3. BFS IMPLEMENTATION\n  # The queue stores tuples of: (x, y, direction, path_list)\n  # The visited set stores tuples of (x, y, direction) to avoid cycles.\n  queue = deque([(start_pos[0], start_pos[1], start_dir, [])])\n  visited = set([(start_pos[0], start_pos[1], start_dir)])\n\n  while queue:\n    x, y, current_dir, path = queue.popleft()\n\n    # GOAL CHECK: Is the agent currently facing a cell with the primitive?\n    if current_dir in dir_to_vector:\n      face_dx, face_dy = dir_to_vector[current_dir]\n      facing_pos = (x + face_dx, y + face_dy)\n      if facing_pos in target_coords:\n        # Path found. Append USE action to collect.\n        return path + [craft.USE]\n\n    # EXPANSION: Try all four move actions from the current state.\n    for action, effect in action_effects.items():\n      dx, dy = effect['dpos']\n      new_dir = effect['new_dir']\n      nx, ny = x + dx, y + dy\n\n      # If new position is valid and this state (pos, dir) has not been visited...\n      if is_traversable(nx, ny) and (nx, ny, new_dir) not in visited:\n        visited.add((nx, ny, new_dir))\n        new_path = path + [action]\n        queue.append((nx, ny, new_dir, new_path))\n            \n  return [] # No path found\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest \n  path to a location where the agent is adjacent to and facing the target \n  primitive. The generated path concludes with a 'USE' action to collect it.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the optimal plan, or an empty\n    list if the primitive is unreachable.\n  \"\"\"\n  # 1. Set up pathfinding problem\n  primitive_index = env.world.cookbook.index[primitive]\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  grid_width, grid_height, _ = grid.shape\n\n  # Define movement actions and their corresponding (dx, dy) coordinate changes.\n  # The environment uses an inverted y-axis: UP is +1, DOWN is -1.\n  action_deltas = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  # A reverse mapping is also useful.\n  # We use a tuple key because numpy arrays are not hashable.\n  vec_to_action = {v: k for k, v in action_deltas.items()}\n\n  # Helper to check if a cell is empty and within grid bounds.\n  def is_traversable(x, y):\n    if not (0 <= x < grid_width and 0 <= y < grid_height):\n      return False\n    # A cell is traversable only if it's completely empty.\n    return not np.any(grid[x, y] > 0)\n\n  # 2. Perform Breadth-First Search (BFS)\n  \n  # Queue stores tuples of (x, y, path_list)\n  queue = collections.deque([(start_pos[0], start_pos[1], [])])\n  \n  # Visited set stores (x, y) tuples of explored empty cells to prevent cycles.\n  visited = {start_pos}\n\n  # Optimization: Check if we can collect from the starting position\n  start_dir_vec = action_deltas.get(current_state.dir)\n  if start_dir_vec:\n      front_x, front_y = start_pos[0] + start_dir_vec[0], start_pos[1] + start_dir_vec[1]\n      if (0 <= front_x < grid_width and 0 <= front_y < grid_height and\n              grid[front_x, front_y, primitive_index] > 0):\n          return [craft.USE]\n\n  while queue:\n    x, y, path = queue.popleft()\n\n    # Explore neighbors by trying each possible move from the current cell (x, y)\n    for action, (dx, dy) in action_deltas.items():\n      \n      # Calculate the potential next position\n      next_x, next_y = x + dx, y + dy\n      \n      # Check if this move is valid (into an unvisited, traversable cell)\n      if (next_x, next_y) not in visited and is_traversable(next_x, next_y):\n        \n        # This move is valid. The new path would be...\n        new_path = path + [action]\n        \n        # After this move, the agent will be at (next_x, next_y) and facing\n        # in the direction of the move (dx, dy).\n        # We must check the cell IN FRONT of that new state for the primitive.\n        front_x, front_y = next_x + dx, next_y + dy\n        \n        # Check if the cell in front is in bounds AND contains the target primitive\n        if (0 <= front_x < grid_width and 0 <= front_y < grid_height and \n            grid[front_x, front_y, primitive_index] > 0):\n          \n          # GOAL FOUND: We found a path that ends with the agent adjacent\n          # to and facing the primitive. The plan is the path plus a USE action.\n          return new_path + [craft.USE]\n        \n        # If it's not a goal state, mark this new cell as visited and add it\n        # to the queue to continue the search from there.\n        visited.add((next_x, next_y))\n        queue.append((next_x, next_y, new_path))\n        \n  # If the queue becomes empty, it means the primitive is unreachable.\n  return []\n",
  "evaluation_result": [
    1.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path to a position from which the agent can collect the target primitive.\n  A collection is possible if the agent is in an empty cell adjacent to the \n  primitive and is facing it.\n\n  Args:\n    env: The simulation environment instance (CraftLab).\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n    A list of action integers representing the optimal sequence of actions.\n    Returns an empty list if the primitive is not on the map or is unreachable.\n  \"\"\"\n  import numpy as np\n  from collections import deque\n\n  # === 1. SETUP: Extract current state and define environment constants ===\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    return []  # Invalid primitive name.\n\n  grid_width, grid_height, _ = grid.shape\n\n  # Pre-calculate all locations of the target primitive for efficient lookup.\n  target_locations = set()\n  for x in range(grid_width):\n    for y in range(grid_height):\n      if grid[x, y, primitive_index] > 0:\n        target_locations.add((x, y))\n\n  if not target_locations:\n    return []  # Primitive does not exist on the map.\n\n  # Define mappings for directions and movements.\n  # Agent direction: 0:Down, 1:Up, 2:Left, 3:Right\n  DIR_VECTORS = {\n      0: (0, -1),  # Down\n      1: (0, 1),   # Up\n      2: (-1, 0),  # Left\n      3: (1, 0),   # Right\n  }\n  MOVE_VECTORS = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # === 2. INITIAL CHECK: Handle the trivial case ===\n  # If the agent is already facing the primitive, the only action needed is USE.\n  if start_dir in DIR_VECTORS:\n    dx, dy = DIR_VECTORS[start_dir]\n    facing_pos = (start_pos[0] + dx, start_pos[1] + dy)\n    if facing_pos in target_locations:\n      return [craft.USE]\n\n  # === 3. BFS PATHFINDING ===\n  # Helper function to determine if a cell is blocked for movement.\n  # Any non-empty cell is considered blocked.\n  def is_blocked(x, y):\n    return np.any(grid[x, y] > 0)\n\n  # The queue stores tuples of: ((current_x, current_y), path_list)\n  queue = deque([(start_pos, [])])\n  # The visited set stores positions to avoid cycles and redundant exploration.\n  visited = {start_pos}\n\n  while queue:\n    (x, y), path = queue.popleft()\n\n    # Explore neighbors by trying each of the four possible moves.\n    for action, (dx, dy) in MOVE_VECTORS.items():\n      # This is the adjacent position the agent would move into.\n      next_pos = (x + dx, y + dy)\n\n      # A. Boundary check for the potential next position.\n      if not (0 <= next_pos[0] < grid_width and 0 <= next_pos[1] < grid_height):\n        continue\n      \n      # B. Goal Check: This is the core logic.\n      # The position the agent will be facing *after* the move is `next_pos + (dx, dy)`.\n      # If this facing position contains the target primitive, and the cell we\n      # are moving into (`next_pos`) is empty, we have found a valid solution.\n      facing_pos_after_move = (next_pos[0] + dx, next_pos[1] + dy)\n      \n      if facing_pos_after_move in target_locations:\n        if not is_blocked(next_pos[0], next_pos[1]):\n          # Solution found: path to current cell + the final move + the USE action.\n          return path + [action, craft.USE]\n\n      # C. Path Expansion: If not a goal, check if we can add this move to the queue.\n      # The agent can move to `next_pos` if it's not blocked and hasn't been visited.\n      if next_pos not in visited and not is_blocked(next_pos[0], next_pos[1]):\n        visited.add(next_pos)\n        new_path = path + [action]\n        queue.append((next_pos, new_path))\n  \n  # If the queue becomes empty, it means the target is unreachable.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a state from which the specified primitive can be collected. A key\n  insight is that the agent must be on an empty cell *adjacent* to the\n  primitive and *facing* it.\n\n  The algorithm works as follows:\n  1. Identify all locations of the target primitive.\n  2. For each primitive, determine the valid \"goal states\". A goal state is\n      defined as a tuple: ((position), action). This means being at 'position'\n      having arrived via 'action', which correctly orients the agent.\n  3. Run a BFS starting from the agent's current position. The search space\n      consists of all empty cells.\n  4. The BFS terminates when it finds a move that lands the agent in one of\n      the pre-calculated goal states.\n  5. The final action sequence is the path to reach the goal state, followed\n      by the 'USE' action to perform the collection.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  grid_height, grid_width, _ = grid.shape\n  start_pos = state.pos\n\n  # 1. Map primitive name to its numerical index.\n  try:\n    primitive_index = state.world.cookbook.index[primitive]\n  except KeyError:\n    return [] # Primitive does not exist.\n\n  # 2. Define moves and their corresponding (dx, dy) deltas.\n  action_deltas = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # 3. Determine all valid goal states ((x, y), last_action).\n  goal_states = set()\n  # np.argwhere returns coordinates as (row, col), which corresponds to (y, x).\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  for prim_loc in primitive_locations:\n    prim_y, prim_x = prim_loc\n    # For each primitive, consider approaching it from all 4 sides.\n    for action, (dx, dy) in action_deltas.items():\n      # The adjacent cell (adj_x, adj_y) is where the agent must stand.\n      adj_x, adj_y = prim_x - dx, prim_y - dy\n\n      # The adjacent cell must be within bounds and empty.\n      if 0 <= adj_y < grid_height and 0 <= adj_x < grid_width:\n        if not np.any(grid[adj_y, adj_x, :]):\n          # A valid goal is to be at (adj_x, adj_y) after performing `action`.\n          goal_states.add(((adj_x, adj_y), action))\n\n  if not goal_states:\n    return [] # No accessible spots next to any instance of the primitive.\n\n  # 4. BFS to find the shortest path to a goal state.\n  # The queue stores tuples of (current_position, path_of_actions).\n  queue = collections.deque([(start_pos, [])])\n  # The visited set stores positions (x, y) to avoid cycles.\n  visited = {start_pos}\n\n  # The main BFS loop.\n  while queue:\n    (current_x, current_y), path = queue.popleft()\n\n    # Explore neighbors by trying each possible move.\n    for action, (dx, dy) in action_deltas.items():\n      next_x, next_y = current_x + dx, current_y + dy\n\n      # Check if this move achieves a goal state.\n      if ((next_x, next_y), action) in goal_states:\n        # Found the shortest path.\n        return path + [action, craft.USE]\n\n      # Standard BFS traversal check.\n      if 0 <= next_y < grid_height and 0 <= next_x < grid_width:\n        # The next cell must be unvisited and empty to be traversable.\n        if (next_x, next_y) not in visited and not np.any(grid[next_y, next_x, :]):\n          visited.add((next_x, next_y))\n          queue.append(((next_x, next_y), path + [action]))\n          \n  # If the queue becomes empty, no path was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) over the state space\n  defined by (x, y, direction). This is necessary because the 'USE' action\n  is directional, and the agent must be facing the primitive to collect it.\n\n  The algorithm works as follows:\n  1. Initialize a queue with the agent's starting state (position, direction, and an empty path).\n  2. Maintain a 'visited' set for (x, y, direction) tuples to avoid cycles and redundant exploration.\n  3. In a loop, dequeue a state and check two types of actions:\n     a. USE action: Check if the cell directly in front of the agent contains the target primitive. If so, a solution is found.\n     b. Move actions (UP, DOWN, LEFT, RIGHT): For each possible move, calculate the new position and direction. If the new cell is valid (within bounds and empty) and the new state has not been visited, add it to the queue.\n  4. The first solution found is guaranteed to be one of the shortest in terms of the number of actions.\n  5. If the queue becomes empty before a solution is found, no path exists.\n  \"\"\"\n  # Get current state from the environment wrapper\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  # Get the integer index for the primitive name from the cookbook\n  primitive_index = state.world.cookbook.index[primitive]\n  \n  # Get grid dimensions assuming grid shape is (WIDTH, HEIGHT, n_kinds)\n  width, height, _ = grid.shape\n\n  # Define movement vectors for each action.\n  # The environment's action_specs maps DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923.\n  # We assume standard Cartesian coordinates where 'pos' is (x, y).\n  moves = {\n      craft.UP:    (0, 1),\n      craft.DOWN:  (0, -1),\n      craft.LEFT:  (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # The agent's direction 'dir' is an integer assumed to map to the same actions.\n  \n  # Queue for BFS. State is a tuple: (x, y, direction, path_list)\n  queue = collections.deque([(start_pos[0], start_pos[1], start_dir, [])])\n  \n  # Visited set to avoid cycles. State is a tuple: (x, y, direction)\n  visited = set([(start_pos[0], start_pos[1], start_dir)])\n\n  while queue:\n      x, y, direction, path = queue.popleft()\n\n      # --- GOAL CHECK: Try to USE the primitive from the current state ---\n      if direction in moves:\n          # Determine the coordinates of the cell in front of the agent\n          face_dx, face_dy = moves[direction]\n          front_x, front_y = x + face_dx, y + face_dy\n\n          # Check if the cell in front is in bounds and contains the target primitive\n          if 0 <= front_x < width and 0 <= front_y < height:\n              if grid[front_x, front_y, primitive_index] > 0:\n                  # Goal found: the agent is positioned correctly to collect.\n                  return path + [craft.USE]\n\n      # --- EXPANSION STEP: Try all possible moves from the current state ---\n      for action, (dx, dy) in moves.items():\n          # A move action updates both position and direction\n          nx, ny = x + dx, y + dy\n          new_dir = action \n          \n          # Check if the new position is valid: within bounds and not blocked\n          if 0 <= nx < width and 0 <= ny < height and not grid[nx, ny].any():\n              # Check if this new state (pos, dir) has been visited before\n              if (nx, ny, new_dir) not in visited:\n                  visited.add((nx, ny, new_dir))\n                  new_path = path + [action]\n                  queue.append((nx, ny, new_dir, new_path))\n                  \n  # If the queue becomes empty, no path to collect the primitive was found\n  return []\n\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a cell adjacent to the target primitive. It then computes the final\n  action sequence, including a turn-by-bumping maneuver if the agent is not\n  already facing the primitive upon arrival.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the plan to collect the primitive,\n    or an empty list if the primitive is unreachable.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  try:\n    primitive_index = state.world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive name does not exist in the game's cookbook.\n    return []\n  \n  start_pos = state.pos\n\n  # Mappings from (dx, dy) deltas to action constants and vice-versa.\n  # This assumes a standard Cartesian grid where +y is UP and +x is RIGHT.\n  delta_to_action = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  action_to_delta = {v: k for k, v in delta_to_action.items()}\n\n  def is_blocked(x, y):\n      \"\"\"Checks if a cell is blocked for movement (i.e., is not empty).\"\"\"\n      return np.any(grid[x, y] > 0)\n\n  # BFS state is a tuple: ((x, y), path_list)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  # Main BFS loop to find the shortest path to an adjacent cell.\n  while queue:\n      (x, y), path = queue.popleft()\n\n      # Explore neighbors of the current cell (x, y)\n      for delta, move_action in delta_to_action.items():\n          nx, ny = x + delta[0], y + delta[1]\n\n          # Check if the neighbor is within grid boundaries\n          if not (0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]):\n              continue\n\n          # --- GOAL CONDITION ---\n          # Check if the neighbor cell (nx, ny) contains the target primitive.\n          if grid[nx, ny, primitive_index] > 0:\n              # Goal found: (x,y) is adjacent to the primitive.\n              # The path to reach (x,y) is `path`.\n              # The action required to face the primitive from (x,y) is `move_action`.\n              action_to_face = move_action\n              \n              is_oriented_correctly = False\n              # Case 1: Agent starts next to the primitive (path is empty).\n              if not path:\n                  # Check the agent's initial direction.\n                  # We assume the agent's `dir` int maps to an action constant.\n                  start_dir_delta = action_to_delta.get(state.dir)\n                  if start_dir_delta == delta:\n                      is_oriented_correctly = True\n              # Case 2: Agent moved to the adjacent spot.\n              else:\n                  # The last move taken determines the agent's current direction.\n                  last_action = path[-1]\n                  if last_action == action_to_face:\n                      is_oriented_correctly = True\n\n              if is_oriented_correctly:\n                  # Already facing the primitive, just USE.\n                  return path + [craft.USE]\n              else:\n                  # Not facing. \"Bump\" into the primitive to turn, then USE.\n                  return path + [action_to_face, craft.USE]\n          \n          # --- TRAVERSAL ---\n          # If neighbor is not the goal, see if we can move there to continue the search.\n          if (nx, ny) not in visited and not is_blocked(nx, ny):\n              visited.add((nx, ny))\n              new_path = path + [move_action]\n              queue.append(((nx, ny), new_path))\n  \n  return [] # Target primitive not found or unreachable\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates the shortest sequence of actions to find and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path from the agent's current position to a location where it can collect\n  the target primitive.\n\n  The key features of this implementation are:\n  1. State Representation: The search space includes the agent's direction\n     (x, y, dir), which is crucial because the 'USE' action is directional.\n  2. Pathfinding Goal: The search terminates when it finds a state (a position\n     and direction) where the agent is facing a cell that contains the target\n     primitive.\n  3. Obstacle Handling: It adheres to the rule that any non-empty cell is\n     considered blocked, so the agent pathfinds through empty cells only.\n  \"\"\"\n  import numpy as np\n  from collections import deque\n  import craft\n\n  # 1. Initialize state from the environment\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n  width, height, _ = grid.shape\n\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    # Target primitive does not exist in the world definition.\n    return []\n\n  # 2. Define action and direction mappings based on environment specs.\n  # The agent's direction `dir` is an integer. We assume it corresponds to the\n  # integer value of the last move action taken.\n  # Based on action_specs: DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923.\n  action_effects = {\n      craft.UP:    {'delta': (0, 1), 'dir': craft.UP},\n      craft.DOWN:  {'delta': (0, -1), 'dir': craft.DOWN},\n      craft.LEFT:  {'delta': (-1, 0), 'dir': craft.LEFT},\n      craft.RIGHT: {'delta': (1, 0), 'dir': craft.RIGHT}\n  }\n  move_actions = list(action_effects.keys())\n\n  # This mapping is used to determine the coordinates of the cell in front of the agent.\n  dir_to_delta = {effect['dir']: effect['delta'] for effect in action_effects.values()}\n\n  # 3. Setup BFS algorithm\n  # A state in the queue is: ((x, y), dir, path_list)\n  queue = deque([(start_pos, start_dir, [])])\n  # A visited state is a unique combination of position and direction.\n  visited = {(start_pos, start_dir)}\n\n  def is_blocked(x, y):\n    \"\"\"A cell is blocked if it is not empty.\"\"\"\n    return np.any(grid[x, y] > 0)\n\n  # 4. Run BFS\n  while queue:\n    (x, y), dir, path = queue.popleft()\n\n    # --- Goal Check ---\n    # Check if the agent is currently facing the primitive.\n    if dir in dir_to_delta:\n      front_dx, front_dy = dir_to_delta[dir]\n      front_x, front_y = x + front_dx, y + front_dy\n\n      if (0 <= front_x < width and 0 <= front_y < height and\n              grid[front_x, front_y, primitive_index] > 0):\n        # If so, the path is complete. The next action is to USE.\n        return path + [craft.USE]\n\n    # --- Explore Neighbors (take a move action) ---\n    for action in move_actions:\n      effect = action_effects[action]\n      move_dx, move_dy = effect['delta']\n      \n      next_x, next_y = x + move_dx, y + move_dy\n      next_dir = effect['dir']\n      \n      next_pos = (next_x, next_y)\n      next_state = (next_pos, next_dir)\n\n      # Check if the potential next state is valid for exploration.\n      if (0 <= next_x < width and 0 <= next_y < height and\n              next_state not in visited and not is_blocked(next_x, next_y)):\n        \n        visited.add(next_state)\n        new_path = path + [action]\n        queue.append((next_pos, next_dir, new_path))\n  \n  # If the queue is exhausted, no path to collect the primitive exists.\n  return []\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path to a state (position and direction) from which the agent can \n  successfully collect the target primitive.\n\n  The state in the BFS is represented as `(position, direction, path)`, as the\n  agent's direction is crucial for the 'USE' action. A cell is considered\n  blocked and unwalkable if it contains any item.\n\n  The algorithm works as follows:\n  1. Identify all locations of the target `primitive` on the grid.\n  2. For each target location, determine the required adjacent positions and \n     facing directions for the agent to be able to collect it. These are the \"goal states\".\n  3. Perform a BFS starting from the agent's initial state `(pos, dir)`. The\n     search expands through empty cells, tracking the path of actions taken.\n  4. The search terminates when it finds the shortest sequence of moves that\n     lands the agent in one of the pre-calculated goal states.\n  5. The final action sequence is the path of moves followed by the 'USE' action.\n  \"\"\"\n  \n  # 1. Setup: Extract current state information from the environment.\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the world's item list.\n    return []\n  start_pos = state.pos\n  start_dir = state.dir\n\n  # In this environment, the move action enums (e.g., craft.UP) also define\n  # the agent's new direction. This map defines the (dx, dy) vector for each.\n  action_vectors = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # 2. Identify all valid goal states (position, direction).\n  target_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  valid_goal_states = set()\n  \n  if target_locations.shape[0] == 0:\n      return [] # Primitive does not exist on the map.\n\n  for tx, ty in target_locations:\n      for action, (dx, dy) in action_vectors.items():\n          # To USE the item at (tx, ty), the agent must be at an adjacent\n          # position (ax, ay) and facing it. The facing vector is (dx, dy).\n          # So, the agent's position must be (ax, ay) = (tx - dx, ty - dy).\n          ax, ay = tx - dx, ty - dy\n          \n          # The required direction `dir` is the same as the `action` enum.\n          goal_dir = action\n          \n          # A goal state is only valid if the agent can stand on that spot.\n          if 0 <= ax < width and 0 <= ay < height and np.sum(grid[ax, ay, :]) == 0:\n              valid_goal_states.add(((ax, ay), goal_dir))\n\n  if not valid_goal_states:\n      return [] # No accessible spot to collect the primitive from.\n\n  # 3. Pathfind with state-aware Breadth-First Search (BFS).\n  # The state for the search is (position, direction, path_of_actions).\n  queue = deque([(start_pos, start_dir, [])])\n  # The visited set must track both position and direction to find correct paths.\n  visited = set([(start_pos, start_dir)])\n\n  # Handle the edge case where the agent starts in a goal state.\n  if (start_pos, start_dir) in valid_goal_states:\n      return [craft.USE]\n\n  while queue:\n      (x, y), current_dir, path = queue.popleft()\n\n      # Explore all possible moves from the current state.\n      for action, (dx, dy) in action_vectors.items():\n          next_x, next_y = x + dx, y + dy\n          next_dir = action  # After moving, the new direction is the action taken.\n          \n          # Create the next state tuple.\n          next_state_tuple = ((next_x, next_y), next_dir)\n\n          # Check if the potential next state is valid to visit.\n          if 0 <= next_x < width and 0 <= next_y < height and next_state_tuple not in visited:\n              \n              # The agent can only move into empty cells.\n              if np.sum(grid[next_x, next_y, :]) > 0:\n                  continue\n              \n              # We have found a valid new state to explore.\n              new_path = path + [action]\n\n              # Check if this new state is a goal state.\n              if next_state_tuple in valid_goal_states:\n                  # Found the shortest path.\n                  return new_path + [craft.USE]\n              \n              # If not a goal, add it to the queue for further exploration.\n              visited.add(next_state_tuple)\n              queue.append((next_state_tuple[0], next_state_tuple[1], new_path))\n              \n  return [] # No path found.\n\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a state where the agent is positioned on an empty cell\n  adjacent to the target primitive and is facing it. By including the agent's\n  direction in the search state `(position, direction, path)`, it correctly\n  handles the game's mechanic that the 'USE' action is directional.\n\n  Args:\n    env: The CraftLab environment instance, which wraps the game state.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n    A list of action integers representing the optimal plan to collect the\n    primitive. Returns an empty list if the primitive is unreachable.\n  \"\"\"\n  # 1. Initialization\n  current_state = env._current_state\n  grid = current_state.grid\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive does not exist in the game's cookbook.\n    return []\n\n  # 2. Define Game Mechanics for Pathfinding\n  # Mappings to interpret agent direction and action effects.\n  # Assumed mapping: 0:Right(+x), 1:Up(+y), 2:Left(-x), 3:Down(-y)\n  dir_to_vec = {\n      0: (1, 0),    # Right (East)\n      1: (0, 1),    # Up (North)\n      2: (-1, 0),   # Left (West)\n      3: (0, -1),   # Down (South)\n  }\n\n  action_effects = {\n      craft.RIGHT: ((1, 0), 0),\n      craft.UP:    ((0, 1), 1),\n      craft.LEFT:  ((-1, 0), 2),\n      craft.DOWN:  ((0, -1), 3),\n  }\n\n  grid_width, grid_height = grid.shape[0], grid.shape[1]\n\n  # Helper function to determine if a cell is blocked (impassable).\n  # According to the rules, any non-empty cell is blocked.\n  def is_blocked(x, y):\n    return np.any(grid[x, y] > 0)\n\n  # 3. Breadth-First Search (BFS)\n  # The queue stores tuples of (position, direction, path).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  \n  # The visited set stores (position, direction) to avoid redundant searches.\n  visited = {(start_pos, start_dir)}\n\n  while queue:\n    (x, y), direction, path = queue.popleft()\n\n    # --- Goal Check ---\n    # Check if the agent is currently facing the target primitive.\n    if direction in dir_to_vec:\n      vec_x, vec_y = dir_to_vec[direction]\n      facing_x, facing_y = x + vec_x, y + vec_y\n\n      # Ensure facing coordinates are within grid bounds.\n      if 0 <= facing_x < grid_width and 0 <= facing_y < grid_height:\n        # If the facing cell contains the primitive, we have found a valid plan.\n        if grid[facing_x, facing_y, primitive_index] > 0:\n          return path + [craft.USE]\n\n    # --- State Expansion ---\n    # If goal not met, try all four move actions from the current state.\n    for action, ((dx, dy), new_dir) in action_effects.items():\n      next_x, next_y = x + dx, y + dy\n      \n      new_state = ((next_x, next_y), new_dir)\n\n      # Check if the new state is valid:\n      # a) Within grid boundaries.\n      # b) Destination cell is not blocked (is empty).\n      # c) This exact (position, direction) state has not been visited yet.\n      if 0 <= next_x < grid_width and 0 <= next_y < grid_height and \\\n         not is_blocked(next_x, next_y) and \\\n         new_state not in visited:\n        \n        visited.add(new_state)\n        new_path = path + [action]\n        queue.append(((next_x, next_y), new_dir, new_path))\n            \n  # If the queue is exhausted, the primitive is unreachable.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Calculates the shortest sequence of actions to navigate to and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path from the agent's current position to a location adjacent to the\n  target primitive, with the correct orientation to collect it.\n\n  The state in the BFS queue is represented as a tuple (x, y, direction, path),\n  ensuring that the agent's facing direction is tracked throughout the search.\n  This correctly models the game's mechanics where movement and orientation are linked,\n  and collection is a directional action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the shortest plan to collect the\n    primitive. Returns an empty list if no path is found.\n  \"\"\"\n  \n  # Action constants are assumed to be defined in the craft module.\n  # craft.UP = 1, craft.RIGHT = 3, craft.DOWN = 0, craft.LEFT = 2, craft.USE = 4\n  # Note: The problem description has conflicting info. \n  # action_specs() maps DOWN->0, UP->1, LEFT->2, RIGHT->3.\n  # The agent's dir is 0:UP, 1:RIGHT, 2:DOWN, 3:LEFT.\n  # We will align with the agent's 'dir' for clarity.\n  \n  # Mapping from an action to the resulting agent direction\n  ACTION_TO_DIR = {\n      craft.UP: 0,\n      craft.RIGHT: 1,\n      craft.DOWN: 2,\n      craft.LEFT: 3\n  }\n\n  # Mapping from an action to the change in coordinates (dx, dy)\n  ACTION_TO_DELTA = {\n      craft.UP: (0, 1),\n      craft.RIGHT: (1, 0),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0)\n  }\n\n  # Mapping from a direction (dir) to the change in coordinates (dx, dy)\n  DIR_TO_DELTA = {\n      0: (0, 1),    # UP\n      1: (1, 0),    # RIGHT\n      2: (0, -1),   # DOWN\n      3: (-1, 0)    # LEFT\n  }\n  \n  # 1. Get initial state & target info\n  state = env._current_state\n  grid = state.grid\n  cookbook = env.world.cookbook\n  \n  primitive_index = cookbook.index[primitive]\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  grid_w, grid_h, _ = grid.shape\n\n  # 2. Pathfinding setup\n  # BFS state is a tuple: (x, y, direction, path_list)\n  queue = collections.deque([(start_pos[0], start_pos[1], start_dir, [])])\n  \n  # Visited set stores (x, y, direction) tuples to avoid cycles and redundant exploration\n  visited = set([(start_pos[0], start_pos[1], start_dir)])\n\n  # 3. BFS Loop\n  while queue:\n      x, y, agent_dir, path = queue.popleft()\n\n      # 3a. Check for Goal Condition: Is the agent facing the primitive?\n      # Get the coordinates of the cell the agent is currently facing\n      face_dx, face_dy = DIR_TO_DELTA[agent_dir]\n      facing_x, facing_y = x + face_dx, y + face_dy\n\n      # Check if the facing cell is within bounds and contains the target primitive\n      if 0 <= facing_x < grid_w and 0 <= facing_y < grid_h:\n          if grid[facing_x, facing_y, primitive_index] > 0:\n              # Goal reached: The agent is in the correct position and orientation.\n              # The final action is to USE.\n              return path + [craft.USE]\n\n      # 3b. Expand Neighbors: Try taking each possible move action\n      for action in [craft.UP, craft.RIGHT, craft.DOWN, craft.LEFT]:\n          # Calculate the potential new state resulting from this action\n          new_dir = ACTION_TO_DIR[action]\n          move_dx, move_dy = ACTION_TO_DELTA[action]\n          new_x, new_y = x + move_dx, y + move_dy\n          \n          new_state_tuple = (new_x, new_y, new_dir)\n\n          # Check validity of the potential new state\n          if 0 <= new_x < grid_w and 0 <= new_y < grid_h: # Is it within bounds?\n              # Is the destination cell empty (not blocked)?\n              if not np.any(grid[new_x, new_y]):\n                  if new_state_tuple not in visited:\n                      visited.add(new_state_tuple)\n                      new_path = path + [action]\n                      queue.append((new_x, new_y, new_dir, new_path))\n  \n  # 4. If the queue becomes empty, no path was found\n  return []\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a state where the agent is adjacent to the target primitive\n  and facing it. The agent can only move through empty cells, and the final\n  'USE' action is directed at the cell the agent is facing.\n\n  Args:\n      env: The environment instance, providing access to the current state.\n      primitive: The string name of the primitive to collect.\n\n  Returns:\n      A list of action integers representing the plan (e.g., [MOVE, MOVE, USE]),\n      or an empty list if no path can be found.\n  \"\"\"\n  # 1. SETUP\n  state = env._current_state\n  grid = state.grid\n  cookbook = env.world.cookbook\n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    # If the primitive name is not in the cookbook, no plan can be made.\n    return []\n\n  start_pos = state.pos\n  start_dir = state.dir\n  grid_w, grid_h, _ = grid.shape\n\n  # Define movement vectors and the corresponding actions and resulting directions.\n  # This mapping is derived from conventions in the provided solution candidates.\n  # dir: 0=DOWN, 1=UP, 2=LEFT, 3=RIGHT\n  action_info = {\n      craft.UP:    {'vec': (0, 1),  'dir': 1},\n      craft.DOWN:  {'vec': (0, -1), 'dir': 0},\n      craft.LEFT:  {'vec': (-1, 0), 'dir': 2},\n      craft.RIGHT: {'vec': (1, 0), 'dir': 3},\n  }\n  dir_to_vec = {info['dir']: info['vec'] for _, info in action_info.items()}\n\n  def is_blocked(x, y):\n    \"\"\"A cell is considered blocked if it contains any item.\"\"\"\n    return np.any(grid[x, y] > 0)\n\n  # 2. INITIAL CHECK (Optimization)\n  # Check if the agent is already facing the primitive from its start position.\n  start_dir_vec = dir_to_vec.get(start_dir)\n  if start_dir_vec:\n    fx, fy = start_pos[0] + start_dir_vec[0], start_pos[1] + start_dir_vec[1]\n    if 0 <= fx < grid_w and 0 <= fy < grid_h and grid[fx, fy, primitive_index] > 0:\n      return [craft.USE]\n\n  # 3. BFS PATHFINDING\n  # The BFS finds a path to an empty cell from which a subsequent move will\n  # result in the agent facing the primitive.\n  # Queue stores: (current_x, current_y, path_to_get_here)\n  queue = collections.deque([(start_pos[0], start_pos[1], [])])\n  # Visited stores positions (x, y) to avoid cycles and redundant exploration.\n  visited = {start_pos}\n\n  while queue:\n    x, y, path = queue.popleft()\n\n    # From (x, y), evaluate all possible single moves.\n    for action, info in action_info.items():\n      vec = info['vec']\n      # nx, ny is the cell the agent would move into.\n      nx, ny = x + vec[0], y + vec[1]\n\n      # Condition 1: Is this a valid cell to move into?\n      if not (0 <= nx < grid_w and 0 <= ny < grid_h):\n        continue\n      if (nx, ny) in visited:\n        continue\n      if is_blocked(nx, ny):\n        continue\n      \n      # After moving to (nx, ny), the agent faces in the direction of the move.\n      # The cell in front of it would then be: (nx, ny) + vec\n      facing_x, facing_y = nx + vec[0], ny + vec[1]\n\n      # Condition 2: Does this move result in facing the primitive?\n      if (0 <= facing_x < grid_w and 0 <= facing_y < grid_h and\n              grid[facing_x, facing_y, primitive_index] > 0):\n        # Success. The plan is the path to the previous cell,\n        # the action to move and face the primitive, and then USE.\n        return path + [action, craft.USE]\n\n      # This move does not lead to collection, so add it to the queue for further exploration.\n      visited.add((nx, ny))\n      queue.append((nx, ny, path + [action]))\n      \n  # If the queue is exhausted and no path was found\n  return []\n",
  "evaluation_result": [
    1.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a robust pathfinding strategy that respects the game's\n  rules about movement and agent orientation. It uses Breadth-First Search (BFS)\n  to find the shortest path to a position from which the agent can move into an\n  adjacent square while facing the target primitive, and then collect it.\n\n  The strategy is as follows:\n  1.  Identify all locations of the target primitive.\n  2.  For each target, determine the valid \"pre-approach\" positions. A pre-approach\n      position is an empty cell from which a single move will land the agent on\n      another empty cell adjacent to the target, correctly oriented to face it.\n  3.  Run a single BFS starting from the agent's current position to find the\n      shortest path to any of these pre-approach positions.\n  4.  Once a path is found, append the final move (to get to the adjacent cell)\n      and the USE action.\n  5.  This approach correctly handles the \"facing\" requirement for the USE action\n      and respects the rule that non-empty cells are blocked for movement.\n  \"\"\"\n\n  # --- 1. Initialization and State Extraction ---\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive name is not valid\n    return []\n    \n  width, height, _ = grid.shape\n\n  # --- 2. Helper Definitions ---\n\n  def is_traversable(x, y):\n    \"\"\"Checks if a cell at (x, y) is empty and within grid bounds.\"\"\"\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is traversable only if it is completely empty.\n    return np.sum(grid[x, y]) == 0\n\n  # Action constants are mapped to their effect on (x, y) coordinates\n  action_to_delta = {\n      craft.UP:    (0, 1),\n      craft.DOWN:  (0, -1),\n      craft.LEFT:  (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # --- 3. Identify BFS Goal States (Pre-Approach Positions) ---\n  \n  # `destinations` maps a goal position {pos: [final_actions]}\n  # E.g., {(3,5): [RIGHT, USE]} means if we reach (3,5), we then move RIGHT and USE.\n  destinations = {}\n  target_coords = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  if target_coords.shape[0] == 0:\n    return [] # Primitive does not exist on the map.\n\n  for tx, ty in target_coords:\n    # To collect, agent must be at an adjacent cell (ax,ay) and USE, facing (tx,ty).\n    # This requires moving from a pre-adjacent cell (px,py) to (ax,ay).\n    \n    # Approach from LEFT: land on (tx-1, ty) by moving RIGHT from (tx-2, ty)\n    if is_traversable(tx - 1, ty) and is_traversable(tx - 2, ty):\n        destinations[(tx - 2, ty)] = [craft.RIGHT, craft.USE]\n\n    # Approach from RIGHT: land on (tx+1, ty) by moving LEFT from (tx+2, ty)\n    if is_traversable(tx + 1, ty) and is_traversable(tx + 2, ty):\n        destinations[(tx + 2, ty)] = [craft.LEFT, craft.USE]\n        \n    # Approach from BELOW: land on (tx, ty-1) by moving UP from (tx, ty-2)\n    if is_traversable(tx, ty - 1) and is_traversable(tx, ty - 2):\n        destinations[(tx, ty - 2)] = [craft.UP, craft.USE]\n\n    # Approach from ABOVE: land on (tx, ty+1) by moving DOWN from (tx, ty+2)\n    if is_traversable(tx, ty + 1) and is_traversable(tx, ty + 2):\n        destinations[(tx, ty + 2)] = [craft.DOWN, craft.USE]\n\n  if not destinations:\n    return [] # No accessible spot from which to collect the primitive.\n\n  # Handle the edge case where the agent already starts at a pre-approach spot.\n  if start_pos in destinations:\n    return destinations[start_pos]\n\n  # --- 4. Run Breadth-First Search (BFS) ---\n  \n  # The queue stores tuples of ((x, y), path_list)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n    (x, y), path = queue.popleft()\n\n    # Explore neighbors\n    for move_action, (dx, dy) in action_to_delta.items():\n      nx, ny = x + dx, y + dy\n      neighbor_pos = (nx, ny)\n\n      # Check if the neighbor is a goal state for the BFS\n      if neighbor_pos in destinations:\n        final_actions = destinations[neighbor_pos]\n        return path + [move_action] + final_actions\n      \n      # If not a goal, check if it's a valid cell for continuing the path\n      if neighbor_pos not in visited and is_traversable(nx, ny):\n        visited.add(neighbor_pos)\n        new_path = path + [move_action]\n        queue.append((neighbor_pos, new_path))\n  \n  return [] # No path could be found\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  The strategy is to find the shortest path to a state (position and direction)\n  from which the agent is facing an adjacent cell containing the target primitive.\n  This is solved using a Breadth-First Search (BFS) over states of the form (x, y, dir).\n\n  Args:\n      env: The CraftLab environment instance, which wraps the game state.\n      primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n      A list of action integers to collect the primitive, or an empty list if\n      unachievable.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  world = env.world\n  cookbook = world.cookbook\n\n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    # The primitive name is not valid according to the cookbook.\n    return []\n\n  # --- Mappings for BFS State Transitions ---\n  # These mappings translate between action constants, movement vectors, and direction indices.\n  # Based on the API, we assume the agent's direction `dir` is an integer index.\n  # A common convention is 0:UP, 1:DOWN, 2:LEFT, 3:RIGHT.\n  \n  # Map action constants to (dx, dy) movement vectors in a standard cartesian grid.\n  action_to_move = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # Map action constants to the direction index they produce.\n  # We assume executing a move action sets the agent's direction accordingly.\n  action_to_dir = {\n      craft.UP: 0,\n      craft.DOWN: 1,\n      craft.LEFT: 2,\n      craft.RIGHT: 3,\n  }\n\n  # Map internal direction indices to (dx, dy) facing vectors.\n  dir_to_vec = {\n      0: (0, 1),   # UP\n      1: (0, -1),  # DOWN\n      2: (-1, 0),  # LEFT\n      3: (1, 0),   # RIGHT\n  }\n\n  grid_width, grid_height, _ = grid.shape\n  start_pos = state.pos\n  start_dir = state.dir\n\n  # BFS state is a tuple: (position, direction, path_list)\n  queue = collections.deque([(start_pos, start_dir, [])])\n  \n  # Visited set stores (position, direction) tuples to avoid redundant exploration.\n  visited = set([(start_pos, start_dir)])\n\n  def is_blocked(x, y):\n    # Per the game description, any non-empty cell is blocked for movement.\n    return np.sum(grid[x, y]) > 0\n\n  while queue:\n    pos, direction, path = queue.popleft()\n    (x, y) = pos\n\n    # --- Target Condition Check ---\n    # Check if the cell IN FRONT of the agent's current state contains the primitive.\n    face_vec = dir_to_vec[direction]\n    front_x, front_y = x + face_vec[0], y + face_vec[1]\n\n    # Check if the front cell is within grid bounds.\n    if 0 <= front_x < grid_width and 0 <= front_y < grid_height:\n      if grid[front_x, front_y, primitive_index] > 0:\n        # Success! The current path leads to a state where we can USE the primitive.\n        return path + [craft.USE]\n\n    # --- Exploration Step (Expand Neighbors) ---\n    # Try taking each of the 4 move actions from the current state.\n    for action, move_vec in action_to_move.items():\n      next_x, next_y = x + move_vec[0], y + move_vec[1]\n      next_pos = (next_x, next_y)\n      next_dir = action_to_dir[action]\n      next_state = (next_pos, next_dir)\n\n      # 1. Boundary Check: Ensure the next position is on the grid.\n      if not (0 <= next_x < grid_width and 0 <= next_y < grid_height):\n        continue\n      \n      # 2. Blocked Cell Check: Agent can only move into empty cells.\n      if is_blocked(next_x, next_y):\n        continue\n\n      # 3. Visited Check: Only explore new (pos, dir) states.\n      if next_state not in visited:\n        visited.add(next_state)\n        new_path = path + [action]\n        queue.append((next_pos, next_dir, new_path))\n\n  # If the queue becomes empty, no path was found to collect the primitive.\n  return []\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates an optimal action sequence to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path from the agent's current state to a state where it is adjacent \n  to and facing the target primitive.\n\n  The state representation in the BFS is (position, direction), which is crucial \n  for ensuring the final 'USE' action is valid. The search explores possible \n  move actions (UP, DOWN, LEFT, RIGHT), treating any non-empty cell as an \n  impassable obstacle for movement.\n\n  Args:\n    env: The environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the shortest plan to collect the \n    primitive. Returns an empty list if no path is found.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos    # Assumed to be (x, y)\n  start_dir = state.dir\n  \n  primitive_index = env.world.cookbook.index[primitive]\n  grid_width, grid_height = grid.shape[0], grid.shape[1]\n\n  # Action constants are defined in the craft module.\n  # If running standalone, these values can be assumed based on action_specs().\n  if not hasattr(craft, 'USE'):\n      craft.DOWN, craft.UP, craft.LEFT, craft.RIGHT, craft.USE = 0, 1, 2, 3, 4\n\n  # Deltas map a direction to a coordinate change (dx, dy).\n  # Based on action_specs, we assume: DOWN:0, UP:1, LEFT:2, RIGHT:3.\n  # We also assume standard grid coordinates where y increases downwards.\n  dir_deltas = {\n      craft.UP:    (0, -1),\n      craft.DOWN:  (0, 1),\n      craft.LEFT:  (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  \n  # The BFS queue stores tuples of ( (x, y), direction, path_list ).\n  queue = collections.deque([(start_pos, start_dir, [])])\n  \n  # The visited set stores tuples of ( (x, y), direction ) to avoid cycles.\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n      (x, y), direction, path = queue.popleft()\n\n      # 1. Check for Termination: Can we USE from the current state?\n      # Calculate the coordinates of the cell in front of the agent.\n      front_dx, front_dy = dir_deltas.get(direction, (0, 0))\n      fx, fy = x + front_dx, y + front_dy\n\n      # Check if the front cell is in-bounds and contains the primitive.\n      if 0 <= fx < grid_width and 0 <= fy < grid_height:\n          # Numpy grids are typically indexed (row, col), which corresponds to (y, x).\n          if grid[fx, fy, primitive_index] > 0:\n              return path + [craft.USE]\n\n      # 2. Explore Neighbors: Try all possible move actions.\n      move_actions = [craft.UP, craft.DOWN, craft.LEFT, craft.RIGHT]\n      for action in move_actions:\n          # A move action determines the new position and new direction.\n          move_dx, move_dy = dir_deltas[action]\n          nx, ny = x + move_dx, y + move_dy\n          new_dir = action\n          \n          # Check if the destination is in-bounds.\n          if 0 <= nx < grid_width and 0 <= ny < grid_height:\n              # The agent can only move into completely empty cells.\n              if not np.any(grid[nx, ny, :]):\n                  new_state = ((nx, ny), new_dir)\n                  if new_state not in visited:\n                      visited.add(new_state)\n                      new_path = path + [action]\n                      queue.append(((nx, ny), new_dir, new_path))\n  \n  # Return an empty list if the queue is exhausted and no path was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find the shortest path to a primitive,\n  face it, and collect it using the 'USE' action.\n\n  This strategy uses Breadth-First Search (BFS) to explore the grid for the\n  shortest path to an empty cell adjacent to the target primitive. It relies on the\n  game mechanic that attempting to move into a blocked cell (like one containing\n  a primitive) fails to change the agent's position but successfully changes its\n  direction to face that cell, allowing the subsequent 'USE' action to succeed.\n\n  The algorithm proceeds as follows:\n  1. Identify the target primitive's index and the agent's starting position.\n  2. Initialize a queue for BFS with the starting position and an empty path.\n  3. Use a 'visited' set to avoid re-exploring empty cells.\n  4. In the main BFS loop, for each cell taken from the queue, check its neighbors:\n      a. If a neighbor contains the target primitive, the search is complete. The\n          final action sequence is the path to the current cell, followed by a\n          move action towards the primitive (to turn and face it), and finally\n          the 'USE' action.\n      b. If a neighbor is empty and unvisited, it's a valid next step. Add it\n          to the queue and the 'visited' set to explore from it later.\n  5. If the queue is exhausted and no path is found, the primitive is unreachable.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  grid_width, grid_height, _ = grid.shape\n\n  try:\n    primitive_index = state.world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive name is not valid in the game's cookbook.\n    return []\n\n  # Define moves as a mapping from coordinate change (dx, dy) to action constant.\n  action_map = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n\n  # Helper function to check if a cell is empty and thus traversable.\n  # A cell is blocked if it contains any item.\n  def is_traversable(x, y):\n    return np.sum(grid[x, y]) == 0\n\n  # Early exit optimization: check if we are already adjacent to the primitive.\n  for (dx, dy), action in action_map.items():\n    adj_x, adj_y = start_pos[0] + dx, start_pos[1] + dy\n    if 0 <= adj_x < grid_width and 0 <= adj_y < grid_height:\n      if grid[adj_x, adj_y, primitive_index] > 0:\n        # Already next to it. Just need to turn and use.\n        return [action, craft.USE]\n\n  # Initialize BFS queue with (position, path) and a set for visited positions.\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  # Main BFS loop to find the shortest path to an adjacent cell.\n  while queue:\n    (x, y), path = queue.popleft()\n\n    # Explore neighbors of the current cell (x, y).\n    for (dx, dy), move_action in action_map.items():\n      nx, ny = x + dx, y + dy\n\n      # Check if the neighbor is within grid bounds.\n      if not (0 <= nx < grid_width and 0 <= ny < grid_height):\n        continue\n\n      # GOAL CONDITION: Is the neighbor cell the primitive we're looking for?\n      if grid[nx, ny, primitive_index] > 0:\n        # Path found. The sequence is: path to current cell,\n        # a final move action to turn towards the primitive, and then the USE action.\n        return path + [move_action, craft.USE]\n\n      # EXPANSION CONDITION: Is the neighbor a valid, unvisited, traversable cell?\n      if (nx, ny) not in visited and is_traversable(nx, ny):\n        visited.add((nx, ny))\n        new_path = path + [move_action]\n        queue.append(((nx, ny), new_path))\n            \n  # If the queue is exhausted, the primitive is unreachable.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
