{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    face it, and craft the specified item.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    valid path to a cell adjacent to the required workshop.\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n    height, width, _ = grid.shape\n    \n    # 1. Identify the required workshop from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'\")\n    \n    recipe = cookbook.recipes[item_idx]\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop (_key)\")\n\n    workshop_name = recipe[\"_key\"]\n    required_workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all locations of the required workshop\n    workshop_locations = set(map(tuple, np.argwhere(grid[:, :, required_workshop_idx] == 1)))\n    if not workshop_locations:\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    # 3. Use BFS to find the shortest path to an adjacent cell\n    start_pos = tuple(state.pos)\n    \n    # The queue stores tuples of (position, path_of_actions)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n\n    # Action mappings: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    # Move mappings: (dx, dy) -> action\n    moves = {\n        (0, -1): 0,  # Down\n        (0, 1): 1,   # Up\n        (-1, 0): 2,  # Left\n        (1, 0): 3,   # Right\n    }\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        # Check neighbors of the current position\n        for (dx, dy), action in moves.items():\n            nx, ny = x + dx, y + dy\n            \n            # If the neighbor is a workshop, we've found our destination\n            if (nx, ny) in workshop_locations:\n                final_path = path[:]\n                # The agent is at (x, y) and needs to face (nx, ny)\n                # The 'action' to get from (x,y) to (nx,ny) is the correct facing direction\n                final_path.append(action) # Action to face the workshop\n                final_path.append(4)      # USE action\n                return final_path\n\n            # Check if the neighbor is a valid, unvisited, and empty cell to move to\n            is_within_bounds = (0 <= nx < width) and (0 <= ny < height)\n            if is_within_bounds and (nx, ny) not in visited:\n                # A cell is empty if the sum of its feature vector is 0\n                is_empty = grid[nx, ny, :].sum() == 0\n                if is_empty:\n                    visited.add((nx, ny))\n                    new_path = path + [action]\n                    queue.append(((nx, ny), new_path))\n    \n    # If the queue becomes empty, no path was found\n    raise ValueError(f\"Cannot find a path to workshop '{workshop_name}' for crafting '{item}'.\")\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    craft a specific item, and handles pathfinding around obstacles.\n    \"\"\"\n\n    def bfs_pathfinding(grid, start, end):\n        \"\"\"\n        Finds the shortest path from start to end on the grid using BFS.\n        Returns a list of actions or None if no path exists.\n        \"\"\"\n        q = collections.deque([(start, [])])  # (position, path_of_actions)\n        visited = {start}\n\n        # Action map: 0: DOWN, 1: UP, 2: LEFT, 3: RIGHT\n        # Corresponds to changes in (x, y) coordinates\n        moves = {\n            (1, 0): 3,   # RIGHT\n            (-1, 0): 2,  # LEFT\n            (0, 1): 1,   # UP\n            (0, -1): 0   # DOWN\n        }\n\n        width, height, _ = grid.shape\n\n        while q:\n            (curr_x, curr_y), path = q.popleft()\n\n            if (curr_x, curr_y) == end:\n                return path\n\n            for (dx, dy), action in moves.items():\n                next_x, next_y = curr_x + dx, curr_y + dy\n                next_pos = (next_x, next_y)\n\n                if 0 <= next_x < width and 0 <= next_y < height and next_pos not in visited:\n                    # A cell is walkable if it's empty.\n                    # The destination is also considered walkable even if occupied (e.g., by the agent at the start).\n                    is_walkable = grid[next_x, next_y, :].sum() == 0 or next_pos == end\n                    if is_walkable:\n                        visited.add(next_pos)\n                        new_path = path + [action]\n                        q.append((next_pos, new_path))\n        return None  # No path found\n\n    # 1. Identify the correct workshop from the recipe\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n    \n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'\")\n    recipe = cookbook.recipes[goal_index]\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n    required_workshop_idx = recipe[\"_key\"]\n\n    grid = env._current_state.grid\n    agent_pos = env._current_state.pos\n\n    # 2. Find all instances of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found on the grid.\")\n\n    # 3. Find the closest, accessible, empty cell adjacent to any required workshop\n    possible_targets = []\n    for ws_pos in workshop_locations:\n        # Check 4-connectivity neighbors\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            adj_pos = (ws_pos[0] + dx, ws_pos[1] + dy)\n            # Check grid bounds\n            if 0 <= adj_pos[0] < grid.shape[0] and 0 <= adj_pos[1] < grid.shape[1]:\n                # A cell is a valid destination if it's empty or the agent is already on it\n                if grid[adj_pos].sum() == 0 or adj_pos == agent_pos:\n                    dist = abs(adj_pos[0] - agent_pos[0]) + abs(adj_pos[1] - agent_pos[1])\n                    possible_targets.append({'dest': adj_pos, 'workshop': tuple(ws_pos), 'dist': dist})\n    \n    if not possible_targets:\n        raise RuntimeError(f\"No accessible spots next to a workshop for '{item}'.\")\n\n    # Sort targets by distance to find the best one\n    possible_targets.sort(key=lambda t: t['dist'])\n    best_target = possible_targets[0]\n    final_destination = best_target['dest']\n    target_workshop_pos = best_target['workshop']\n\n    # 4. Find a path to the destination\n    if agent_pos == final_destination:\n        actions = []\n    else:\n        actions = bfs_pathfinding(grid, agent_pos, final_destination)\n        if actions is None:\n            raise RuntimeError(f\"Cannot find a path to the workshop for '{item}'.\")\n    \n    # 5. Determine orientation and add USE action\n    # The agent is now at final_destination. It needs to face the workshop.\n    dx = target_workshop_pos[0] - final_destination[0]\n    dy = target_workshop_pos[1] - final_destination[1]\n\n    # Append the action that makes the agent face the workshop\n    if dx == 1 and dy == 0:\n        actions.append(3)  # Face RIGHT\n    elif dx == -1 and dy == 0:\n        actions.append(2)  # Face LEFT\n    elif dx == 0 and dy == 1:\n        actions.append(1)  # Face UP\n    elif dx == 0 and dy == -1:\n        actions.append(0)  # Face DOWN\n    \n    actions.append(4)  # USE the workshop\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop, face it, and craft the specified item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of integer actions to be executed.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n\n    # Step 1: Find the required workshop for the given item from the cookbook.\n    goal_idx = cookbook.index[item]\n    if goal_idx is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook index.\")\n    \n    recipe = cookbook.recipes.get(goal_idx)\n    if recipe is None:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n\n    # The required workshop is specified by the '_key' in the recipe.\n    required_workshop_idx = recipe.get('_key')\n    if required_workshop_idx is None:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n\n    # Step 2: Find all locations of the required workshop on the grid.\n    workshop_locations = set(map(tuple, np.argwhere(state.grid[:, :, required_workshop_idx])))\n    if not workshop_locations:\n        raise ValueError(f\"Required workshop for '{item}' not found in the current environment.\")\n\n    # Step 3: Use Breadth-First Search (BFS) to find the shortest path to an adjacent empty cell.\n    # The grid is (width, height, kinds), but numpy array indexing is (row, col).\n    # Position is (x, y) which corresponds to (col, row). Let's use (row, col) for consistency with numpy.\n    start_pos = (state.pos[1], state.pos[0]) # Convert (x, y) to (row, col)\n    \n    # Action mapping: 0:DOWN (+row), 1:UP (-row), 2:LEFT (-col), 3:RIGHT (+col)\n    # Deltas for (row, col)\n    moves = {\n        0: (1, 0),   # DOWN\n        1: (-1, 0),  # UP\n        2: (0, -1),  # LEFT\n        3: (0, 1)    # RIGHT\n    }\n\n    queue = collections.deque([(start_pos, [])]) # (position, path_list)\n    visited = {start_pos}\n\n    path_to_target = None\n    target_pos = None\n    final_workshop_pos = None\n\n    # The grid is non-empty where the sum across kinds is > 0\n    # An empty cell has a sum of 0.\n    is_blocked = state.grid.sum(axis=2) > 0\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        # Check if current_pos is adjacent to a required workshop\n        for action, (dr, dc) in moves.items():\n            neighbor_pos = (current_pos[0] + dr, current_pos[1] + dc)\n            if neighbor_pos in workshop_locations:\n                path_to_target = path\n                target_pos = current_pos\n                final_workshop_pos = neighbor_pos\n                queue.clear() # Target found, exit BFS\n                break\n        if path_to_target is not None:\n            break\n\n        # Explore neighbors\n        for action, (dr, dc) in moves.items():\n            next_pos = (current_pos[0] + dr, current_pos[1] + dc)\n            \n            # Check bounds\n            if not (0 <= next_pos[0] < state.grid.shape[1] and 0 <= next_pos[1] < state.grid.shape[0]):\n                continue\n            \n            # Check if visited or blocked\n            if next_pos in visited or is_blocked[next_pos[1], next_pos[0]]:\n                continue\n            \n            visited.add(next_pos)\n            new_path = path + [action]\n            queue.append((next_pos, new_path))\n            \n    if path_to_target is None:\n        raise RuntimeError(f\"Could not find a path to the workshop for '{item}'.\")\n\n    # Step 4: Determine the final facing direction and add USE action.\n    actions = list(path_to_target)\n    \n    # Calculate direction from agent (target_pos) to workshop (final_workshop_pos)\n    dr = final_workshop_pos[0] - target_pos[0]\n    dc = final_workshop_pos[1] - target_pos[1]\n\n    if dr == 1: # Workshop is below\n        actions.append(0) # Face DOWN\n    elif dr == -1: # Workshop is above\n        actions.append(1) # Face UP\n    elif dc == 1: # Workshop is to the right\n        actions.append(3) # Face RIGHT\n    elif dc == -1: # Workshop is to the left\n        actions.append(2) # Face LEFT\n    \n    actions.append(4) # USE action\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft a specified item.\n\n    This function implements a multi-step process:\n    1.  Looks up the recipe for the given item to identify the specific workshop required.\n    2.  Scans the grid to find all instances of that required workshop.\n    3.  Calculates the closest workshop instance to the agent's current position.\n    4.  Identifies all valid (empty) cells adjacent to the target workshop. These are the possible destinations.\n    5.  Uses a Breadth-First Search (BFS) algorithm to find the shortest, obstacle-avoiding path from the agent's\n        current position to one of the valid destination cells.\n    6.  Determines the final turning action required to face the workshop from the destination cell.\n    7.  Assembles the full action sequence: a series of moves from the path, the final turn, and the 'USE' action.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft (e.g., 'plank', 'axe').\n\n    Returns:\n        list[int]: A list of integer actions to be executed sequentially. Returns an empty\n                   list if crafting is not possible (e.g., no workshop, no path).\n    \"\"\"\n    \n    # Helper function for pathfinding using Breadth-First Search (BFS)\n    def find_shortest_path(grid, start_pos, destinations):\n        width, height, _ = grid.shape\n        # A cell is blocked if any object is on it.\n        is_blocked = grid.sum(axis=2) > 0\n        \n        start_tuple = tuple(start_pos)\n        destination_set = set(tuple(d) for d in destinations)\n\n        # If already at a destination, no movement is needed.\n        if start_tuple in destination_set:\n            return [], start_tuple\n\n        # Queue stores tuples of (current_position, path_taken_so_far)\n        queue = collections.deque([(start_tuple, [])])\n        visited = {start_tuple}\n        \n        # Action map: action_id -> (dx, dy)\n        action_to_delta = {0: (0, -1), 1: (0, 1), 2: (-1, 0), 3: (1, 0)} # DOWN, UP, LEFT, RIGHT\n\n        while queue:\n            (curr_pos, path) = queue.popleft()\n\n            for action, (dx, dy) in action_to_delta.items():\n                next_pos = (curr_pos[0] + dx, curr_pos[1] + dy)\n\n                if next_pos in destination_set:\n                    # Found the shortest path to a destination\n                    return path + [action], next_pos\n\n                # Check if the next position is valid\n                if (0 <= next_pos[0] < width and\n                    0 <= next_pos[1] < height and\n                    next_pos not in visited and\n                    not is_blocked[next_pos[0], next_pos[1]]):\n                    \n                    visited.add(next_pos)\n                    queue.append((next_pos, path + [action]))\n        \n        # No path found\n        return None, None\n\n    # 1. Look up the recipe to find the required workshop\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        # This item cannot be crafted (it might be a primitive)\n        return []\n    \n    recipe = cookbook.recipes[goal_index]\n    workshop_name = recipe.get('_key')\n    if not workshop_name:\n        # Recipe does not specify a workshop\n        return []\n    \n    required_workshop_idx = cookbook.index[workshop_name]\n    \n    # 2. Find all locations of the required workshop on the grid\n    grid = env._current_state.grid\n    agent_pos = np.array(env._current_state.pos)\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    \n    if workshop_locations.size == 0:\n        # Required workshop does not exist on the map\n        return []\n\n    # 3. Find the closest workshop instance\n    distances = np.sum(np.abs(workshop_locations - agent_pos), axis=1)\n    closest_workshop_pos = workshop_locations[np.argmin(distances)]\n\n    # 4. Identify valid, empty destination cells adjacent to the workshop\n    width, height, _ = grid.shape\n    adjacent_destinations = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # UP, DOWN, RIGHT, LEFT\n        adj_pos = closest_workshop_pos + np.array([dx, dy])\n        if (0 <= adj_pos[0] < width and 0 <= adj_pos[1] < height and\n            grid[adj_pos[0], adj_pos[1]].sum() == 0):\n            adjacent_destinations.append(adj_pos)\n\n    if not adjacent_destinations:\n        # No accessible cells next to the closest workshop\n        return []\n    \n    # 5. Find the shortest path to one of the destination cells\n    path, final_agent_pos = find_shortest_path(grid, agent_pos, adjacent_destinations)\n    \n    if path is None:\n        # No path could be found to any destination\n        return []\n\n    # 6. Determine the final turn action to face the workshop\n    dx = closest_workshop_pos[0] - final_agent_pos[0]\n    dy = closest_workshop_pos[1] - final_agent_pos[1]\n\n    face_action = -1\n    if (dx, dy) == (0, 1): face_action = 1  # Face UP\n    elif (dx, dy) == (0, -1): face_action = 0 # Face DOWN\n    elif (dx, dy) == (1, 0): face_action = 3  # Face RIGHT\n    elif (dx, dy) == (-1, 0): face_action = 2 # Face LEFT\n    \n    # 7. Assemble the complete action sequence: move, turn, and use\n    actions = path + [face_action, 4]  # 4 is the USE action\n    \n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop, craft an item, and return.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of integer actions to be executed.\n                   Returns an empty list if crafting is not possible.\n    \"\"\"\n    world = env.world\n    state = env._current_state\n    cookbook = world.cookbook\n\n    # 1. Find the required workshop from the recipe\n    goal_idx = cookbook.index[item]\n    if goal_idx is None:\n        print(f\"Item '{item}' not found in cookbook index.\")\n        return []\n\n    recipe = cookbook.recipes.get(goal_idx)\n    if not recipe or '_key' not in recipe:\n        print(f\"No recipe or workshop specified for item '{item}'.\")\n        return []\n\n    workshop_name = recipe['_key']\n    workshop_idx = cookbook.index[workshop_name]\n    \n    # 2. Find all instances of the required workshop on the grid\n    grid = state.grid\n    workshop_positions = np.argwhere(grid[:, :, workshop_idx])\n\n    if workshop_positions.shape[0] == 0:\n        print(f\"Required workshop '{workshop_name}' not found on the map.\")\n        return []\n\n    # 3. Pathfind (BFS) to the nearest reachable cell adjacent to any workshop instance\n    \n    start_pos = tuple(state.pos)\n    grid_height, grid_width, _ = grid.shape\n\n    # BFS queue stores tuples of (current_position, path_of_actions)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    # Define possible moves and corresponding actions\n    # (dy, dx), action_id -> (y corresponds to row, x to column)\n    moves = {\n        (-1, 0): 1,  # UP\n        (1, 0): 0,   # DOWN\n        (0, -1): 2,  # LEFT\n        (0, 1): 3,   # RIGHT\n    }\n\n    path_to_workshop = None\n    target_workshop_pos = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        # Check if current_pos is adjacent to any workshop\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            check_pos = (current_pos[0] + dy, current_pos[1] + dx)\n            # Check if check_pos is a workshop location\n            if any(np.array_equal(check_pos, wp_pos) for wp_pos in workshop_positions):\n                path_to_workshop = path\n                target_workshop_pos = check_pos\n                queue.clear() # Goal found, clear queue to exit outer loop\n                break\n        \n        if path_to_workshop is not None:\n            break\n\n        # Explore neighbors\n        for (dy, dx), action in moves.items():\n            neighbor_pos = (current_pos[0] + dy, current_pos[1] + dx)\n\n            # Check boundaries\n            if not (0 <= neighbor_pos[0] < grid_height and 0 <= neighbor_pos[1] < grid_width):\n                continue\n\n            # Check if visited\n            if neighbor_pos in visited:\n                continue\n                \n            # Check if blocked (any item present)\n            if grid[neighbor_pos[0], neighbor_pos[1]].any():\n                continue\n\n            visited.add(neighbor_pos)\n            new_path = path + [action]\n            queue.append((neighbor_pos, new_path))\n\n    if path_to_workshop is None:\n        print(f\"Cannot find a reachable path to workshop '{workshop_name}'.\")\n        return []\n        \n    # 4. Determine final facing direction and add USE action\n    final_agent_pos = start_pos\n    # To determine the agent's position at the end of the path, we can either\n    # simulate the path or use the last position from the BFS search that led to the goal.\n    # Let's find the agent's final position based on the last position in the BFS search\n    if path_to_workshop:\n        q_temp = collections.deque([(start_pos, [])])\n        visited_temp = {start_pos}\n        found_final_pos = False\n        while q_temp and not found_final_pos:\n            curr, p = q_temp.popleft()\n            if p == path_to_workshop:\n                final_agent_pos = curr\n                found_final_pos = True\n                break\n            for (dy, dx), action in moves.items():\n                neighbor = (curr[0] + dy, curr[1] + dx)\n                if neighbor not in visited_temp:\n                    visited_temp.add(neighbor)\n                    q_temp.append((neighbor, p + [action]))\n\n    dy = target_workshop_pos[0] - final_agent_pos[0]\n    dx = target_workshop_pos[1] - final_agent_pos[1]\n\n    face_action = -1\n    if dy == -1 and dx == 0: face_action = 1 # Face UP\n    elif dy == 1 and dx == 0: face_action = 0 # Face DOWN\n    elif dy == 0 and dx == -1: face_action = 2 # Face LEFT\n    elif dy == 0 and dx == 1: face_action = 3 # Face RIGHT\n    \n    actions = list(path_to_workshop)\n    if face_action != -1:\n        actions.append(face_action)\n    \n    actions.append(4)  # USE action\n\n    return actions\n",
  "evaluation_result": [
    -1,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop, face it, and craft an item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to execute the crafting task.\n    \"\"\"\n    cookbook = env.world.cookbook\n    item_idx = cookbook.index[item]\n\n    if item_idx is None:\n        raise ValueError(f\"Item '{item}' not found in the cookbook.\")\n\n    # 1. Find the specific workshop required by the recipe\n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe or '_key' not in recipe:\n        # This item cannot be crafted (e.g., it's a primitive) or requires no workshop.\n        return []\n\n    required_workshop_idx = recipe['_key']\n\n    # 2. Find the closest instance of that specific workshop\n    agent_pos = np.array(env._current_state.pos)\n    \n    # Get all grid locations for the required workshop\n    all_workshop_locations = np.argwhere(env._current_state.grid[:, :, required_workshop_idx])\n\n    if len(all_workshop_locations) == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found on the grid.\")\n\n    # Calculate Manhattan distance to find the single closest workshop instance\n    closest_workshop_pos = None\n    min_dist = float('inf')\n    for pos in all_workshop_locations:\n        dist = np.sum(np.abs(agent_pos - pos))\n        if dist < min_dist:\n            min_dist = dist\n            closest_workshop_pos = pos\n\n    actions = []\n    # Simulate the agent's movement to generate the action sequence\n    current_pos = agent_pos.copy()\n\n    # 3. Generate path to an ADJACENT cell (Manhattan distance > 1)\n    # This simple pathfinding moves horizontally first, then vertically. It does not account for obstacles.\n    while np.sum(np.abs(current_pos - closest_workshop_pos)) > 1:\n        diff = closest_workshop_pos - current_pos\n        dx, dy = diff[0], diff[1]\n\n        action_taken = False\n        # Prioritize moving along the axis with the largest distance\n        if abs(dx) > 0:\n            if dx > 0:\n                action = 3  # RIGHT\n                current_pos[0] += 1\n            else:\n                action = 2  # LEFT\n                current_pos[0] -= 1\n            actions.append(action)\n            action_taken = True\n        elif abs(dy) > 0:\n            if dy > 0:\n                action = 1  # DOWN\n                current_pos[1] += 1\n            else:\n                action = 0  # UP\n                current_pos[1] -= 1\n            actions.append(action)\n            action_taken = True\n        \n        if not action_taken:\n            # Should not be reached if distance > 1, but as a safeguard.\n            break\n\n    # 4. Add the final action to FACE the workshop\n    final_diff = closest_workshop_pos - current_pos\n    if final_diff[0] == 1:   # Workshop is to the right\n        actions.append(3)    # RIGHT\n    elif final_diff[0] == -1: # Workshop is to the left\n        actions.append(2)    # LEFT\n    elif final_diff[1] == 1:  # Workshop is below\n        actions.append(1)    # DOWN\n    elif final_diff[1] == -1: # Workshop is above\n        actions.append(0)    # UP\n\n    # 5. Use the workshop\n    actions.append(4)  # USE\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function implements a robust strategy to navigate the environment and\n    craft a specified item. It addresses the shortcomings of the original by:\n    1.  Reading the recipe to identify the specific workshop required for the item.\n    2.  Using Breadth-First Search (BFS) for obstacle-aware pathfinding.\n    3.  Targeting a valid empty cell adjacent to the workshop, not the workshop itself.\n    4.  Ensuring the agent's final move orients it to face the workshop before crafting.\n    5.  Naturally finding the closest reachable workshop via the BFS algorithm.\n    \"\"\"\n\n    # Action constants for clarity and mapping to coordinate deltas\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n    MOVES = {\n        UP: (0, 1),    # (dx, dy)\n        DOWN: (0, -1),\n        RIGHT: (1, 0),\n        LEFT: (-1, 0),\n    }\n    ACTION_FOR_DELTA = {v: k for k, v in MOVES.items()}\n\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n    start_pos = tuple(state.pos)\n    width, height, _ = grid.shape\n\n    # --- Step 1: Identify the correct workshop for the item from the cookbook ---\n    goal_index = cookbook.index[item]\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'\")\n\n    recipe = cookbook.recipes[goal_index]\n    if '_key' not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop ('_key')\")\n    \n    workshop_kind = recipe['_key']\n\n    # --- Step 2: Find all instances of the required workshop on the grid ---\n    workshop_locations_np = np.argwhere(grid[:, :, workshop_kind])\n    if workshop_locations_np.shape[0] == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found on the map.\")\n    \n    workshop_locations = [tuple(pos) for pos in workshop_locations_np]\n\n    # --- Helper function to check if a grid cell is walkable ---\n    def is_walkable(pos):\n        if not (0 <= pos[0] < width and 0 <= pos[1] < height):\n            return False\n        # The agent's starting position is traversable for pathfinding purposes\n        if pos == start_pos:\n            return True\n        # An empty cell has no items, so its feature vector sums to 0\n        return grid[pos[0], pos[1], :].sum() == 0\n\n    # --- Special Case: Check if agent is already adjacent to the workshop ---\n    # If so, the agent just needs to turn towards it (by \"bumping\" it) and use it.\n    for w_pos in workshop_locations:\n        delta = (w_pos[0] - start_pos[0], w_pos[1] - start_pos[1])\n        if sum(map(abs, delta)) == 1: # Manhattan distance of 1 means adjacent\n            turn_action = ACTION_FOR_DELTA[delta]\n            return [turn_action, USE]\n\n    # --- Step 3: Define pathfinding goals for BFS ---\n    # A goal is a position from which a final move will correctly orient the agent.\n    # The dictionary maps a `goal_pos` to the `final_move` needed from there.\n    goals = {}\n    for w_pos in workshop_locations:\n        for final_move, delta in MOVES.items():\n            # The position the agent needs to land on, adjacent to the workshop\n            adj_pos = (w_pos[0] - delta[0], w_pos[1] - delta[1])\n            \n            # The BFS needs to find a path to the position *before* this final move\n            goal_pos = (adj_pos[0] - delta[0], adj_pos[1] - delta[1])\n\n            # A goal is valid only if the landing spot (adj_pos) is walkable\n            if is_walkable(adj_pos):\n                if goal_pos not in goals:\n                    goals[goal_pos] = final_move\n\n    # --- Step 4: Find the shortest path using Breadth-First Search ---\n    queue = collections.deque([(start_pos, [])]) # Each item is (current_pos, path_so_far)\n    visited = {start_pos}\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        # Check if the current position is a \"pre-move\" goal position\n        if current_pos in goals:\n            final_move = goals[current_pos]\n            return path + [final_move, USE]\n\n        # Explore neighbors\n        for action, (dx, dy) in MOVES.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            \n            if next_pos not in visited and is_walkable(next_pos):\n                visited.add(next_pos)\n                new_path = path + [action]\n                queue.append((next_pos, new_path))\n    \n    # If the queue becomes empty, no path to any workshop could be found\n    raise RuntimeError(f\"Could not find a path to craft '{item}'. The workshop may be inaccessible.\")\n\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop,\n    craft a specific item, and handles obstacles.\n    \"\"\"\n    \n    # Action constants for clarity\n    ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n\n    # --- 1. Identify the required workshop from the recipe ---\n    cookbook = env.world.cookbook\n    current_state = env._current_state\n    \n    goal_idx = cookbook.index[item]\n    if goal_idx is None:\n        # Item name is not recognized\n        return []\n\n    recipe = cookbook.recipes.get(goal_idx)\n    if not recipe or \"_key\" not in recipe:\n        # Item cannot be crafted (it's a primitive or has no recipe)\n        return []\n    \n    workshop_name = recipe[\"_key\"]\n    workshop_idx = cookbook.index[workshop_name]\n\n    # --- 2. Find all instances of the required workshop ---\n    grid = current_state.grid\n    # np.argwhere returns coordinates in (row, col) which is (y, x) format\n    workshop_locations_yx = np.argwhere(grid[:, :, workshop_idx])\n\n    if workshop_locations_yx.size == 0:\n        # Required workshop does not exist on the map\n        return []\n\n    # --- 3. Find the closest reachable workshop and a valid adjacent cell ---\n    # Agent's position is (x, y), convert to (y, x) for grid operations\n    start_pos_yx = (current_state.pos[1], current_state.pos[0])\n    \n    # The grid is indexed by (y, x)\n    height, width, _ = grid.shape\n    \n    # A cell is blocked if any object is on it\n    is_blocked = grid.any(axis=2)\n    \n    # BFS setup\n    queue = collections.deque([(start_pos_yx, [])])\n    visited = {start_pos_yx}\n    \n    # Dictionaries to store the path and target for each reachable adjacent cell\n    found_paths = {}\n\n    # --- 4. Perform a single BFS to find the shortest path to ANY valid adjacent cell ---\n    while queue:\n        current_yx, path = queue.popleft()\n        \n        # Explore neighbors (Down, Up, Left, Right)\n        # The order of exploration can matter if multiple paths have the same length\n        # (dy, dx, action)\n        for dy, dx, action in [(1, 0, ACTION_DOWN), (-1, 0, ACTION_UP), (0, -1, ACTION_LEFT), (0, 1, ACTION_RIGHT)]:\n            neighbor_yx = (current_yx[0] + dy, current_yx[1] + dx)\n            \n            # Check if neighbor is a valid destination (adjacent to a workshop)\n            for workshop_yx in workshop_locations_yx:\n                if np.array_equal(neighbor_yx, workshop_yx):\n                    # This means current_yx is adjacent to a workshop\n                    # We have found a path to a valid destination\n                    if current_yx not in found_paths:\n                         found_paths[current_yx] = (path, tuple(workshop_yx))\n\n            # Standard BFS bounds and obstacle check\n            if not (0 <= neighbor_yx[0] < height and 0 <= neighbor_yx[1] < width):\n                continue\n            if neighbor_yx in visited:\n                continue\n            if is_blocked[neighbor_yx[0], neighbor_yx[1]]:\n                continue\n\n            visited.add(neighbor_yx)\n            queue.append((neighbor_yx, path + [action]))\n            \n    if not found_paths:\n        # No path found to any cell adjacent to any required workshop\n        return []\n        \n    # We already have the shortest paths due to BFS, pick any\n    # (or you could add logic here to pick a preferred one)\n    destination_yx, (move_actions, target_workshop_yx) = min(found_paths.items(), key=lambda item: len(item[1][0]))\n\n    # --- 5. Determine orientation and final action sequence ---\n    # Calculate direction from destination to the workshop to determine facing direction\n    dy = target_workshop_yx[0] - destination_yx[0]\n    dx = target_workshop_yx[1] - destination_yx[1]\n\n    face_action = None\n    if dy == 1: face_action = ACTION_DOWN   # Workshop is below\n    elif dy == -1: face_action = ACTION_UP  # Workshop is above\n    elif dx == 1: face_action = ACTION_RIGHT# Workshop is to the right\n    elif dx == -1: face_action = ACTION_LEFT # Workshop is to the left\n    \n    if face_action is None:\n        # Should not happen with valid adjacency\n        return []\n\n    return move_actions + [face_action, ACTION_USE]\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    path to a cell adjacent to the required workshop, ensuring the final\n    move correctly orients the agent.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to be executed.\n    \n    Raises:\n        ValueError: If the item, recipe, or required workshop cannot be found.\n        RuntimeError: If no path to a valid crafting location can be found.\n    \"\"\"\n    # Action constants for clarity and correctness\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # 1. Identify the required workshop from the recipe\n    cookbook = env.world.cookbook\n    item_idx = cookbook.index[item]\n    if item_idx is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook.\")\n\n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe or '_key' not in recipe:\n        raise ValueError(f\"No recipe or workshop found for item '{item}'.\")\n    required_workshop_idx = recipe['_key']\n\n    # 2. Find all valid target destinations\n    # A valid destination is an empty cell adjacent to the correct workshop.\n    grid = env._current_state.grid\n    grid_height, grid_width, _ = grid.shape\n    start_pos = tuple(env._current_state.pos)\n\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found in the environment.\")\n\n    # Store potential destinations: map adjacent_cell -> workshop_cell\n    target_cells = {}\n    for ws_pos in workshop_locations:\n        ws_y, ws_x = tuple(ws_pos)\n        # Check 4 neighbors of the workshop\n        for dy, dx in [(1, 0), (-1, 0), (0, -1), (0, 1)]:\n            adj_y, adj_x = ws_y + dy, ws_x + dx\n            # Check if neighbor is within bounds and is empty (walkable)\n            if 0 <= adj_y < grid_height and 0 <= adj_x < grid_width:\n                if np.sum(grid[adj_y, adj_x, :]) == 0:\n                    target_cells[(adj_y, adj_x)] = (ws_y, ws_x)\n    \n    if not target_cells:\n        raise RuntimeError(\"No accessible cells adjacent to the required workshop.\")\n\n    # 3. Find the shortest path using Breadth-First Search (BFS)\n    queue = collections.deque([(start_pos, [])]) # (position, path_list)\n    visited = {start_pos}\n\n    # Agent move definitions: (dy, dx, action_id)\n    moves = [\n        (1, 0, DOWN),\n        (-1, 0, UP),\n        (0, -1, LEFT),\n        (0, 1, RIGHT),\n    ]\n    \n    path_to_craft = None\n\n    while queue:\n        (current_y, current_x), path = queue.popleft()\n\n        for dy, dx, action in moves:\n            next_y, next_x = current_y + dy, current_x + dx\n            next_pos = (next_y, next_x)\n\n            if next_pos in visited or not (0 <= next_y < grid_height and 0 <= next_x < grid_width):\n                continue\n            \n            # Check if the next position is a valid crafting spot\n            if next_pos in target_cells:\n                # This position is adjacent to a workshop.\n                # Now, check if this move orients the agent correctly.\n                workshop_pos = target_cells[next_pos]\n                \n                # The required facing direction is from the agent (at next_pos)\n                # towards the workshop.\n                req_face_dy = workshop_pos[0] - next_y\n                req_face_dx = workshop_pos[1] - next_x\n\n                # The agent's actual facing direction is determined by the last move.\n                # dy, dx represents the vector of the last move.\n                # We need to map the required facing vector to an action.\n                if (req_face_dy, req_face_dx) == (1, 0) and action == DOWN:\n                    path_to_craft = path + [action]\n                elif (req_face_dy, req_face_dx) == (-1, 0) and action == UP:\n                    path_to_craft = path + [action]\n                elif (req_face_dy, req_face_dx) == (0, -1) and action == LEFT:\n                    path_to_craft = path + [action]\n                elif (req_face_dy, req_face_dx) == (0, 1) and action == RIGHT:\n                    path_to_craft = path + [action]\n                \n                if path_to_craft:\n                    queue.clear() # Path found, stop searching\n                    break\n            \n            # If not a final crafting spot, check if it's walkable for standard BFS\n            if np.sum(grid[next_y, next_x, :]) == 0:\n                 visited.add(next_pos)\n                 queue.append((next_pos, path + [action]))\n\n        if path_to_craft:\n            break\n\n    # 4. Assemble the final action sequence\n    if path_to_craft is None:\n        # Check if already at a valid location but facing wrong direction\n        # This case is handled by BFS finding a path like (move away, move back)\n        raise RuntimeError(f\"Could not find a path to craft item '{item}'.\")\n\n    return path_to_craft + [USE]\n\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n    path to a state (position and direction) where the agent is adjacent to the\n    required workshop and facing it.\n\n    Args:\n        env: The CraftLab environment instance.\n        item: The name of the item to craft (e.g., \"plank\").\n\n    Returns:\n        A list of integer actions to execute.\n\n    Raises:\n        ValueError: If the item, recipe, workshop, or a valid path cannot be found.\n    \"\"\"\n    # 1. Setup: Get required information from the environment\n    world = env.world\n    cookbook = world.cookbook\n    state = env._current_state\n    grid = state.grid\n    start_pos = tuple(state.pos)\n    start_dir = state.dir\n\n    item_index = cookbook.index[item]\n    if item_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(item_index)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    workshop_index = recipe.get('_key')\n    if workshop_index is None:\n        raise ValueError(f\"No workshop specified in recipe for item: {item}\")\n\n    # 2. Define Goal States for BFS\n    h, w, n_kinds = grid.shape\n    \n    # Create a boolean grid of blocked locations\n    non_grabbable_mask = np.zeros(n_kinds, dtype=bool)\n    non_grabbable_mask[list(world.non_grabbable_indices)] = True\n    is_blocked = np.dot(grid, non_grabbable_mask) > 0\n\n    goals = set()  # A set of valid (position, direction) goal states\n    workshop_locations = np.argwhere(grid[:, :, workshop_index] == 1)\n\n    for wy, wx in workshop_locations:  # numpy returns (row, col) which is (y, x)\n        # Goal: be at (wx, wy-1) and face DOWN (dir 0)\n        if wy > 0 and not is_blocked[wy - 1, wx]:\n            goals.add(((wx, wy - 1), 0))\n        # Goal: be at (wx, wy+1) and face UP (dir 1)\n        if wy < h - 1 and not is_blocked[wy + 1, wx]:\n            goals.add(((wx, wy + 1), 1))\n        # Goal: be at (wx+1, wy) and face LEFT (dir 2)\n        if wx < w - 1 and not is_blocked[wy, wx + 1]:\n            goals.add(((wx + 1, wy), 2))\n        # Goal: be at (wx-1, wy) and face RIGHT (dir 3)\n        if wx > 0 and not is_blocked[wy, wx - 1]:\n            goals.add(((wx - 1, wy), 3))\n\n    if not goals:\n        raise ValueError(f\"No valid spots adjacent to workshop for {item}\")\n        \n    # Check if starting state is already a goal state\n    if (start_pos, start_dir) in goals:\n        return [4]  # Already in position, just USE\n\n    # 3. Run Breadth-First Search (BFS)\n    # The queue stores tuples of: ((position, direction), path_to_state)\n    queue = collections.deque([((start_pos, start_dir), [])])\n    visited = { (start_pos, start_dir) }\n\n    # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    # Move mapping: action -> (dx, dy)\n    moves = {\n        0: (0, 1),   # DOWN increases y\n        1: (0, -1),  # UP decreases y\n        2: (-1, 0),  # LEFT decreases x\n        3: (1, 0),   # RIGHT increases x\n    }\n\n    path = None\n    while queue:\n        (current_pos, current_dir), current_path = queue.popleft()\n        cx, cy = current_pos\n\n        for action, (dx, dy) in moves.items():\n            nx, ny = cx + dx, cy + dy\n            next_pos = (nx, ny)\n\n            # Check grid bounds\n            if not (0 <= nx < w and 0 <= ny < h):\n                continue\n\n            # Check if the next position is blocked\n            if is_blocked[ny, nx]:\n                continue\n            \n            # The agent's new direction is determined by the last move\n            next_dir = action\n            next_state = (next_pos, next_dir)\n\n            if next_state in visited:\n                continue\n\n            new_path = current_path + [action]\n            \n            # Check if we have reached a goal state\n            if next_state in goals:\n                path = new_path\n                queue.clear() # Found shortest path, stop searching\n                break\n            \n            visited.add(next_state)\n            queue.append((next_state, new_path))\n        \n        if path is not None:\n            break\n            \n    # 4. Assemble and return the final action sequence\n    if path is None:\n        raise ValueError(f\"Cannot find a path to correctly face the workshop for {item}\")\n\n    return path + [4]  # Append the USE action\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a robust strategy to solve the crafting task by:\n    1.  Identifying the specific workshop required for the item from the game's cookbook.\n    2.  Finding all empty, accessible cells adjacent to the required workshops, which serve as valid navigation targets.\n    3.  Using Breadth-First Search (BFS) to compute the shortest, obstacle-aware path to the nearest target cell.\n    4.  Determining the final action needed to orient the agent towards the workshop.\n    5.  Appending the 'USE' action to complete the crafting process.\n    \"\"\"\n    \n    # Define action constants for clarity\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n    \n    # Define movement vectors and their corresponding actions: ((dx, dy), action_id)\n    # This facilitates the BFS neighbor exploration.\n    moves = [\n        ((0, 1), DOWN),   # Down increases y-coordinate\n        ((0, -1), UP),    # Up decreases y-coordinate\n        ((-1, 0), LEFT),  # Left decreases x-coordinate\n        ((1, 0), RIGHT)   # Right increases x-coordinate\n    ]\n\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    height, width, _ = grid.shape\n    start_pos = tuple(env._current_state.pos)\n\n    # 1. Identify the required workshop from the recipe\n    item_index = cookbook.index[item]\n    if item_index is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook.\")\n    \n    recipe = cookbook.recipes.get(item_index)\n    if recipe is None:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n\n    # The workshop is typically specified by the '_key' in the recipe dictionary.\n    # This logic robustly finds a key like '_key' or '_place'.\n    try:\n        workshop_key = next(k for k in recipe if isinstance(k, str) and k.startswith('_'))\n    except StopIteration:\n        raise ValueError(f\"Could not find a workshop key in the recipe for '{item}'.\")\n    required_workshop_index = recipe[workshop_key]\n\n    # 2. Locate all instances of the required workshop on the grid\n    # np.argwhere returns (row, col) which corresponds to (y, x). We convert to (x, y).\n    workshop_locations_yx = np.argwhere(grid[:, :, required_workshop_index])\n    workshop_locations = {(loc[1], loc[0]) for loc in workshop_locations_yx}\n    if not workshop_locations:\n        raise ValueError(f\"Required workshop for '{item}' not found on the grid.\")\n\n    # 3. Create a walkability map and find all valid, empty target cells adjacent to workshops\n    walkable_grid = grid.sum(axis=2) == 0\n    possible_targets = set()\n    for wx, wy in workshop_locations:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = wx + dx, wy + dy\n            if 0 <= nx < width and 0 <= ny < height and walkable_grid[ny, nx]:\n                possible_targets.add((nx, ny))\n    \n    # Ensure the agent's starting position is considered walkable for the search.\n    if start_pos not in possible_targets:\n        walkable_grid[start_pos[1], start_pos[0]] = True\n\n    if not possible_targets:\n        raise RuntimeError(\"No accessible cell next to any required workshop.\")\n\n    # 4. Use BFS to find the shortest path to the nearest target\n    queue = collections.deque([start_pos])\n    visited = {start_pos}\n    # Parent map stores: child_pos -> (parent_pos, action_from_parent) for path reconstruction\n    parent = {start_pos: None}\n    target_reached = None\n\n    while queue:\n        curr_pos = queue.popleft()\n        if curr_pos in possible_targets:\n            target_reached = curr_pos\n            break\n        cx, cy = curr_pos\n        for (dx, dy), action in moves:\n            neighbor = (cx + dx, cy + dy)\n            if 0 <= neighbor[0] < width and 0 <= neighbor[1] < height and neighbor not in visited and walkable_grid[neighbor[1], neighbor[0]]:\n                visited.add(neighbor)\n                parent[neighbor] = (curr_pos, action)\n                queue.append(neighbor)\n                \n    if target_reached is None:\n        raise RuntimeError(\"Could not find a path to the workshop.\")\n\n    # 5. Reconstruct the path of move actions from the parent map\n    actions = []\n    curr = target_reached\n    while parent[curr] is not None:\n        prev_pos, action = parent[curr]\n        actions.append(action)\n        curr = prev_pos\n    actions.reverse()\n    \n    # 6. Determine the final orientation action to face the workshop\n    final_pos = target_reached\n    target_workshop_pos = None\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        check_pos = (final_pos[0] + dx, final_pos[1] + dy)\n        if check_pos in workshop_locations:\n            target_workshop_pos = check_pos\n            break\n    \n    # Calculate relative position and determine the action to face the workshop\n    wdx = target_workshop_pos[0] - final_pos[0]\n    wdy = target_workshop_pos[1] - final_pos[1]\n\n    orientation_action = None\n    if wdx == 1: orientation_action = RIGHT\n    elif wdx == -1: orientation_action = LEFT\n    elif wdy == 1: orientation_action = DOWN\n    elif wdy == -1: orientation_action = UP\n    \n    if orientation_action is not None:\n        actions.append(orientation_action)\n\n    # 7. Append the USE action to perform the craft\n    actions.append(USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop, orient, and craft an item.\n\n    This function implements a robust strategy by:\n    1.  Identifying the specific workshop required for the item from the recipe book.\n    2.  Locating all instances of that workshop in the current grid.\n    3.  Defining valid target destinations as any empty grid cell adjacent to a required workshop.\n    4.  Using Breadth-First Search (BFS) to find the shortest, obstacle-free path from the\n        agent's current position to the nearest valid target destination.\n    5.  Translating the found path into a sequence of movement actions (UP, DOWN, LEFT, RIGHT).\n    6.  Adding a final movement action that \"bumps\" into the workshop to correctly orient the agent.\n    7.  Appending the 'USE' action to perform the craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to be executed sequentially.\n\n    Raises:\n        ValueError: If the item has no recipe, requires no workshop, or if no workshop\n                    of the required type is present or accessible in the environment.\n        RuntimeError: If no path can be found to an accessible workshop.\n    \"\"\"\n    cookbook = env.world.cookbook\n    item_index = cookbook.index[item]\n\n    # 1. Identify the required workshop from the recipe\n    if item_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'\")\n    recipe = cookbook.recipes[item_index]\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n    workshop_index = recipe[\"_key\"]\n\n    grid = env._current_state.grid\n    # Grid dimensions are (height, width, kinds), which corresponds to (y, x, k)\n    h, w = grid.shape[:2]\n    # Agent position is (x, y), so we swap to (y, x) for grid indexing\n    start_pos_xy = env._current_state.pos\n    start_pos_yx = (start_pos_xy[1], start_pos_xy[0])\n\n    # 2. Find all empty cells adjacent to required workshops (our target destinations)\n    workshop_locs = np.argwhere(grid[:, :, workshop_index])\n    if workshop_locs.shape[0] == 0:\n        raise ValueError(f\"No workshop for '{item}' found in the environment.\")\n\n    # Map target adjacent cells (y,x) to their workshop's location (y,x)\n    target_cells = {}\n    for pos_yx in workshop_locs:\n        wy, wx = pos_yx\n        # Check 4-directional neighbors\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ny, nx = wy + dy, wx + dx\n            # Check if the neighbor is within bounds and is empty\n            if 0 <= ny < h and 0 <= nx < w and np.sum(grid[ny, nx, :]) == 0:\n                target_cells[(ny, nx)] = tuple(pos_yx)\n\n    if not target_cells:\n        raise ValueError(\"No accessible cells adjacent to any required workshop.\")\n\n    # 3. Pathfind using Breadth-First Search (BFS)\n    queue = collections.deque([start_pos_yx])\n    visited = {start_pos_yx}\n    # parent map to reconstruct the path: child -> parent\n    parent = {start_pos_yx: None}\n    \n    found_target_yx = None\n    while queue:\n        current_yx = queue.popleft()\n        if current_yx in target_cells:\n            found_target_yx = current_yx\n            break\n        \n        cy, cx = current_yx\n        # Explore neighbors\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ny, nx = cy + dy, cx + dx\n            neighbor_yx = (ny, nx)\n            # Check bounds, if visited, and if the cell is empty (traversable)\n            if 0 <= ny < h and 0 <= nx < w and neighbor_yx not in visited and np.sum(grid[ny, nx, :]) == 0:\n                visited.add(neighbor_yx)\n                parent[neighbor_yx] = current_yx\n                queue.append(neighbor_yx)\n    \n    if found_target_yx is None:\n        raise RuntimeError(\"Could not find a path to the workshop.\")\n\n    # Reconstruct path from parent map\n    path_yx = []\n    curr = found_target_yx\n    while curr is not None:\n        path_yx.append(curr)\n        curr = parent.get(curr)\n    path_yx.reverse()\n\n    # 4. Convert the path of coordinates to a sequence of movement actions\n    actions = []\n    # Action mapping: DOWN: 0, UP: 1, LEFT: 2, RIGHT: 3\n    for i in range(1, len(path_yx)):\n        prev_y, prev_x = path_yx[i-1]\n        curr_y, curr_x = path_yx[i]\n        dy, dx = curr_y - prev_y, curr_x - prev_x\n\n        if dy == 1: actions.append(0)   # Moved DOWN\n        elif dy == -1: actions.append(1)  # Moved UP\n        elif dx == -1: actions.append(2)  # Moved LEFT\n        elif dx == 1: actions.append(3)  # Moved RIGHT\n\n    # 5. Add a final \"bump\" action to face the workshop\n    final_pos_yx = path_yx[-1]\n    target_workshop_yx = target_cells[final_pos_yx]\n    \n    dy = target_workshop_yx[0] - final_pos_yx[0]\n    dx = target_workshop_yx[1] - final_pos_yx[1]\n    \n    if dy == 1: actions.append(0)      # Face DOWN\n    elif dy == -1: actions.append(1)     # Face UP\n    elif dx == -1: actions.append(2)     # Face LEFT\n    elif dx == 1: actions.append(3)     # Face RIGHT\n    \n    # 6. Add the USE action to perform the craft\n    actions.append(4) # USE\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item.\n    This involves:\n    1. Looking up the recipe to find the required workshop.\n    2. Finding all instances of that workshop in the environment.\n    3. Identifying all empty, accessible cells adjacent to these workshops.\n    4. Using Breadth-First Search (BFS) to find the shortest path to one of these cells.\n    5. Orienting the agent to face the workshop before using it.\n    6. Appending the 'USE' action to perform the craft.\n    \n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A sequence of action integers to be executed.\n        \n    Raises:\n        ValueError: If the item, recipe, or required workshop is not found.\n        RuntimeError: If no path to the workshop can be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    start_pos = env._current_state.pos  # Grid coordinates are (row, col) or (y, x)\n    h, w, _ = grid.shape\n\n    # 1. Look up the recipe to find the required workshop for the item.\n    goal_index = cookbook.index[item]\n    if goal_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    if \"_key\" not in recipe:\n        raise ValueError(f\"No workshop specified in recipe for {item}\")\n    required_workshop_index = recipe[\"_key\"]\n\n    # Action constants and mappings for grid movement.\n    # Note: dy > 0 is DOWN, dx > 0 is RIGHT.\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n    # moves are defined as (dy, dx, action)\n    moves = [(1, 0, DOWN), (-1, 0, UP), (0, -1, LEFT), (0, 1, RIGHT)]\n\n    # 2. Find all locations of the required workshop.\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_index])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop '{cookbook.index.get(required_workshop_index)}' not found in the environment.\")\n\n    # 3. Identify all valid target cells (empty and adjacent to a workshop).\n    target_cells = set()\n    for pos_y, pos_x in workshop_locations:\n        for dy, dx, _ in moves:\n            ny, nx = pos_y + dy, pos_x + dx\n            # Check if the neighbor is within bounds and is an empty cell.\n            if 0 <= ny < h and 0 <= nx < w and np.sum(grid[ny, nx, :]) == 0:\n                target_cells.add((ny, nx))\n    \n    if not target_cells:\n        raise ValueError(\"No accessible cells next to the required workshop.\")\n\n    # 4. Find the shortest path to an adjacent cell using BFS.\n    queue = collections.deque([(start_pos, [])])  # Stores ((y, x), path_list)\n    visited = {start_pos}\n    path_to_target = None\n    final_pos = None\n\n    # If already at a target cell, no movement is needed initially.\n    if start_pos in target_cells:\n        path_to_target = []\n        final_pos = start_pos\n    else:\n        while queue:\n            (curr_y, curr_x), path = queue.popleft()\n\n            for dy, dx, action in moves:\n                next_y, next_x = curr_y + dy, curr_x + dx\n                next_pos = (next_y, next_x)\n\n                if not (0 <= next_y < h and 0 <= next_x < w) or next_pos in visited:\n                    continue\n\n                if next_pos in target_cells:\n                    path_to_target = path + [action]\n                    final_pos = next_pos\n                    queue.clear()  # Path found, exit loops.\n                    break\n                \n                # Agent can only move through empty cells.\n                if np.sum(grid[next_y, next_x, :]) == 0:\n                    visited.add(next_pos)\n                    queue.append((next_pos, path + [action]))\n\n    if path_to_target is None:\n        raise RuntimeError(f\"Cannot find a path to a workshop for {item}.\")\n\n    # 5. Ensure the agent is facing the workshop.\n    # Find the specific workshop instance we are now adjacent to.\n    target_workshop_pos = None\n    for dy, dx, _ in moves:\n        ny, nx = final_pos[0] + dy, final_pos[1] + dx\n        if 0 <= ny < h and 0 <= nx < w and grid[ny, nx, required_workshop_index] > 0:\n            target_workshop_pos = (ny, nx)\n            break\n    \n    if target_workshop_pos is None:\n        raise RuntimeError(\"Arrived at a cell not adjacent to the workshop.\")\n\n    # Determine the direction required to face the workshop from the final position.\n    dy_face = target_workshop_pos[0] - final_pos[0]\n    dx_face = target_workshop_pos[1] - final_pos[1]\n    \n    required_dir = next(action for dy, dx, action in moves if dy == dy_face and dx == dx_face)\n\n    # Determine direction upon arrival. If no moves, use current direction.\n    arrival_dir = env._current_state.dir if not path_to_target else path_to_target[-1]\n    \n    final_actions = list(path_to_target)\n\n    # If not facing the correct direction, attempt a re-orienting maneuver.\n    if arrival_dir != required_dir:\n        # The maneuver involves stepping into an adjacent empty cell and then\n        # stepping back into final_pos with the correct orientation.\n        opposites = {DOWN: UP, UP: DOWN, LEFT: RIGHT, RIGHT: LEFT}\n        move_vectors = {\n            DOWN: (1, 0), UP: (-1, 0), LEFT: (0, -1), RIGHT: (0, 1)\n        }\n        \n        # Action to move away from final_pos.\n        action_away = opposites[required_dir]\n        dy_away, dx_away = move_vectors[action_away]\n        temp_pos = (final_pos[0] + dy_away, final_pos[1] + dx_away)\n        \n        # Check if the temporary cell for the maneuver is valid (in bounds and empty).\n        temp_y, temp_x = temp_pos\n        if 0 <= temp_y < h and 0 <= temp_x < w and np.sum(grid[temp_y, temp_x, :]) == 0:\n            final_actions.append(action_away)\n            final_actions.append(required_dir) # This step both returns and orients.\n        else:\n            # If the simple turn is not possible (e.g., in a corridor),\n            # the agent may fail. A more complex pathfinder (e.g., A* on x,y,dir)\n            # would be needed for such edge cases.\n            pass\n\n    # 6. Add the 'USE' action to craft the item.\n    final_actions.append(USE)\n\n    return final_actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    orient the agent, and craft the specified item.\n    \"\"\"\n    \n    # Action constants for clarity\n    ACTION_DOWN = 0\n    ACTION_UP = 1\n    ACTION_LEFT = 2\n    ACTION_RIGHT = 3\n    ACTION_USE = 4\n\n    # --- 1. Identify Requirements: Find the correct workshop for the item ---\n    cookbook = env.world.cookbook\n    item_idx = cookbook.index[item]\n    \n    if item_idx not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'. Cannot craft.\")\n        \n    recipe = cookbook.recipes[item_idx]\n    \n    # The workshop required is specified by the '_key' in the recipe\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n        \n    required_workshop_idx = recipe[\"_key\"]\n\n    # --- 2. Locate Target: Find all valid, empty cells adjacent to the workshop ---\n    grid = env._current_state.grid\n    height, width, _ = grid.shape\n    start_pos = tuple(env._current_state.pos)\n\n    # Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found in the environment.\")\n\n    # An obstacle grid: True for blocked cells, False for empty cells\n    # A cell is blocked if it contains any object.\n    is_obstacle = grid.sum(axis=2) > 0\n    \n    target_cells = set()\n    for pos in workshop_locations:\n        y, x = pos\n        # Check four neighbors (up, down, left, right)\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ny, nx = y + dy, x + dx\n            # A valid target cell is within bounds and not an obstacle\n            if 0 <= ny < height and 0 <= nx < width and not is_obstacle[ny, nx]:\n                target_cells.add((ny, nx))\n    \n    if not target_cells:\n        raise ValueError(f\"No accessible cells next to the workshop for '{item}'.\")\n\n    # --- 3. Navigate: Find the shortest path using Breadth-First Search (BFS) ---\n    queue = collections.deque([(start_pos, [])]) # (current_pos, path_so_far)\n    visited = {start_pos}\n\n    path_to_workshop = None\n\n    # Mappings for BFS: (dy, dx) -> action\n    moves = {\n        (1, 0): ACTION_DOWN,\n        (-1, 0): ACTION_UP,\n        (0, -1): ACTION_LEFT,\n        (0, 1): ACTION_RIGHT,\n    }\n\n    while queue:\n        (y, x), path = queue.popleft()\n\n        if (y, x) in target_cells:\n            path_to_workshop = path\n            break\n\n        for (dy, dx), action in moves.items():\n            ny, nx = y + dy, x + dx\n            \n            # Check if the neighbor is valid to move to\n            if 0 <= ny < height and 0 <= nx < width and (ny, nx) not in visited:\n                # The agent can only move into non-obstacle cells.\n                # Exception: A target cell *could* be the destination of a path,\n                # but we can't path *through* another workshop/obstacle.\n                if not is_obstacle[ny, nx] or (ny, nx) in target_cells:\n                    visited.add((ny, nx))\n                    new_path = path + [action]\n                    queue.append(((ny, nx), new_path))\n    \n    if path_to_workshop is None:\n        raise RuntimeError(f\"Cannot find a path to the workshop for '{item}'.\")\n\n    # --- 4. Orient and Craft: Add final orientation and USE actions ---\n    \n    # Determine the agent's position after following the path\n    final_pos = start_pos\n    for action in path_to_workshop:\n        if action == ACTION_DOWN: final_pos = (final_pos[0] + 1, final_pos[1])\n        elif action == ACTION_UP: final_pos = (final_pos[0] - 1, final_pos[1])\n        elif action == ACTION_LEFT: final_pos = (final_pos[0], final_pos[1] - 1)\n        elif action == ACTION_RIGHT: final_pos = (final_pos[0], final_pos[1] + 1)\n            \n    # Find the workshop this final position is adjacent to\n    orientation_action = -1\n    for (dy, dx), action in moves.items():\n        ny, nx = final_pos[0] + dy, final_pos[1] + dx\n        if 0 <= ny < height and 0 <= nx < width and grid[ny, nx, required_workshop_idx]:\n            orientation_action = action\n            break\n            \n    if orientation_action == -1:\n        # This should not happen if the logic is correct\n        raise RuntimeError(\"Pathfinding ended in a non-adjacent cell.\")\n\n    # The full plan: move to the cell, turn to face the workshop, then use it.\n    # To \"turn\", the agent attempts to move into the workshop, which updates its\n    # direction without changing position.\n    actions = path_to_workshop + [orientation_action, ACTION_USE]\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item.\n\n    The strategy involves:\n    1. Identifying the specific workshop required for the item's recipe.\n    2. Finding all valid, empty locations adjacent to these workshops.\n    3. For each adjacent spot, determine the \"pre-move\" position and the final orienting move required.\n    4. Using Breadth-First Search (BFS) to find the shortest path to one of these \"pre-move\" positions.\n    5. Appending the final orienting move and the 'USE' action to the path.\n\n    This approach correctly handles obstacle navigation, selects the right workshop,\n    and ensures the agent is properly positioned and oriented before crafting.\n    \"\"\"\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    start_pos = tuple(env._current_state.pos) # Use tuple for hashability\n\n    # 1. Find the required workshop index from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook.\")\n\n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n\n    required_workshop_idx = recipe.get('_key')\n    if required_workshop_idx is None:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n\n    # 2. Define moves and identify all potential pathfinding goals\n    # A \"goal\" is a position P from which a final move M\n    # will land the agent on a space N adjacent to the workshop W, facing W.\n    \n    # action: (dr, dc) for position (row, col)\n    # DOWN: 0 (+row), UP: 1 (-row), LEFT: 2 (-col), RIGHT: 3 (+col)\n    moves = {\n        0: (1, 0),   # DOWN\n        1: (-1, 0),  # UP\n        2: (0, -1),  # LEFT\n        3: (0, 1),   # RIGHT\n    }\n\n    pathfinding_goals = {} # Maps pre-final position P -> final_move M\n    height, width, _ = grid.shape\n\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"No workshop for '{item}' found in the current environment.\")\n\n    for wr, wc in workshop_locations:\n        # For each workshop, check its 4 neighbors to define N, P, and M\n        for final_move, (dr, dc) in moves.items():\n            # N is the position adjacent to the workshop where the agent will stand\n            nr, nc = wr - dr, wc - dc\n            \n            # P is the position *before* N, from which the final move is made\n            pr, pc = nr - dr, nc - dc\n            \n            if not (0 <= nr < height and 0 <= nc < width and 0 <= pr < height and 0 <= pc < width):\n                continue\n            \n            # The agent's final standing spot (N) must be empty\n            if grid[nr, nc, :].any():\n                continue\n            \n            # The pre-final spot (P) must be traversable. If it's the start\n            # position, it's traversable by definition.\n            if (pr, pc) != start_pos and grid[pr, pc, :].any():\n                continue\n\n            pathfinding_goals[(pr, pc)] = final_move\n\n    if not pathfinding_goals:\n        raise RuntimeError(f\"Could not find any accessible crafting location for '{item}'.\")\n\n    # 3. Use BFS to find the shortest path to one of the pre-final positions (P)\n    goal_positions = set(pathfinding_goals.keys())\n    \n    path = []\n    destination = None\n    \n    # Handle case where agent is already at a goal position\n    if start_pos in goal_positions:\n        destination = start_pos\n    else:\n        queue = collections.deque([(start_pos, [])]) # (position, path_list)\n        visited = {start_pos}\n\n        while queue:\n            (r, c), current_path = queue.popleft()\n\n            for action, (dr, dc) in moves.items():\n                nr, nc = r + dr, c + dc\n                neighbor_pos = (nr, nc)\n\n                if not (0 <= nr < height and 0 <= nc < width) or neighbor_pos in visited:\n                    continue\n                \n                # Check if a goal is reached\n                if neighbor_pos in goal_positions:\n                    path = current_path + [action]\n                    destination = neighbor_pos\n                    queue.clear() # Goal found, empty queue to stop searching\n                    break\n                \n                # Check if traversable (not an obstacle)\n                if not grid[nr, nc, :].any():\n                    visited.add(neighbor_pos)\n                    queue.append((neighbor_pos, current_path + [action]))\n            if destination is not None:\n                break\n\n    if destination is None:\n        raise RuntimeError(f\"Cannot find a path to a workshop for '{item}'.\")\n\n    # 4. Assemble the full action sequence\n    final_move = pathfinding_goals[destination]\n    full_path = path + [final_move, 4] # 4 is USE action\n\n    return full_path\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop, face it, and craft an item.\n\n    This function implements a robust strategy using Breadth-First Search (BFS) for pathfinding.\n    1.  It reads the cookbook to determine the specific workshop required for the given item.\n    2.  It identifies all empty, accessible cells adjacent to that type of workshop.\n    3.  It uses BFS to find the shortest obstacle-avoiding path to the nearest of these adjacent cells.\n    4.  It generates the sequence of movement actions (UP, DOWN, LEFT, RIGHT) for the path.\n    5.  It adds a final action to turn the agent to face the workshop.\n    6.  It appends the 'USE' action to perform the craft.\n\n    Args:\n        env: The environment instance, providing access to the current state and world info.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to be executed.\n        \n    Raises:\n        ValueError: If the item, recipe, workshop, or a path cannot be found.\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n    h, w, _ = grid.shape\n    start_pos = state.pos  # The agent's starting (x, y) position\n\n    # Action constants derived from the environment's action_specs\n    ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n\n    # 1. Find the recipe and the specific workshop required for the item.\n    item_idx = cookbook.index[item]\n    if item_idx is None or item_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' not found or does not have a recipe.\")\n    \n    recipe = cookbook.recipes[item_idx]\n    \n    # Find the workshop key (e.g., '_key') in the recipe dictionary.\n    workshop_key = next((k for k in recipe if k.startswith('_')), None)\n    if not workshop_key:\n        raise ValueError(f\"Recipe for '{item}' does not specify a required workshop.\")\n    \n    workshop_name = recipe[workshop_key]\n    workshop_idx = cookbook.index[workshop_name]\n\n    # 2. Find all valid target cells (empty cells adjacent to the correct workshop).\n    workshop_locs_yx = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locs_yx.shape[0] == 0:\n        raise ValueError(f\"Workshop '{workshop_name}' not found in the environment.\")\n\n    # A dictionary mapping valid target positions (adj_x, adj_y) to their workshop's position (wx, wy)\n    targets = {}\n    for wy, wx in workshop_locs_yx: # Note: np.argwhere returns (row, col) which is (y, x)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = wx + dx, wy + dy\n            \n            # Ensure the adjacent cell is within the grid bounds\n            if not (0 <= adj_x < w and 0 <= adj_y < h):\n                continue\n            \n            # A cell is a valid target if it's empty (no items/features)\n            if grid[adj_y, adj_x, :].sum() == 0:\n                targets[(adj_x, adj_y)] = (wx, wy)\n    \n    if not targets:\n        raise ValueError(f\"No accessible cells found next to any '{workshop_name}'.\")\n        \n    # 3. Use Breadth-First Search (BFS) to find the shortest path to a target cell.\n    queue = collections.deque([(start_pos, [])])  # Each item is (position, path_of_actions)\n    visited = {start_pos}\n\n    path_to_target = None\n    final_pos = None\n    workshop_pos = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        # If we've reached a valid target cell, we have found the shortest path.\n        if current_pos in targets:\n            path_to_target = path\n            final_pos = current_pos\n            workshop_pos = targets[current_pos]\n            break\n\n        # Explore neighbors in a consistent order (DOWN, UP, LEFT, RIGHT)\n        for action, (dx, dy) in zip(\n            [ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT],\n            [(0, 1), (0, -1), (-1, 0), (1, 0)] # (dx, dy) for each action\n        ):\n            neighbor_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            nx, ny = neighbor_pos\n\n            if neighbor_pos in visited:\n                continue\n\n            # Check if the neighbor is within bounds and is traversable (empty)\n            if (0 <= nx < w and 0 <= ny < h and grid[ny, nx, :].sum() == 0) or neighbor_pos in targets:\n                visited.add(neighbor_pos)\n                new_path = path + [action]\n                queue.append((neighbor_pos, new_path))\n    \n    if path_to_target is None:\n        raise ValueError(\"Cannot find a path to the required workshop.\")\n\n    actions = path_to_target\n\n    # 4. Determine the final orientation action to face the workshop.\n    # Calculate vector from agent's final position to the workshop.\n    w_dx = workshop_pos[0] - final_pos[0]\n    w_dy = workshop_pos[1] - final_pos[1]\n\n    orient_action = -1\n    if (w_dx, w_dy) == (0, 1): # Workshop is DOWN from agent\n        orient_action = ACTION_DOWN\n    elif (w_dx, w_dy) == (0, -1): # Workshop is UP\n        orient_action = ACTION_UP\n    elif (w_dx, w_dy) == (-1, 0): # Workshop is LEFT\n        orient_action = ACTION_LEFT\n    elif (w_dx, w_dy) == (1, 0): # Workshop is RIGHT\n        orient_action = ACTION_RIGHT\n\n    actions.append(orient_action)\n    \n    # 5. Add the USE action to perform the craft.\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A sequence of action integers to be executed.\n        \n    Raises:\n        ValueError: If the item, workshop, or a path cannot be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index[item]\n\n    if goal_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipe = cookbook.recipes.get(goal_index)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item: {item}\")\n\n    workshop_index = recipe.get('_key')\n    if workshop_index is None:\n        raise ValueError(f\"No workshop specified in recipe for item: {item}\")\n\n    grid = env._current_state.grid\n    w, h, _ = grid.shape\n    start_pos = tuple(env._current_state.pos)\n\n    # Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, workshop_index])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Workshop for {item} not found on the map.\")\n\n    # Define the mapping from action to grid displacement (dx, dy)\n    # Assumes grid is indexed [x, y] and y increases downwards.\n    # 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    moves = {\n        0: (0, 1),   # DOWN (+y)\n        1: (0, -1),  # UP (-y)\n        2: (-1, 0),  # LEFT (-x)\n        3: (1, 0)    # RIGHT (+x)\n    }\n    opposites = {0: 1, 1: 0, 2: 3, 3: 2}\n    \n    # Find all valid, empty cells adjacent to any instance of the workshop\n    target_cells = set()\n    for x, y in workshop_locations:\n        for dx, dy in moves.values():\n            nx, ny = x + dx, y + dy\n            # Check if neighbor is within bounds and is empty (walkable)\n            if 0 <= nx < w and 0 <= ny < h and grid[nx, ny, :].sum() == 0:\n                target_cells.add((nx, ny))\n\n    if not target_cells:\n        raise ValueError(f\"No accessible cell next to a workshop for {item}.\")\n\n    # --- Pathfinding with Breadth-First Search (BFS) ---\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    path = None\n    final_pos = None\n\n    while queue:\n        current_pos, current_path = queue.popleft()\n\n        if current_pos in target_cells:\n            path = current_path\n            final_pos = current_pos\n            break\n\n        for action, (dx, dy) in moves.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            if (0 <= next_pos[0] < w and 0 <= next_pos[1] < h and\n                    next_pos not in visited and\n                    grid[next_pos[0], next_pos[1], :].sum() == 0):\n                visited.add(next_pos)\n                queue.append((next_pos, current_path + [action]))\n\n    if path is None:\n        raise ValueError(f\"Cannot find a path to the workshop for {item}.\")\n\n    # --- Final Orientation ---\n    # Find the specific workshop this final_pos is adjacent to\n    workshop_pos = None\n    for x, y in workshop_locations:\n        if abs(x - final_pos[0]) + abs(y - final_pos[1]) == 1:\n            workshop_pos = (x, y)\n            break\n            \n    # Determine the action required to move from final_pos to workshop_pos\n    # This action sets the correct final direction for the 'USE' command.\n    dx_face = workshop_pos[0] - final_pos[0]\n    dy_face = workshop_pos[1] - final_pos[1]\n    \n    facing_action = -1\n    for act, (dx, dy) in moves.items():\n        if (dx, dy) == (dx_face, dy_face):\n            facing_action = act\n            break\n            \n    # The agent's direction is determined by its last move. To ensure correct\n    # orientation, we perform a move away from the workshop, then move back\n    # towards it. This guarantees the final direction is correct.\n    move_away_action = opposites[facing_action]\n    dx_away, dy_away = moves[move_away_action]\n    temp_pos = (final_pos[0] + dx_away, final_pos[1] + dy_away)\n\n    # Only add orientation moves if the temporary spot is walkable\n    if (0 <= temp_pos[0] < w and 0 <= temp_pos[1] < h and\n            grid[temp_pos[0], temp_pos[1], :].sum() == 0):\n        path.append(move_away_action)\n        path.append(facing_action)\n\n    # --- Final Action ---\n    path.append(4)  # USE action\n\n    return path\n\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specific item.\n\n    This function implements a strategy to:\n    1. Identify the specific workshop required for the item from the recipe book.\n    2. Find all locations of that workshop on the grid.\n    3. Determine all valid, empty cells adjacent to these workshops.\n    4. Use Breadth-First Search (BFS) to find the shortest path from the agent's\n       current position to the nearest of these adjacent cells.\n    5. Determine the correct orientation to face the workshop.\n    6. Append the final \"USE\" action to craft the item.\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n\n    # 1. Identify required workshop from recipe\n    item_index = cookbook.index[item]\n    if item_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'\")\n    \n    recipe = cookbook.recipes[item_index]\n    # The workshop is usually denoted by '_key' in the recipe\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n    workshop_index = recipe[\"_key\"]\n\n    # 2. Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, workshop_index])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found on the map.\")\n\n    # 3. Find all empty, adjacent cells (valid targets)\n    width, height, _ = grid.shape\n    target_cells = set()\n    for pos in workshop_locations:\n        # pos is (x, y)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_pos = (pos[0] + dx, pos[1] + dy)\n            # Check bounds\n            if not (0 <= adj_pos[0] < width and 0 <= adj_pos[1] < height):\n                continue\n            # Check if adjacent cell is empty (traversable)\n            if not grid[adj_pos[0], adj_pos[1], :].any():\n                target_cells.add(adj_pos)\n\n    if not target_cells:\n        raise ValueError(f\"No accessible location next to workshop for '{item}'.\")\n\n    # 4. Pathfind to the nearest target cell using BFS\n    start_pos = tuple(state.pos)\n    \n    # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n    # Grid is (width, height), so pos is (x, y)\n    # DOWN: (x, y+1), UP: (x, y-1), LEFT: (x-1, y), RIGHT: (x+1, y)\n    action_map = {\n        0: (0, 1),   # DOWN\n        1: (0, -1),  # UP\n        2: (-1, 0),  # LEFT\n        3: (1, 0)    # RIGHT\n    }\n    \n    delta_to_action = {v: k for k, v in action_map.items()}\n\n    q = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    path_to_target = None\n    final_pos = None\n\n    if start_pos in target_cells: # Agent is already at a target position\n        path_to_target = []\n        final_pos = start_pos\n    else:\n        while q:\n            current_pos, path = q.popleft()\n\n            for action, (dx, dy) in action_map.items():\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n                if next_pos in visited:\n                    continue\n\n                if not (0 <= next_pos[0] < width and 0 <= next_pos[1] < height):\n                    continue\n                \n                visited.add(next_pos)\n                new_path = path + [action]\n\n                if next_pos in target_cells:\n                    path_to_target = new_path\n                    final_pos = next_pos\n                    q.clear() # Found shortest path, exit loop\n                    break\n                \n                # Check if next cell is empty/traversable\n                if not grid[next_pos[0], next_pos[1], :].any():\n                    q.append((next_pos, new_path))\n\n    if path_to_target is None:\n        raise RuntimeError(f\"Could not find a path to the workshop for '{item}'.\")\n\n    actions = path_to_target\n\n    # 5. Determine final orientation to face the workshop\n    adjacent_workshop_pos = None\n    for dx, dy in action_map.values():\n        check_pos = (final_pos[0] + dx, final_pos[1] + dy)\n        if 0 <= check_pos[0] < width and 0 <= check_pos[1] < height:\n            if grid[check_pos[0], check_pos[1], workshop_index]:\n                adjacent_workshop_pos = check_pos\n                break\n    \n    if adjacent_workshop_pos is None:\n        raise RuntimeError(\"Reached target cell but couldn't find adjacent workshop.\")\n\n    # Calculate delta from agent to workshop to determine which way to face\n    final_dx = adjacent_workshop_pos[0] - final_pos[0]\n    final_dy = adjacent_workshop_pos[1] - final_pos[1]\n\n    # Add an action to face the workshop (assumes bumping into an object turns the agent)\n    orientation_action = delta_to_action.get((final_dx, final_dy))\n    if orientation_action is not None:\n        actions.append(orientation_action)\n    else:\n        raise RuntimeError(\"Invalid delta for final orientation.\")\n\n    # 6. Append USE action\n    actions.append(4) # USE\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop,\n    face it, and craft the specified item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item: The string name of the item to craft.\n\n    Returns:\n        A list of integer actions, or an empty list if crafting is not possible.\n    \"\"\"\n    cookbook = env.world.cookbook\n    grid = env._current_state.grid\n    start_pos = tuple(env._current_state.pos)\n    w, h, _ = grid.shape\n\n    # 1. Find the specific workshop required by the recipe.\n    item_idx = cookbook.index[item]\n    if item_idx not in cookbook.recipes:\n        # This item cannot be crafted (e.g., it's a primitive).\n        return []\n    \n    recipe = cookbook.recipes[item_idx]\n    if '_key' not in recipe:\n        # This recipe does not require a workshop.\n        return []\n    workshop_idx = recipe['_key']\n\n    # 2. Find all locations of the required workshop and their adjacent empty cells.\n    workshop_locations = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locations.size == 0:\n        # The required workshop does not exist in the current environment.\n        return []\n\n    # Target cells are empty cells adjacent to any instance of the required workshop.\n    targets = {}  # Map target_pos -> corresponding_workshop_pos\n    for pos in workshop_locations:\n        x, y = pos\n        # Check 4-directional neighbors\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < w and 0 <= ny < h and grid[nx, ny].sum() == 0:\n                # This neighbor is a valid, empty target cell.\n                if (nx, ny) not in targets:\n                    targets[(nx, ny)] = (x, y)\n    \n    if not targets:\n        # No accessible cells next to any required workshop.\n        return []\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path to a target.\n    queue = collections.deque([(start_pos, [])])  # (current_pos, path_list)\n    visited = {start_pos}\n    \n    path_to_target = None\n    destination_pos = None\n    target_workshop_pos = None\n\n    # Handle the case where the agent already starts at a target location.\n    if start_pos in targets:\n        path_to_target = []\n        destination_pos = start_pos\n        target_workshop_pos = targets[start_pos]\n    \n    while queue and path_to_target is None:\n        (x, y), path = queue.popleft()\n\n        # Action codes: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n        # (dx, dy) -> action\n        for dx, dy, action in [(0, 1, 0), (0, -1, 1), (-1, 0, 2), (1, 0, 3)]:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < w and 0 <= ny < h and (nx, ny) not in visited:\n                # Check if the cell is walkable (empty or a target)\n                if grid[nx, ny].sum() == 0 or (nx, ny) in targets:\n                    visited.add((nx, ny))\n                    new_path = path + [action]\n                    \n                    if (nx, ny) in targets:\n                        # Found the shortest path to a target.\n                        path_to_target = new_path\n                        destination_pos = (nx, ny)\n                        target_workshop_pos = targets[(nx, ny)]\n                        break\n                    \n                    queue.append(((nx, ny), new_path))\n    \n    if path_to_target is None:\n        # No path found to any target cell.\n        return []\n\n    # 4. Determine the final actions: face the workshop, then use it.\n    final_actions = path_to_target\n    \n    # Calculate direction from agent's destination to the workshop\n    dx = target_workshop_pos[0] - destination_pos[0]\n    dy = target_workshop_pos[1] - destination_pos[1]\n\n    face_action = -1\n    if dx == 1:  # Workshop is to the RIGHT\n        face_action = 3\n    elif dx == -1:  # Workshop is to the LEFT\n        face_action = 2\n    elif dy == 1:  # Workshop is DOWN\n        face_action = 0\n    elif dy == -1:  # Workshop is UP\n        face_action = 1\n    \n    # Add action to face the workshop. Assumes moving into a blocked cell changes\n    # direction without changing position.\n    if face_action != -1:\n        final_actions.append(face_action)\n    \n    # Add the USE action.\n    final_actions.append(4)\n    \n    return final_actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a given item.\n\n    This function implements a strategy to:\n    1. Look up the recipe for the specified item to find the required workshop.\n    2. Locate all instances of that workshop in the environment.\n    3. Use Breadth-First Search (BFS) to find the shortest path to an empty\n       cell adjacent to the nearest reachable workshop.\n    4. Generate movement actions based on the path.\n    5. Add a final action to turn the agent towards the workshop.\n    6. Add the 'USE' action to perform the craft.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list: A list of integer actions to execute.\n    \n    Raises:\n        ValueError: If the item is unknown, the required workshop is not in\n                    the recipe, or no path to a workshop can be found.\n    \"\"\"\n    \n    # --- 1. Initialization and Recipe Lookup ---\n    world = env.world\n    cookbook = world.cookbook\n    state = env._current_state\n    \n    item_idx = cookbook.index[item]\n    if item_idx is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook.\")\n\n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n\n    # Find the required workshop from the recipe\n    workshop_indices = set(world.workshop_indices)\n    required_workshop_idx = None\n    for component_idx in recipe:\n        if component_idx in workshop_indices:\n            required_workshop_idx = component_idx\n            break\n            \n    if required_workshop_idx is None:\n        raise ValueError(f\"No workshop specified in recipe for '{item}'.\")\n\n    # --- 2. Find Target Locations ---\n    grid = state.grid\n    start_pos = tuple(state.pos)\n    \n    # Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.size == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found in the environment.\")\n\n    # A cell is an obstacle if it's not empty\n    is_obstacle = grid.sum(axis=2) > 0\n    grid_width, grid_height, _ = grid.shape\n\n    # BFS targets are empty cells adjacent to any workshop instance\n    targets = []\n    for w_pos in workshop_locations:\n        wx, wy = tuple(w_pos)\n        # Check four neighbors: UP, DOWN, LEFT, RIGHT\n        for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            ax, ay = wx + dx, wy + dy\n            # Ensure the adjacent cell is within bounds and is not an obstacle\n            if 0 <= ax < grid_width and 0 <= ay < grid_height and not is_obstacle[ax, ay]:\n                targets.append(((ax, ay), (wx, wy))) # (agent_target_pos, workshop_pos)\n\n    if not targets:\n        raise ValueError(\"No accessible location next to a workshop found.\")\n\n    # --- 3. Pathfinding with Breadth-First Search (BFS) ---\n    queue = collections.deque([(start_pos, [])])  # (current_pos, list_of_actions)\n    visited = {start_pos}\n    target_map = {t[0]: t[1] for t in targets} # Maps agent_pos -> workshop_pos\n    \n    path_to_target = None\n    final_pos = None\n    workshop_pos = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in target_map:\n            path_to_target = path\n            final_pos = current_pos\n            workshop_pos = target_map[current_pos]\n            break\n\n        cx, cy = current_pos\n        # Action order: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n        moves = [((cx, cy - 1), 0), ((cx, cy + 1), 1), \n                 ((cx - 1, cy), 2), ((cx + 1, cy), 3)]\n\n        for next_pos, action in moves:\n            nx, ny = next_pos\n            if 0 <= nx < grid_width and 0 <= ny < grid_height and \\\n               next_pos not in visited and not is_obstacle[nx, ny]:\n                visited.add(next_pos)\n                new_path = path + [action]\n                queue.append((next_pos, new_path))\n    \n    if path_to_target is None:\n        raise RuntimeError(f\"Could not find a path to a workshop for '{item}'.\")\n        \n    # --- 4. Final Action Generation ---\n    actions = path_to_target\n    \n    # Add a final \"turn\" action to face the workshop.\n    # This is done by attempting to move into the workshop, which only changes direction.\n    dx = workshop_pos[0] - final_pos[0]\n    dy = workshop_pos[1] - final_pos[1]\n\n    if dy == 1:\n        turn_action = 1  # UP\n    elif dy == -1:\n        turn_action = 0  # DOWN\n    elif dx == 1:\n        turn_action = 3  # RIGHT\n    else: # dx == -1\n        turn_action = 2  # LEFT\n    \n    actions.append(turn_action)\n    \n    # Add the USE action to craft\n    actions.append(4)  # USE\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the required workshop and craft an item.\n    This function implements a Breadth-First Search (BFS) for pathfinding to avoid\n    obstacles and finds the correct workshop based on the item's recipe.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n    grid = state.grid\n\n    # Action constants from the environment's action_specs\n    # DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n    ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n    \n    # 1. Identify the required workshop from the recipe\n    item_idx = cookbook.index[item]\n    if item_idx is None:\n        raise ValueError(f\"Item '{item}' not found in cookbook index.\")\n        \n    recipe = cookbook.recipes.get(item_idx)\n    if recipe is None:\n        raise ValueError(f\"No recipe found for item '{item}'.\")\n        \n    required_workshop_idx = recipe.get(\"_key\")\n    if required_workshop_idx is None:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop (_key).\")\n\n    # 2. Find all instances of the required workshop and their valid adjacent cells (destinations)\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found in the environment.\")\n\n    height, width, _ = grid.shape\n    destinations = set()\n    # Store which workshop each destination corresponds to, to find it later\n    destination_to_workshop = {} \n    \n    for wy, wx in workshop_locations:\n        # Check 4-directional neighbors\n        for dy, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ny, nx = wy + dy, wx + dx\n            # A valid destination is within bounds and is an empty cell\n            if 0 <= ny < height and 0 <= nx < width and not grid[ny, nx, :].any():\n                destinations.add((ny, nx))\n                destination_to_workshop[(ny, nx)] = (wy, wx)\n\n    if not destinations:\n        raise ValueError(\"No accessible adjacent cells for any required workshop.\")\n\n    # 3. Pathfind from agent's current position to the nearest destination using BFS\n    start_pos_yx = (state.pos[1], state.pos[0]) # Convert from (x,y) to (y,x) for numpy indexing\n\n    # If already at a valid destination, no movement is needed.\n    if start_pos_yx in destinations:\n        path = [start_pos_yx]\n    else:\n        # The queue stores paths (lists of coordinates)\n        queue = collections.deque([[start_pos_yx]])\n        visited = {start_pos_yx}\n        path = None\n\n        while queue:\n            current_path = queue.popleft()\n            y, x = current_path[-1]\n\n            if (y, x) in destinations:\n                path = current_path\n                break\n\n            # Explore neighbors: UP, DOWN, LEFT, RIGHT\n            for move_y, move_x in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ny, nx = y + move_y, x + move_x\n                if 0 <= ny < height and 0 <= nx < width and (ny, nx) not in visited and not grid[ny, nx, :].any():\n                    visited.add((ny, nx))\n                    new_path = list(current_path)\n                    new_path.append((ny, nx))\n                    queue.append(new_path)\n    \n    if path is None:\n        raise RuntimeError(\"Could not find a path to the required workshop.\")\n\n    # 4. Convert the path (list of y,x tuples) to a sequence of move actions\n    actions = []\n    for i in range(1, len(path)):\n        prev_y, prev_x = path[i-1]\n        curr_y, curr_x = path[i]\n        \n        dy, dx = curr_y - prev_y, curr_x - prev_x\n        \n        if dy == -1: actions.append(ACTION_UP)\n        elif dy == 1: actions.append(ACTION_DOWN)\n        elif dx == -1: actions.append(ACTION_LEFT)\n        elif dx == 1: actions.append(ACTION_RIGHT)\n\n    # 5. Add a final action to face the workshop, then the USE action\n    final_pos_yx = path[-1]\n    \n    target_workshop_yx = destination_to_workshop[final_pos_yx]\n    \n    # Determine direction from agent's final position to the workshop\n    dy = target_workshop_yx[0] - final_pos_yx[0]\n    dx = target_workshop_yx[1] - final_pos_yx[1]\n    \n    # This last \"move\" action correctly orients the agent, likely by bumping into the workshop\n    if dy == -1: actions.append(ACTION_UP)    # Face UP\n    elif dy == 1: actions.append(ACTION_DOWN)  # Face DOWN\n    elif dx == -1: actions.append(ACTION_LEFT)  # Face LEFT\n    elif dx == 1: actions.append(ACTION_RIGHT) # Face RIGHT\n    \n    actions.append(ACTION_USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    Args:\n        env: The CraftLab environment instance.\n        item: The string name of the item to craft.\n\n    Returns:\n        A list of integer actions to be executed.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # 1. Find the recipe and the required workshop for the item.\n    item_idx = cookbook.index[item]\n    if item_idx is None:\n        raise ValueError(f\"Item '{item}' not found in the cookbook index.\")\n    \n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe or '_key' not in recipe:\n        raise ValueError(f\"No recipe or workshop specified for item '{item}'.\")\n    \n    workshop_idx = recipe['_key']\n    \n    # 2. Find all instances of the required workshop and select the closest one.\n    grid = state.grid\n    start_pos = state.pos  # (x, y)\n\n    workshop_locs_yx = np.argwhere(grid[:, :, workshop_idx])\n    if workshop_locs_yx.shape[0] == 0:\n        workshop_name = cookbook.index.get(workshop_idx)\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    # Convert locations from numpy's (row, col) i.e. (y, x) to game's (x, y)\n    workshop_locs_xy = [(pos[1], pos[0]) for pos in workshop_locs_yx]\n    \n    # Find the workshop instance closest to the agent\n    min_dist = float('inf')\n    target_workshop_pos = None\n    for pos in workshop_locs_xy:\n        # Use Manhattan distance for grid worlds\n        dist = abs(start_pos[0] - pos[0]) + abs(start_pos[1] - pos[1])\n        if dist < min_dist:\n            min_dist = dist\n            target_workshop_pos = pos\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path to a cell adjacent to the workshop.\n    \n    def is_walkable(pos, grid):\n        \"\"\"Check if a grid cell at (x, y) is empty/walkable.\"\"\"\n        return np.sum(grid[pos[1], pos[0], :]) == 0\n\n    height, width, _ = grid.shape\n    \n    # Define goal states: walkable cells adjacent to the target workshop\n    goals = set()\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_pos = (target_workshop_pos[0] + dx, target_workshop_pos[1] + dy)\n        if (0 <= adj_pos[0] < width and 0 <= adj_pos[1] < height and is_walkable(adj_pos, grid)):\n            goals.add(adj_pos)\n\n    if not goals:\n        raise RuntimeError(f\"No accessible cells next to the workshop for '{item}'.\")\n\n    # BFS queue stores tuples of (current_position, path_to_reach_it)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    # Action mapping: MOVE_ACTION -> (dx, dy)\n    # DOWN=0, UP=1, LEFT=2, RIGHT=3\n    moves = {0: (0, 1), 1: (0, -1), 2: (-1, 0), 3: (1, 0)}\n    path_to_adjacent = None\n    final_pos = None\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos in goals:\n            path_to_adjacent = path\n            final_pos = current_pos\n            break\n\n        for action, (dx, dy) in moves.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            if (0 <= next_pos[0] < width and 0 <= next_pos[1] < height and\n                    next_pos not in visited and is_walkable(next_pos, grid)):\n                visited.add(next_pos)\n                queue.append((next_pos, path + [action]))\n    \n    if path_to_adjacent is None:\n        raise RuntimeError(f\"Could not find a path to the workshop for '{item}'.\")\n\n    actions = path_to_adjacent\n    \n    # 4. Determine the action to turn and face the workshop from the adjacent cell.\n    dx = target_workshop_pos[0] - final_pos[0]\n    dy = target_workshop_pos[1] - final_pos[1]\n    \n    turn_action = -1\n    if (dx, dy) == (0, 1): turn_action = 0   # Face Down\n    elif (dx, dy) == (0, -1): turn_action = 1 # Face Up\n    elif (dx, dy) == (-1, 0): turn_action = 2 # Face Left\n    elif (dx, dy) == (1, 0): turn_action = 3  # Face Right\n    \n    if turn_action == -1:\n         # This case should be unreachable if BFS goal logic is correct.\n        raise RuntimeError(\"Pathfinding ended in a non-adjacent cell.\")\n\n    actions.append(turn_action)\n    \n    # 5. Add the 'USE' action to perform the craft.\n    actions.append(4)  # USE action\n\n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    The function performs the following steps:\n    1.  Looks up the recipe for the given 'item' to identify the required workshop.\n    2.  Finds all locations of that specific workshop on the grid.\n    3.  Identifies all empty, accessible cells adjacent to any of these workshops. These become the target destinations.\n    4.  Uses a Breadth-First Search (BFS) algorithm to find the shortest, obstacle-avoiding path from the agent's current position to the nearest target cell.\n    5.  Reconstructs the sequence of movement actions (UP, DOWN, LEFT, RIGHT) from the BFS result.\n    6.  Determines the final action needed to make the agent face the workshop.\n    7.  Appends the 'face' action and the 'USE' action to the movement sequence.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers representing the complete plan.\n\n    Raises:\n        ValueError: If the item has no recipe, the recipe doesn't specify a workshop, or no required workshop is found in the environment.\n        RuntimeError: If no path to an accessible workshop can be found.\n    \"\"\"\n    state = env._current_state\n    cookbook = env.world.cookbook\n    grid = state.grid\n    agent_pos = tuple(state.pos)\n    grid_width, grid_height, _ = grid.shape\n\n    # 1. Find the required workshop from the item's recipe\n    item_idx = cookbook.index[item]\n    if item_idx not in cookbook.recipes:\n        raise ValueError(f\"Item '{item}' cannot be crafted (no recipe found).\")\n    \n    recipe = cookbook.recipes[item_idx]\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n    \n    required_workshop_idx = recipe[\"_key\"]\n\n    # 2. Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locations.shape[0] == 0:\n        raise ValueError(f\"No workshop for crafting '{item}' found in the environment.\")\n\n    # 3. Define target cells for BFS (empty cells adjacent to any workshop)\n    target_cells = set()\n    for wx, wy in workshop_locations:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = wx + dx, wy + dy\n            # Check bounds and if the cell is empty (walkable)\n            if 0 <= nx < grid_width and 0 <= ny < grid_height and grid[nx, ny, :].sum() == 0:\n                target_cells.add((nx, ny))\n\n    # If the agent is already adjacent to a workshop, its current position is the target\n    if agent_pos in target_cells:\n        pass\n    # If there are no other accessible cells, but the agent is adjacent, this is still a valid starting point\n    elif not target_cells:\n        is_adjacent = False\n        ax, ay = agent_pos\n        for wx, wy in workshop_locations:\n            if abs(ax - wx) + abs(ay - wy) == 1:\n                is_adjacent = True\n                break\n        if not is_adjacent:\n            raise RuntimeError(f\"No accessible cells adjacent to a workshop for '{item}'.\")\n\n    # 4. Pathfinding using Breadth-First Search (BFS)\n    queue = collections.deque([agent_pos])\n    visited = {agent_pos}\n    # parent stores {pos: (previous_pos, action_to_get_here)}\n    parent = {agent_pos: (None, None)}\n    \n    found_target_pos = None\n    if agent_pos in target_cells:\n        found_target_pos = agent_pos\n    else:\n        while queue:\n            curr_pos = queue.popleft()\n            \n            # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n            # Move mapping: (dx, dy, action)\n            moves = [(0, 1, 1), (0, -1, 0), (-1, 0, 2), (1, 0, 3)] # UP, DOWN, LEFT, RIGHT\n\n            for dx, dy, action in moves:\n                next_pos = (curr_pos[0] + dx, curr_pos[1] + dy)\n                if next_pos in visited:\n                    continue\n\n                nx, ny = next_pos\n                if 0 <= nx < grid_width and 0 <= ny < grid_height:\n                    # Check if the next cell is a target\n                    if next_pos in target_cells:\n                        visited.add(next_pos)\n                        parent[next_pos] = (curr_pos, action)\n                        found_target_pos = next_pos\n                        queue.clear() # End search\n                        break\n                    # Check if walkable (empty)\n                    if grid[nx, ny, :].sum() == 0:\n                        visited.add(next_pos)\n                        parent[next_pos] = (curr_pos, action)\n                        queue.append(next_pos)\n\n    if found_target_pos is None:\n        raise RuntimeError(f\"Could not find a path to a workshop for '{item}'.\")\n\n    # 5. Reconstruct the path of move actions\n    move_actions = []\n    curr = found_target_pos\n    while curr != agent_pos:\n        prev_pos, action = parent[curr]\n        move_actions.append(action)\n        curr = prev_pos\n    move_actions.reverse()\n    \n    # 6. Find the specific workshop we are now next to\n    final_pos = found_target_pos\n    workshop_pos = None\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        check_pos = (final_pos[0] + dx, final_pos[1] + dy)\n        cx, cy = check_pos\n        if 0 <= cx < grid_width and 0 <= cy < grid_height:\n            if grid[cx, cy, required_workshop_idx] > 0:\n                workshop_pos = check_pos\n                break\n    \n    if workshop_pos is None:\n        raise RuntimeError(\"Internal logic error: cannot find adjacent workshop after pathfinding.\")\n\n    # 7. Determine the action required to face the workshop\n    w_dx = workshop_pos[0] - final_pos[0]\n    w_dy = workshop_pos[1] - final_pos[1]\n    \n    # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT, 4:USE\n    if w_dx == 1: face_action = 3  # RIGHT\n    elif w_dx == -1: face_action = 2  # LEFT\n    elif w_dy == 1: face_action = 1  # UP\n    elif w_dy == -1: face_action = 0  # DOWN\n    else:\n        raise RuntimeError(\"Workshop is not adjacent to final position.\")\n\n    # Assemble the final action list: path to location, action to face workshop, then use\n    final_actions = move_actions + [face_action, 4]\n\n    return final_actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to craft a specified item.\n\n    The strategy involves:\n    1. Identifying the specific workshop required by the item's recipe from the cookbook.\n    2. Finding the closest instance of that workshop in the environment.\n    3. Using Breadth-First Search (BFS) to find the shortest path to an empty\n       cell adjacent to the workshop, navigating around obstacles.\n    4. Appending a move action that turns the agent to face the workshop.\n    5. Appending the 'USE' action to perform the crafting.\n    \n    Args:\n        env (CraftLab): The environment instance, providing access to the current state and world info.\n        item (str): The name of the item to craft (e.g., \"plank\", \"axe\").\n\n    Returns:\n        list[int]: A sequence of action integers to be executed by the DSL interpreter.\n\n    Raises:\n        ValueError: If the item is unknown, has no recipe, or the required\n                    workshop is not found in the environment.\n        RuntimeError: If no path can be found to the workshop or it's\n                      completely surrounded by obstacles.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    cookbook = world.cookbook\n\n    # 1. Identify the required workshop from the recipe\n    try:\n        goal_index = cookbook.index[item]\n    except KeyError:\n        raise ValueError(f\"Item '{item}' not found in cookbook index.\")\n\n    if goal_index not in cookbook.recipes:\n        raise ValueError(f\"No recipe found for item '{item}'. It might be a primitive or uncraftable.\")\n\n    recipe = cookbook.recipes[goal_index]\n    if \"_key\" not in recipe:\n        raise ValueError(f\"Recipe for '{item}' does not specify a workshop.\")\n    \n    required_workshop_idx = recipe[\"_key\"]\n\n    # 2. Find the closest instance of the required workshop\n    grid = state.grid\n    # np.argwhere returns coordinates in (row, col) format, which corresponds to (y, x)\n    workshop_locations_yx = np.argwhere(grid[:, :, required_workshop_idx] > 0)\n\n    if workshop_locations_yx.size == 0:\n        workshop_name = cookbook.index.get(required_workshop_idx)\n        raise ValueError(f\"Required workshop '{workshop_name}' not found in the environment.\")\n\n    agent_pos_xy = np.array(state.pos)  # Agent position is in (x, y) format\n    \n    # Convert workshop locations from (y, x) to (x, y) for distance calculation\n    workshop_locations_xy = workshop_locations_yx[:, ::-1]\n    \n    # Calculate Manhattan distances to find the closest workshop instance\n    distances = np.sum(np.abs(workshop_locations_xy - agent_pos_xy), axis=1)\n    closest_workshop_index = np.argmin(distances)\n    target_workshop_pos_xy = workshop_locations_xy[closest_workshop_index]\n\n    # 3. Pathfind to an adjacent cell using Breadth-First Search (BFS)\n    q = collections.deque([(list(agent_pos_xy), [])]) # Queue stores (current_pos_xy, path)\n    visited = {tuple(agent_pos_xy)}\n    \n    height, width, _ = grid.shape\n    \n    # Pre-calculate a grid of blocked locations (containing non-grabbable items) for efficient collision checking\n    non_grabbable_mask = np.zeros(cookbook.n_kinds, dtype=bool)\n    non_grabbable_mask[list(world.non_grabbable_indices)] = True\n    blocked_grid = np.einsum('ijk,k->ij', grid, non_grabbable_mask).astype(bool)\n\n    # Define moves as: action -> (dx, dy)\n    moves = {\n        RIGHT: (1, 0),\n        LEFT: (-1, 0),\n        UP: (0, -1),\n        DOWN: (0, 1),\n    }\n    \n    # Find all valid, empty cells adjacent to the target workshop. These are our BFS goals.\n    target_adjacent_cells = set()\n    for dx, dy in moves.values():\n        adj_x, adj_y = target_workshop_pos_xy[0] + dx, target_workshop_pos_xy[1] + dy\n        if 0 <= adj_x < width and 0 <= adj_y < height and not blocked_grid[adj_y, adj_x]:\n            target_adjacent_cells.add((adj_x, adj_y))\n            \n    if not target_adjacent_cells:\n        raise RuntimeError(f\"Workshop at {tuple(target_workshop_pos_xy)} is completely surrounded.\")\n\n    path_to_workshop = None\n    final_agent_pos = None\n\n    while q:\n        current_pos_list, path = q.popleft()\n        current_pos_tuple = tuple(current_pos_list)\n\n        if current_pos_tuple in target_adjacent_cells:\n            path_to_workshop = path\n            final_agent_pos = current_pos_tuple\n            break\n        \n        for action, (dx, dy) in moves.items():\n            next_x, next_y = current_pos_tuple[0] + dx, current_pos_tuple[1] + dy\n            \n            if 0 <= next_x < width and 0 <= next_y < height and (next_x, next_y) not in visited:\n                if not blocked_grid[next_y, next_x]:\n                    visited.add((next_x, next_y))\n                    new_path = path + [action]\n                    q.append(([next_x, next_y], new_path))\n\n    if path_to_workshop is None:\n        raise RuntimeError(\"Could not find a valid path to the workshop.\")\n\n    actions = path_to_workshop\n    \n    # 4. Determine the action needed to turn and face the workshop from the final adjacent cell\n    final_x, final_y = final_agent_pos\n    target_x, target_y = target_workshop_pos_xy\n    \n    turn_action = -1\n    if target_x > final_x:      turn_action = RIGHT\n    elif target_x < final_x:    turn_action = LEFT\n    elif target_y > final_y:    turn_action = DOWN  # Higher y-index in grid corresponds to DOWN action\n    elif target_y < final_y:    turn_action = UP    # Lower y-index in grid corresponds to UP action\n        \n    if turn_action != -1:\n        actions.append(turn_action)\n\n    # 5. Append the USE action to perform the craft\n    actions.append(USE)\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to move to the correct workshop and craft an item.\n\n    This function implements a robust strategy using Breadth-First Search (BFS) for\n    pathfinding to navigate the agent to a cell adjacent to the required workshop.\n    It correctly identifies the workshop from the item's recipe, finds all\n    accessible locations next to it, and computes the shortest obstacle-avoiding path.\n    The final move in the path naturally orients the agent to face the workshop\n    before issuing the 'USE' command. It also handles the edge case where the agent\n    starts next to the workshop but is facing the wrong direction.\n\n    Args:\n        env (CraftLab): The environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action integers to execute.\n\n    Raises:\n        ValueError: If the item is unknown, cannot be crafted, the required\n                    workshop doesn't exist, or no path can be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # 1. Look up the recipe to find the required workshop\n    goal_idx = cookbook.index[item]\n    if goal_idx is None:\n        raise ValueError(f\"Item '{item}' is not a known entity.\")\n\n    recipe = cookbook.recipes.get(goal_idx)\n    if not recipe:\n        raise ValueError(f\"Item '{item}' cannot be crafted (no recipe found).\")\n\n    required_workshop_idx = None\n    for ingredient_idx in recipe.keys():\n        if ingredient_idx in env.world.workshop_indices:\n            required_workshop_idx = ingredient_idx\n            break\n\n    if required_workshop_idx is None:\n        raise ValueError(f\"No workshop specified in the recipe for '{item}'.\")\n\n    # 2. Find all valid destination cells (empty cells adjacent to the workshop)\n    grid = state.grid\n    height, width, _ = grid.shape\n    is_blocked = grid.sum(axis=2) > 0\n\n    workshop_locs = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_locs.shape[0] == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found in the environment.\")\n\n    destinations = set()\n    for y, x in workshop_locs:\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ny, nx = y + dy, x + dx\n            if 0 <= ny < height and 0 <= nx < width and not is_blocked[ny, nx]:\n                destinations.add((ny, nx))\n\n    if not destinations:\n        raise ValueError(\"No accessible cells found next to any required workshop.\")\n\n    # 3. Pathfinding using Breadth-First Search (BFS)\n    start_pos_xy = state.pos  # (x, y)\n    start_node = (start_pos_xy[1], start_pos_xy[0])  # Convert to (y, x) for grid indexing\n\n    # Action map: (dy, dx) -> action_code\n    # UP: dy=-1 -> 1, DOWN: dy=1 -> 0, LEFT: dx=-1 -> 2, RIGHT: dx=1 -> 3\n    action_map = {(-1, 0): 1, (1, 0): 0, (0, -1): 2, (0, 1): 3}\n\n    # If already at a destination, we may just need to turn\n    if start_node in destinations:\n        # Find the adjacent workshop to determine correct orientation\n        req_dir = -1\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ny, nx = start_node[0] + dy, start_node[1] + dx\n            if 0 <= ny < height and 0 <= nx < width and grid[ny, nx, required_workshop_idx]:\n                # Direction is defined by the move needed to get *from* agent *to* workshop\n                # Agent at (y,x), workshop at (y-1,x). Agent must face UP (dir 1).\n                # Move from (y,x) to (y-1,x) is UP, action 1.\n                if (dy, dx) == (-1, 0): req_dir = 1 # UP\n                elif (dy, dx) == (1, 0): req_dir = 0 # DOWN\n                elif (dy, dx) == (0, -1): req_dir = 2 # LEFT\n                elif (dy, dx) == (0, 1): req_dir = 3 # RIGHT\n                break\n        \n        if state.dir == req_dir:\n            return [4] # Already oriented correctly, just USE\n\n    # Standard BFS implementation\n    queue = collections.deque([(start_node, [])])  # ((y, x), path_of_actions)\n    visited = {start_node}\n\n    path_to_dest = None\n    while queue:\n        (curr_y, curr_x), path = queue.popleft()\n\n        if (curr_y, curr_x) in destinations:\n            path_to_dest = path\n            break\n\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # U, D, L, R\n            ny, nx = curr_y + dy, curr_x + dx\n\n            if 0 <= ny < height and 0 <= nx < width and not is_blocked[ny, nx] and (ny, nx) not in visited:\n                visited.add((ny, nx))\n                action = action_map[(dy, dx)]\n                new_path = path + [action]\n                queue.append(((ny, nx), new_path))\n    \n    if path_to_dest is None:\n        raise ValueError(\"Cannot find a path to the workshop.\")\n\n    return path_to_dest + [4] # Append USE action\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    path to a location adjacent to the required workshop for the specified item.\n    It handles obstacles and ensures the agent is correctly oriented before\n    attempting to use the workshop.\n\n    Args:\n        env: The CraftLab environment instance.\n        item (str): The name of the item to craft.\n\n    Returns:\n        list[int]: A list of action codes to perform the craft task.\n\n    Raises:\n        ValueError: If the item has no recipe, requires no workshop, or the\n                    necessary workshop is not present in the environment.\n        RuntimeError: If no path to the required workshop can be found.\n    \"\"\"\n    cookbook = env.world.cookbook\n    item_idx = cookbook.index[item]\n    \n    # 1. Look up the recipe to find the required workshop\n    recipe = cookbook.recipes.get(item_idx)\n    if not recipe or '_workshop' not in recipe:\n        raise ValueError(f\"Item '{item}' has no recipe or does not require a workshop.\")\n    \n    required_workshop_idx = recipe['_workshop']\n    \n    grid = env._current_state.grid\n    start_pos = env._current_state.pos  # This is in (x, y) format\n\n    # 2. Find all locations of the required workshop\n    # np.argwhere returns in (row, col) which corresponds to (y, x)\n    workshop_coords_yx = np.argwhere(grid[:, :, required_workshop_idx])\n    if workshop_coords_yx.size == 0:\n        raise ValueError(f\"Required workshop for '{item}' not found in the environment.\")\n\n    # Convert locations to a set of (x, y) tuples for efficient lookup\n    workshop_locations = set((pos[1], pos[0]) for pos in workshop_coords_yx)\n\n    # 3. Use Breadth-First Search (BFS) to find the shortest path to an adjacent cell\n    height, width, _ = grid.shape\n    queue = collections.deque([(start_pos, [])])  # Each item is ((x, y), path_list)\n    visited = {start_pos}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        # Check if the current position is adjacent to any target workshop\n        for dx, dy, face_direction in [(0, 1, 0), (0, -1, 1), (1, 0, 2), (-1, 0, 3)]: # DOWN, UP, LEFT, RIGHT\n            neighbor_x, neighbor_y = current_x + dx, current_y + dy\n            if (neighbor_x, neighbor_y) in workshop_locations:\n                # Path found! Now, construct the final action sequence.\n                # The agent needs to turn to face the workshop. A move action\n                # into the workshop block will turn the agent without moving it.\n                final_actions = list(path)\n                \n                # Determine the direction from agent (current_x,y) to workshop (neighbor_x,y)\n                if neighbor_x > current_x: # Workshop is to the right\n                    turn_action = 3  # RIGHT\n                elif neighbor_x < current_x: # Workshop is to the left\n                    turn_action = 2  # LEFT\n                elif neighbor_y > current_y: # Workshop is up\n                    turn_action = 1  # UP\n                else: # Workshop is down\n                    turn_action = 0  # DOWN\n                \n                final_actions.append(turn_action)\n                final_actions.append(4)  # USE action\n                return final_actions\n\n        # Explore neighbors if a path has not been found yet\n        # Action mapping: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n        for move_dx, move_dy, action in [(0, -1, 0), (0, 1, 1), (-1, 0, 2), (1, 0, 3)]:\n            next_x, next_y = current_x + move_dx, current_y + move_dy\n\n            # Check grid boundaries\n            if not (0 <= next_x < width and 0 <= next_y < height):\n                continue\n            \n            # Check if already visited\n            if (next_x, next_y) in visited:\n                continue\n            \n            # Check if the cell is blocked (impassable)\n            # grid is (h, w, kinds), so access is grid[y, x]\n            if grid[next_y, next_x, :].sum() > 0:\n                continue\n\n            # This is a valid, unvisited, and passable cell. Add to queue.\n            visited.add((next_x, next_y))\n            new_path = path + [action]\n            queue.append(((next_x, next_y), new_path))\n    \n    # If the queue is exhausted and no path was found\n    raise RuntimeError(f\"Could not find a path to the workshop required for '{item}'.\")\n",
  "evaluation_result": [
    -1,
    false
  ]
}
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to the correct workshop and craft an item.\n\n    This function implements a Breadth-First Search (BFS) algorithm to find the shortest \n    path to a valid cell adjacent to the required workshop. It then calculates the\n    necessary final actions to face the workshop and use it.\n    \"\"\"\n    \n    # --- Step 1: Identify the required workshop from the recipe ---\n    cookbook = env.world.cookbook\n    item_index = cookbook.index[item]\n    \n    if item_index is None:\n        raise ValueError(f\"Unknown item: {item}\")\n\n    recipes = cookbook.recipes\n    if item_index not in recipes:\n        raise ValueError(f\"No recipe found for item: {item}\")\n        \n    recipe = recipes[item_index]\n    workshop_key_index = cookbook.index['_key']\n    \n    if workshop_key_index not in recipe:\n        raise ValueError(f\"Recipe for {item} does not specify a workshop.\")\n        \n    required_workshop_index = recipe[workshop_key_index]\n    \n    # --- Step 2: Find all instances of the workshop and target cells ---\n    state = env._current_state\n    grid = state.grid\n    grid_width, grid_height, _ = grid.shape\n    \n    # Find all locations of the required workshop\n    workshop_locations = np.argwhere(grid[:, :, required_workshop_index])\n    if workshop_locations.size == 0:\n        workshop_name = cookbook.index.get(required_workshop_index)\n        raise ValueError(f\"Required workshop '{workshop_name}' not found on the map.\")\n\n    # Define potential moves and their corresponding action codes\n    # (dx, dy) -> action_code\n    moves = {\n        (0, -1): 0,  # Down\n        (0, 1): 1,   # Up\n        (-1, 0): 2,  # Left\n        (1, 0): 3,   # Right\n    }\n\n    # Find all empty cells adjacent to any workshop instance. These are our goals.\n    goal_positions = set()\n    # Map each goal position to the workshop it's adjacent to, needed for the final turn\n    goal_to_workshop_map = {}\n\n    for pos_x, pos_y in workshop_locations:\n        for (dx, dy), action in moves.items():\n            adj_x, adj_y = pos_x + dx, pos_y + dy\n            \n            # Check if adjacent cell is within bounds and is empty\n            if 0 <= adj_x < grid_width and 0 <= adj_y < grid_height:\n                # A cell is empty if its feature vector sums to 0\n                if grid[adj_x, adj_y, :].sum() == 0:\n                    goal_pos = (adj_x, adj_y)\n                    goal_positions.add(goal_pos)\n                    goal_to_workshop_map[goal_pos] = (pos_x, pos_y)\n\n    if not goal_positions:\n        raise ValueError(\"All required workshops are blocked and unreachable.\")\n\n    # --- Step 3: Pathfind using Breadth-First Search (BFS) ---\n    start_pos = tuple(state.pos)\n    \n    # If already at a goal position, no movement is needed\n    if start_pos in goal_positions:\n        path = []\n        final_pos = start_pos\n    else:\n        queue = collections.deque([(start_pos, [])]) # (position, path_list)\n        visited = {start_pos}\n        path_found = False\n\n        while queue:\n            current_pos, current_path = queue.popleft()\n\n            if current_pos in goal_positions:\n                path = current_path\n                final_pos = current_pos\n                path_found = True\n                break\n\n            for (dx, dy), action in moves.items():\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                \n                if next_pos not in visited and 0 <= next_pos[0] < grid_width and 0 <= next_pos[1] < grid_height:\n                    # Check if the next cell is empty\n                    if grid[next_pos[0], next_pos[1], :].sum() == 0:\n                        visited.add(next_pos)\n                        new_path = current_path + [action]\n                        queue.append((next_pos, new_path))\n        \n        if not path_found:\n            raise ValueError(\"Could not find a path to the required workshop.\")\n\n    # --- Step 4: Determine final orientation and USE action ---\n    workshop_pos = goal_to_workshop_map[final_pos]\n    \n    # Calculate the vector from the agent to the workshop\n    dx = workshop_pos[0] - final_pos[0]\n    dy = workshop_pos[1] - final_pos[1]\n    \n    # Determine the action that makes the agent face the workshop\n    # This action \"bumps\" into the workshop, changing direction without moving\n    turn_action = moves[(dx, dy)]\n    \n    # The final action sequence: path to move, action to turn, action to use\n    actions = path + [turn_action, 4]  # 4 is the USE action\n    \n    return actions\n",
  "evaluation_result": [
    -1,
    false
  ]
}
