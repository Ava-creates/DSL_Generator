{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  The strategy is as follows:\n  1. Identify all locations of the target primitive on the grid.\n  2. Determine all valid \"goal\" cells, which are empty, traversable cells\n     adjacent to any instance of the primitive. An empty cell is one not\n     occupied by a non-grabbable entity like water or stone.\n  3. Use Breadth-First Search (BFS) to find the shortest path of movement\n     actions from the agent's current position to one of these goal cells.\n  4. Once a path to an adjacent cell is found, determine the final action\n     required to turn the agent to face the primitive. This is achieved by\n     issuing a move command in the direction of the primitive. The game\n     mechanics will update the agent's direction even if the move into the\n     blocked cell fails.\n  5. Append the 'USE' action to collect the primitive from the adjacent cell.\n  6. Return the complete sequence of actions. If no path is found, return\n     an empty list.\n  \"\"\"\n  # Action constants based on the environment's action_specs:\n  # DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n  DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n  # Mapping of move actions to coordinate changes (dx, dy) assuming a\n  # standard Cartesian grid where +y is down.\n  ACTION_VECTORS = {\n      UP: (0, -1),\n      DOWN: (0, 1),\n      LEFT: (-1, 0),\n      RIGHT: (1, 0),\n  }\n  # Reverse mapping from vector to action, useful for determining the final turn.\n  VECTOR_TO_ACTION = {v: k for k, v in ACTION_VECTORS.items()}\n\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  width, height = grid.shape[0], grid.shape[1]\n\n  # 1. Identify all locations of the target primitive.\n  try:\n    primitive_idx = state.world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the game's cookbook.\n    return []\n\n  # np.argwhere returns coordinates as (row, col). For a grid of shape\n  # (WIDTH, HEIGHT, ...), this corresponds directly to (x, y).\n  primitive_locations = [tuple(coords) for coords in np.argwhere(grid[:, :, primitive_idx] > 0)]\n  if not primitive_locations:\n    return []  # Primitive is not present on the map.\n\n  # 2. Determine all valid, empty cells adjacent to any primitive.\n  non_grabbable_indices = state.world.non_grabbable_indices\n  # This dictionary maps a valid goal position to the primitive it's next to.\n  goals = {}\n\n  for px, py in primitive_locations:\n    for dx, dy in ACTION_VECTORS.values():\n      # The goal cell (gx, gy) is where the agent will stand.\n      gx, gy = px - dx, py - dy\n\n      if 0 <= gx < width and 0 <= gy < height:\n        # A cell is a valid goal if it is not blocked by a non-grabbable entity.\n        is_blocked = any(grid[gx, gy, i] > 0 for i in non_grabbable_indices)\n        if not is_blocked and (gx, gy) not in goals:\n          goals[(gx, gy)] = (px, py)\n\n  if not goals:\n    return []  # No accessible cells next to any instance of the primitive.\n\n  # 3. Use BFS to find the shortest path to a goal cell.\n  # The queue stores tuples of (current_position, path_to_get_here).\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n    current_pos, path = queue.popleft()\n\n    # Check if the current position is one of our goal cells.\n    if current_pos in goals:\n      primitive_pos = goals[current_pos]\n\n      # 4. Path found. Determine the final action to face the primitive.\n      # Calculate the vector from the agent's final spot to the primitive.\n      face_dx = primitive_pos[0] - current_pos[0]\n      face_dy = primitive_pos[1] - current_pos[1]\n      turn_action = VECTOR_TO_ACTION[(face_dx, face_dy)]\n\n      # 5. Append the turn and USE actions to finalize the plan.\n      return path + [turn_action, USE]\n\n    # If not at a goal, explore valid neighbors.\n    for action, (dx, dy) in ACTION_VECTORS.items():\n      next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n      nx, ny = next_pos\n\n      if 0 <= nx < width and 0 <= ny < height and next_pos not in visited:\n        # A cell is traversable if it's not blocked by a non-grabbable entity.\n        is_blocked = any(grid[nx, ny, i] > 0 for i in non_grabbable_indices)\n        if not is_blocked:\n          visited.add(next_pos)\n          queue.append((next_pos, path + [action]))\n\n  # 6. If the queue becomes empty, no path to any goal was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Finds and executes the shortest plan to collect a specified primitive.\n\n    The strategy uses a Breadth-First Search (BFS) to find the shortest\n    sequence of moves. The search goal is not just to be near the primitive, but\n    to arrive at an adjacent empty cell with the agent facing the primitive,\n    ready for collection. This ensures the final `USE` action is effective.\n\n    This implementation correctly handles key environmental constraints:\n    - The agent can only move into completely empty cells.\n    - The agent's final move must orient it towards the primitive.\n    \"\"\"\n    state = env._current_state\n    grid = state.grid\n    start_pos = state.pos\n    start_dir = state.dir\n\n    # Assumed mapping from action constants to direction vectors (dx, dy).\n    action_to_vec = {\n        craft.UP: (0, 1),\n        craft.DOWN: (0, -1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n    vec_to_action = {v: k for k, v in action_to_vec.items()}\n\n    # Assumed mapping from the agent's internal direction state (integer) to a vector.\n    # This is a common convention: 0:Up, 1:Right, 2:Down, 3:Left.\n    dir_int_to_vec = {\n        0: (0, 1),    # Corresponds to craft.UP\n        1: (1, 0),    # Corresponds to craft.RIGHT\n        2: (0, -1),   # Corresponds to craft.DOWN\n        3: (-1, 0),   # Corresponds to craft.LEFT\n    }\n\n    width, height, _ = grid.shape\n    primitive_index = state.world.cookbook.index[primitive]\n\n    # Step 1: Find all locations of the target primitive on the grid.\n    primitive_locations = set()\n    for x in range(width):\n        for y in range(height):\n            if grid[x, y, primitive_index] > 0:\n                primitive_locations.add((x, y))\n\n    if not primitive_locations:\n        return []  # Primitive does not exist on the map.\n\n    # Helper function to check if a cell is traversable (must be empty).\n    def is_traversable(pos):\n        x, y = pos\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        # Any cell with an item is considered blocked for movement.\n        return np.sum(grid[x, y, :]) == 0\n\n    # Step 2: Handle the edge case where the agent starts next to the primitive.\n    current_facing_vec = dir_int_to_vec.get(start_dir)\n    if current_facing_vec:\n        facing_pos = (start_pos[0] + current_facing_vec[0], start_pos[1] + current_facing_vec[1])\n        if facing_pos in primitive_locations:\n            return [craft.USE]\n\n    # Step 3: Perform BFS to find the shortest valid action sequence.\n    # The queue stores paths, where each path is a list of positions.\n    queue = collections.deque([[start_pos]])\n    # 'visited' tracks positions already added to the queue to prevent cycles.\n    visited = {start_pos}\n\n    while queue:\n        path = queue.popleft()\n        pos = path[-1]\n\n        # The goal is found if the last move in the path orients the agent correctly.\n        # This check applies only to paths with at least one move.\n        if len(path) > 1:\n            prev_pos = path[-2]\n            arrival_vec = (pos[0] - prev_pos[0], pos[1] - prev_pos[1])\n            \n            # The position the agent is facing after arriving at `pos`.\n            facing_pos = (pos[0] + arrival_vec[0], pos[1] + arrival_vec[1])\n\n            if facing_pos in primitive_locations:\n                # Success! Convert the path of positions to a list of actions.\n                actions = []\n                for i in range(len(path) - 1):\n                    p1 = path[i]\n                    p2 = path[i+1]\n                    action_vec = (p2[0] - p1[0], p2[1] - p1[1])\n                    actions.append(vec_to_action[action_vec])\n                \n                actions.append(craft.USE)\n                return actions\n\n        # Expand the search to neighboring cells.\n        for move_vec in vec_to_action.keys():\n            next_pos = (pos[0] + move_vec[0], pos[1] + move_vec[1])\n\n            # A move is valid only if the destination is traversable and unvisited.\n            if next_pos not in visited and is_traversable(next_pos):\n                visited.add(next_pos)\n                new_path = path + [next_pos]\n                queue.append(new_path)\n\n    return []  # No path found.\n",
  "evaluation_result": [
    1.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  The strategy is to find the shortest path to an empty cell adjacent to the\n  primitive. This is done using a Breadth-First Search (BFS) algorithm. The\n  search space for the BFS consists only of empty cells, as the agent cannot\n  move onto cells occupied by any item or obstacle.\n\n  Once a path to an adjacent cell is found, the action sequence is extended\n  with two final actions:\n  1. A move action that makes the agent turn and face the primitive. Since\n     the primitive's cell is blocked, this action results in a turn without\n     a change in position.\n  2. The 'USE' action, which collects the item from the now-faced cell.\n\n  This approach correctly handles the core mechanics of the game: movement is\n  restricted to empty cells, and collection requires adjacency and proper\n  orientation.\n  \"\"\"\n  # Action constants as per CraftLab specification\n  DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n  # Mappings for pathfinding. Directions are in (dy, dx) format to align\n  # with numpy's (row, col) grid indexing.\n  ACTION_MAP = {\n      (-1, 0): UP,    # UP: y decreases\n      (1, 0): DOWN,   # DOWN: y increases\n      (0, -1): LEFT,   # LEFT: x decreases\n      (0, 1): RIGHT,  # RIGHT: x increases\n  }\n\n  state = env._current_state\n  grid = state.grid\n  height, width = grid.shape[:2]\n  cookbook = state.world.cookbook\n\n  # Step 1: Get the integer index for the primitive's name.\n  try:\n      primitive_index = cookbook.index[primitive]\n  except KeyError:\n      # The primitive name does not exist in the game's vocabulary.\n      return []\n\n  # Step 2: Find all grid locations of the primitive.\n  # np.argwhere returns (row, col) pairs, which correspond to (y, x).\n  prim_coords = np.argwhere(grid[:, :, primitive_index] > 0)\n  if prim_coords.shape[0] == 0:\n      # The primitive does not exist on the current map.\n      return []\n  # Convert (y, x) coordinates to (x, y) for consistency with agent's position.\n  primitive_locations = set(tuple(c) for c in np.fliplr(prim_coords))\n\n  # Step 3: Identify all empty cells adjacent to the primitive locations.\n  # These are the valid destination cells for our pathfinding algorithm.\n  target_positions = set()\n  for px, py in primitive_locations:\n      for dy, dx in ACTION_MAP.keys():\n          ax, ay = px + dx, py + dy\n          # Check if the adjacent cell is within grid bounds and is empty.\n          # A cell is considered empty if the sum of its one-hot vector is 0.\n          if 0 <= ax < width and 0 <= ay < height and grid[ay, ax].sum() == 0:\n              target_positions.add((ax, ay))\n\n  if not target_positions:\n      # No empty, accessible cell next to the primitive exists.\n      return []\n\n  # Step 4: Perform BFS to find the shortest path to a target cell.\n  start_pos = state.pos  # Agent's current (x, y) position.\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n  path, final_pos = None, None\n\n  while queue:\n      current_pos, current_path = queue.popleft()\n\n      # If the current position is a valid destination, we've found the shortest path.\n      if current_pos in target_positions:\n          path = current_path\n          final_pos = current_pos\n          break\n\n      # Explore adjacent cells.\n      for (dy, dx), action in ACTION_MAP.items():\n          nx, ny = current_pos[0] + dx, current_pos[1] + dy\n          neighbor_pos = (nx, ny)\n\n          if 0 <= nx < width and 0 <= ny < height and neighbor_pos not in visited:\n              # The agent can only traverse through empty cells.\n              if grid[ny, nx].sum() == 0:\n                  visited.add(neighbor_pos)\n                  queue.append((neighbor_pos, current_path + [action]))\n\n  if path is None:\n      # No path from the agent's position to any target cell was found.\n      return []\n\n  # Step 5: Construct the final action sequence.\n  # First, determine which primitive location is adjacent to our destination.\n  adjacent_primitive_pos = None\n  for dy, dx in ACTION_MAP.keys():\n      px, py = final_pos[0] + dx, final_pos[1] + dy\n      if (px, py) in primitive_locations:\n          adjacent_primitive_pos = (px, py)\n          break\n  \n  if adjacent_primitive_pos is None:\n      # This case should not be reachable if logic is correct.\n      return []\n\n  # Determine the final move action required to face the primitive.\n  face_dx = adjacent_primitive_pos[0] - final_pos[0]\n  face_dy = adjacent_primitive_pos[1] - final_pos[1]\n  face_action = ACTION_MAP[(face_dy, face_dx)]\n\n  # The full sequence: path to get adjacent, one action to turn, and one to use.\n  return path + [face_action, USE]\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to a primitive and collect it.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    path to a cell adjacent to the target primitive. Since the agent cannot\n    occupy a cell with an item, the goal is to reach a neighboring empty cell.\n    The pathfinding correctly identifies that the agent can only move into\n    completely empty cells.\n\n    Once an adjacent cell is reached, the function computes the final actions\n    required: one action to turn the agent to face the primitive, followed by\n    the 'USE' action to collect it.\n\n    Args:\n        env: The simulation environment, providing access to the current state.\n        primitive (str): The name of the primitive to collect.\n\n    Returns:\n        list[int]: A list of action integers representing the shortest plan\n                   to collect the primitive. Returns an empty list if the\n                   primitive is not found or is unreachable.\n    \"\"\"\n    state = env._current_state\n    world = state.world\n    grid = state.grid\n    start_pos = state.pos\n    grid_shape = grid.shape\n\n    # Action constants are assumed to be defined in the 'craft' module.\n    # We map them to direction vectors (dx, dy) for grid calculations.\n    action_to_vec = {\n        craft.UP: (0, -1),\n        craft.DOWN: (0, 1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n    vec_to_action = {v: k for k, v in action_to_vec.items()}\n\n    # Step 1: Find the integer index for the primitive and locate all instances on the grid.\n    try:\n        primitive_idx = world.cookbook.index[primitive]\n    except KeyError:\n        return []  # Primitive name is invalid.\n\n    primitive_locations = list(zip(*np.where(grid[:, :, primitive_idx] > 0)))\n    if not primitive_locations:\n        return []  # Primitive not found on the map.\n\n    # Step 2: Identify all valid target positions. A target is an empty\n    # cell adjacent to any instance of the primitive.\n    target_positions = set()\n    for prim_pos in primitive_locations:\n        px, py = prim_pos\n        for vec in action_to_vec.values():\n            adj_pos = (px + vec[0], py + vec[1])\n            if (0 <= adj_pos[0] < grid_shape[0] and\n                0 <= adj_pos[1] < grid_shape[1] and\n                # The adjacent cell must be completely empty to be a valid target.\n                np.sum(grid[adj_pos[0], adj_pos[1], :]) == 0):\n                target_positions.add(adj_pos)\n\n    if not target_positions:\n        return []  # Primitive is completely surrounded and unreachable.\n\n    # Step 3: Perform BFS to find the shortest path to a target position.\n    queue = collections.deque([(start_pos, [])])  # Stores (position, path_list)\n    visited = {start_pos}\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        # Goal check: Have we reached a cell adjacent to the primitive?\n        if current_pos in target_positions:\n            # Determine the direction to face to 'USE' the primitive.\n            for vec, action in vec_to_action.items():\n                faced_pos = (current_pos[0] + vec[0], current_pos[1] + vec[1])\n                if (0 <= faced_pos[0] < grid_shape[0] and\n                    0 <= faced_pos[1] < grid_shape[1] and\n                    grid[faced_pos[0], faced_pos[1], primitive_idx] > 0):\n                    \n                    # Found the primitive. The plan is: path to adjacent cell,\n                    # action to turn, and finally the USE action.\n                    turn_action = action\n                    return path + [turn_action, craft.USE]\n\n        # Explore neighbors\n        for action, vec in action_to_vec.items():\n            next_pos = (current_pos[0] + vec[0], current_pos[1] + vec[1])\n\n            if (0 <= next_pos[0] < grid_shape[0] and\n                0 <= next_pos[1] < grid_shape[1] and\n                next_pos not in visited):\n\n                # Agent can only move into completely empty cells.\n                if np.sum(grid[next_pos[0], next_pos[1], :]) == 0:\n                    visited.add(next_pos)\n                    new_path = path + [action]\n                    queue.append((next_pos, new_path))\n\n    # Step 4: If the queue empties, no path was found.\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a cell adjacent to the target primitive. It correctly handles\n  agent orientation to ensure the 'USE' action is successful.\n\n  Args:\n    env: The CraftLab environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n    A list of integer actions to be executed, or an empty list if no path is found.\n  \"\"\"\n  # Action constants corresponding to the environment's action specification.\n  # DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n  ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n\n  # 1. Extract current state information from the environment.\n  state = env._current_state\n  grid = state.grid  # Grid dimensions are (WIDTH, HEIGHT, n_kinds)\n  start_pos = state.pos  # Agent position is a tuple (x, y)\n  primitive_idx = state.world.cookbook.index[primitive]\n\n  # 2. Find all locations of the target primitive.\n  # np.argwhere returns coordinates as (dim0, dim1), which corresponds to (x, y)\n  # for our grid shape (WIDTH, HEIGHT, ...).\n  primitive_locations = np.argwhere(grid[:, :, primitive_idx] > 0)\n  if primitive_locations.size == 0:\n    return []  # Primitive does not exist on the map.\n\n  # 3. Identify valid goal positions for the BFS. A goal is an EMPTY cell\n  # ADJACENT to a primitive. The agent must stand on an empty cell to interact\n  # with an adjacent one. This corrects a common error of pathfinding *onto*\n  # the primitive's blocked cell.\n  goal_positions = set()\n  # Map each goal position back to the primitive it's adjacent to.\n  # This is crucial for determining the final facing direction.\n  goal_to_primitive_map = {}\n  for x, y in primitive_locations:\n    # Check four neighbors: right, left, down, up\n    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n      adj_x, adj_y = x + dx, y + dy\n      if 0 <= adj_x < grid.shape[0] and 0 <= adj_y < grid.shape[1]:\n        # A cell is traversable if it's empty (sum of features is 0).\n        if grid[adj_x, adj_y].sum() == 0:\n          goal_pos = (adj_x, adj_y)\n          goal_positions.add(goal_pos)\n          goal_to_primitive_map[goal_pos] = (x, y)\n\n  if not goal_positions:\n    return []  # No accessible empty cells next to any instance of the primitive.\n\n  # 4. Perform BFS to find the shortest path to a goal position.\n  queue = collections.deque([(start_pos, [])]) # (current_position, path_so_far)\n  visited = {start_pos}\n  path_to_goal = None\n  final_pos = None\n\n  # Handle the edge case where the agent starts at a goal position.\n  if start_pos in goal_positions:\n      path_to_goal = []\n      final_pos = start_pos\n  else:\n    # Run the main BFS loop.\n    while queue:\n      (curr_x, curr_y), path = queue.popleft()\n\n      # Define moves and their corresponding action codes: (dx, dy, action_code)\n      moves = [(0, 1, ACTION_DOWN), (0, -1, ACTION_UP),\n               (-1, 0, ACTION_LEFT), (1, 0, ACTION_RIGHT)]\n\n      for dx, dy, action in moves:\n        next_pos = (curr_x + dx, curr_y + dy)\n        if next_pos in goal_positions:\n          path_to_goal = path + [action]\n          final_pos = next_pos\n          queue.clear() # Stop searching once the shortest path is found.\n          break\n\n        # Continue BFS: check if the next cell is valid and unvisited.\n        nx, ny = next_pos\n        if (0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1] and\n            grid[nx, ny].sum() == 0 and next_pos not in visited):\n          visited.add(next_pos)\n          queue.append((next_pos, path + [action]))\n      if path_to_goal is not None:\n          break\n\n  # 5. If a path was found, finalize the action sequence.\n  if path_to_goal is not None:\n    # This section addresses the critical feedback about final agent orientation.\n    primitive_pos = goal_to_primitive_map[final_pos]\n    required_dx = primitive_pos[0] - final_pos[0]\n    required_dy = primitive_pos[1] - final_pos[1]\n\n    # Determine the action that corresponds to facing the primitive.\n    final_turn_action = -1\n    if (required_dx, required_dy) == (0, 1): final_turn_action = ACTION_DOWN\n    elif (required_dx, required_dy) == (0, -1): final_turn_action = ACTION_UP\n    elif (required_dx, required_dy) == (-1, 0): final_turn_action = ACTION_LEFT\n    elif (required_dx, required_dy) == (1, 0): final_turn_action = ACTION_RIGHT\n\n    # After moving, the agent's direction is that of the last move. If this\n    # is not the direction needed to face the primitive, add a \"turn\" action.\n    # A turn is achieved by executing a move into a blocked cell (the primitive),\n    # which fails to change position but updates the agent's direction.\n    last_move_action = path_to_goal[-1] if path_to_goal else -1 # -1 if no move needed\n    if last_move_action != final_turn_action:\n      path_to_goal.append(final_turn_action)\n\n    # Finally, append the USE action to collect the primitive.\n    path_to_goal.append(ACTION_USE)\n    return path_to_goal\n\n  # No path could be found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find and collect a specified primitive.\n\n  This function implements a robust strategy using Breadth-First Search (BFS)\n  to find the shortest path to the target primitive. It correctly identifies that\n  the agent must move to an empty cell *adjacent* to the primitive, not onto\n  the primitive's cell itself, as item cells are blocked.\n\n  The key features of this implementation are:\n  1.  **Correct Pathfinding Target**: It searches for a path to an empty cell\n      neighboring the primitive.\n  2.  **Obstacle Avoidance**: The BFS correctly treats any non-empty cell as\n      an untraversable obstacle, as per the environment description.\n  3.  **Final Orientation**: It accounts for the agent's need to face the\n      primitive before collection. It generates a final \"turn\" action by\n      bumping into the primitive's blocked cell, which is an effective\n      mechanic in grid-world environments for changing direction without\n      changing position.\n  4.  **Efficiency**: It uses a deque for an efficient BFS implementation and\n      terminates as soon as the first (and therefore shortest) path is found.\n  \"\"\"\n  current_state = env._current_state\n  world = current_state.world\n  grid = current_state.grid\n  start_pos = current_state.pos\n\n  # Action constants and mappings for navigation.\n  # Assumes craft module provides UP, DOWN, LEFT, RIGHT, USE constants.\n  ACTION_VECTORS = {\n      craft.UP: (0, -1),\n      craft.DOWN: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  VECTOR_ACTIONS = {v: k for k, v in ACTION_VECTORS.items()}\n\n  # 1. Setup: Get primitive index and grid dimensions\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    return []  # Primitive name is not valid\n\n  height, width, _ = grid.shape\n\n  # 2. Identify all possible target locations for the BFS\n  # A target is an empty cell adjacent to the primitive.\n  goal_positions = set()\n  primitive_locations = []\n  for r in range(height):\n    for c in range(width):\n      if grid[r, c, primitive_index] > 0:\n        primitive_locations.append((c, r))\n\n  if not primitive_locations:\n    return []  # Primitive not found on the map\n\n  def is_traversable(pos):\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is traversable only if it is completely empty.\n    return grid[y, x].sum() == 0\n\n  for prim_pos in primitive_locations:\n    px, py = prim_pos\n    for _, (dx, dy) in ACTION_VECTORS.items():\n      adj_pos = (px + dx, py + dy)\n      if is_traversable(adj_pos):\n        goal_positions.add(adj_pos)\n\n  if not goal_positions:\n    return []  # No accessible empty cell next to the primitive\n\n  # 3. BFS to find the shortest path to a goal position\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n  path_to_goal = None\n  final_pos = None\n\n  if start_pos in goal_positions:\n    path_to_goal = []\n    final_pos = start_pos\n  else:\n    while queue:\n      current_pos, path = queue.popleft()\n\n      for action, (dx, dy) in ACTION_VECTORS.items():\n        next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n        if next_pos in visited:\n          continue\n\n        if next_pos in goal_positions:\n          path_to_goal = path + [action]\n          final_pos = next_pos\n          break\n\n        if is_traversable(next_pos):\n          visited.add(next_pos)\n          queue.append((next_pos, path + [action]))\n      \n      if path_to_goal is not None:\n        break\n  \n  if path_to_goal is None:\n    return []  # No path found\n\n  # 4. Determine final orientation and collect action\n  # Find the specific primitive location we are now adjacent to.\n  target_primitive_pos = None\n  for _, (dx, dy) in ACTION_VECTORS.items():\n    check_pos = (final_pos[0] + dx, final_pos[1] + dy)\n    cx, cy = check_pos\n    if (0 <= cx < width and 0 <= cy < height) and grid[cy, cx, primitive_index] > 0:\n      target_primitive_pos = check_pos\n      break\n      \n  if target_primitive_pos is None:\n    # This case should not be reached if BFS succeeded.\n    return []\n\n  # To face the primitive, the agent must perform a move action in its direction.\n  # Since the primitive's cell is blocked, this results in a \"bump,\"\n  # changing the agent's direction without changing its position.\n  dx = target_primitive_pos[0] - final_pos[0]\n  dy = target_primitive_pos[1] - final_pos[1]\n  \n  turn_action = VECTOR_ACTIONS[(dx, dy)]\n\n  # The complete sequence: move to adjacent cell, turn (by bumping), then use.\n  return path_to_goal + [turn_action, craft.USE]\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move to, and collect a specified primitive.\n  \n  The strategy is as follows:\n  1. Identify all locations of the target primitive on the grid.\n  2. Determine all valid, empty cells adjacent to these primitive locations. These are the target destinations for the agent.\n  3. Use Breadth-First Search (BFS) to find the shortest path from the agent's current position to any of these target cells.\n     - A cell is considered traversable if it does not contain a non-grabbable item (e.g., water, stone).\n  4. Once a path is found, convert the sequence of coordinates into a sequence of movement actions (UP, DOWN, LEFT, RIGHT).\n  5. After reaching the cell adjacent to the primitive, determine the correct direction to face the primitive.\n  6. If the agent is not already facing the correct direction after its last move, add an extra movement action to turn the agent.\n     - It's assumed that attempting to move into a blocked cell (like the one with the primitive) will cause the agent to turn without changing position.\n  7. Finally, add the 'USE' action to collect the primitive.\n  8. If no path is found, return an empty list.\n  \"\"\"\n  \n  # --- 1. Setup ---\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  cookbook = state.world.cookbook\n  \n  # Check if primitive name is valid\n  if primitive not in cookbook.index.contents:\n      return []\n  primitive_index = cookbook.index[primitive]\n  \n  # Action constants and mappings from (dx, dy) vector to action\n  action_map = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n\n  height, width, _ = grid.shape\n  non_grabbable_indices = state.world.non_grabbable_indices\n\n  def is_traversable(pos):\n      x, y = pos\n      if not (0 <= x < width and 0 <= y < height):\n          return False\n      # A cell is traversable if it contains no non-grabbable items.\n      for i in non_grabbable_indices:\n          if grid[y, x, i] > 0:\n              return False\n      return True\n\n  # --- 2. Find Target Positions ---\n  target_adjacent_cells = set()\n  primitive_locations = []\n  for y in range(height):\n      for x in range(width):\n          if grid[y, x, primitive_index] > 0:\n              primitive_locations.append((x,y))\n\n  for prim_pos in primitive_locations:\n      px, py = prim_pos\n      for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n          adj_pos = (px + dx, py + dy)\n          if is_traversable(adj_pos):\n              target_adjacent_cells.add(adj_pos)\n\n  if not target_adjacent_cells:\n      return [] # No accessible primitive\n\n  # Handle edge case where agent starts next to the primitive\n  if start_pos in target_adjacent_cells:\n      for prim_pos in primitive_locations:\n          if abs(start_pos[0] - prim_pos[0]) + abs(start_pos[1] - prim_pos[1]) == 1:\n              dx, dy = prim_pos[0] - start_pos[0], prim_pos[1] - start_pos[1]\n              required_action = action_map.get((dx, dy))\n              if required_action is not None:\n                  return [required_action, craft.USE]\n      return []\n\n  # --- 3. BFS for Shortest Path ---\n  queue = collections.deque([start_pos])\n  # `came_from` dict stores {child_pos: parent_pos} to reconstruct the path\n  came_from = {start_pos: None}\n  end_pos = None\n\n  while queue:\n      current_pos = queue.popleft()\n      if current_pos in target_adjacent_cells:\n          end_pos = current_pos\n          break\n      cx, cy = current_pos\n      for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n          neighbor_pos = (cx + dx, cy + dy)\n          if neighbor_pos not in came_from and is_traversable(neighbor_pos):\n              came_from[neighbor_pos] = current_pos\n              queue.append(neighbor_pos)\n  \n  # --- 4. Path Reconstruction & Action Generation ---\n  if end_pos is None:\n      return [] # No path found\n\n  path_coords = []\n  curr = end_pos\n  while curr is not None:\n      path_coords.append(curr)\n      curr = came_from[curr]\n  path_coords.reverse() # Path is now [start_pos, ..., end_pos]\n\n  actions = []\n  for i in range(len(path_coords) - 1):\n      p1, p2 = path_coords[i], path_coords[i+1]\n      dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n      action = action_map.get((dx, dy))\n      if action is not None:\n          actions.append(action)\n  \n  # --- 5. Final Orientation and USE Action ---\n  primitive_pos = None\n  ex, ey = end_pos\n  for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n      check_pos = (ex + dx, ey + dy)\n      # Check if neighbor contains the primitive\n      if (0 <= check_pos[0] < width and 0 <= check_pos[1] < height and\n              grid[check_pos[1], check_pos[0], primitive_index] > 0):\n          primitive_pos = check_pos\n          break\n  \n  if primitive_pos is None:\n      return [] # Should not happen with correct logic\n  \n  face_dx, face_dy = primitive_pos[0] - end_pos[0], primitive_pos[1] - end_pos[1]\n  required_facing_action = action_map.get((face_dx, face_dy))\n  \n  last_move_action = actions[-1] if actions else None\n  \n  if last_move_action != required_facing_action:\n      actions.append(required_facing_action)\n      \n  actions.append(craft.USE)\n\n  return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path from the agent's current position to a location adjacent to the\n  target primitive. It then appends the necessary actions to turn towards the\n  primitive and collect it.\n\n  Args:\n    env: The simulation environment instance, providing access to the current state.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\", \"IRON\").\n\n  Returns:\n    A list of integer actions (e.g., [3, 3, 1, 4]) representing the optimal\n    plan to collect the primitive. Returns an empty list if the primitive is\n    unreachable or not present on the map.\n  \"\"\"\n  # Action constants based on the environment's action specification.\n  # CraftLab.action_specs: DOWN->0, UP->1, LEFT->2, RIGHT->3, USE->4\n  class Actions:\n    DOWN = 0\n    UP = 1\n    LEFT = 2\n    RIGHT = 3\n    USE = 4\n\n  # Map grid movements (dy, dx) to corresponding actions.\n  # Assumes a (row, col) or (y, x) coordinate system.\n  DIR_TO_ACTION = {\n      (-1, 0): Actions.UP,    # Move up: y-coordinate decreases\n      (1, 0): Actions.DOWN,   # Move down: y-coordinate increases\n      (0, -1): Actions.LEFT,  # Move left: x-coordinate decreases\n      (0, 1): Actions.RIGHT, # Move right: x-coordinate increases\n  }\n\n  state = env._current_state\n  grid = state.grid\n  # The grid shape is assumed to be (HEIGHT, WIDTH, n_kinds) for grid[y, x] indexing.\n  height, width, _ = grid.shape\n  start_pos = state.pos  # Assumed to be a (y, x) tuple\n\n  try:\n    primitive_idx = state.world.cookbook.index[primitive]\n  except KeyError:\n    return []  # Primitive name is not valid in this world's cookbook.\n\n  # --- Step 1: Identify all valid destination cells for the agent ---\n  # A valid destination is an empty cell immediately adjacent to the target primitive.\n  primitive_locs = np.argwhere(grid[:, :, primitive_idx] > 0)\n  if primitive_locs.size == 0:\n    return []  # The target primitive does not exist on the current grid.\n\n  # `targets` maps a valid destination position (y, x) to the primitive's\n  # position (py, px) that it is adjacent to.\n  targets = {}\n  for prim_pos in primitive_locs:\n    py, px = prim_pos[0], prim_pos[1]\n    for dy, dx in DIR_TO_ACTION.keys():\n      adj_pos = (py + dy, px + dx)\n      \n      # Check if the adjacent cell is within grid bounds\n      if not (0 <= adj_pos[0] < height and 0 <= adj_pos[1] < width):\n        continue\n      \n      # Check if the cell is empty (i.e., the agent can move onto it).\n      # An empty cell's one-hot feature vector sums to 0.\n      if grid[adj_pos[0], adj_pos[1], :].sum() == 0:\n        if adj_pos not in targets:\n            targets[adj_pos] = (py, px)\n\n  if not targets:\n    # This occurs if all instances of the primitive are completely surrounded.\n    return []\n\n  # --- Step 2: Use BFS to find the shortest path to any target cell ---\n  queue = collections.deque([(start_pos, [])]) # Each item is (position, path_list)\n  visited = {start_pos}\n  found_path_info = None\n\n  while queue:\n    current_pos, path = queue.popleft()\n\n    # Goal check: Have we reached a valid destination cell?\n    if current_pos in targets:\n      found_path_info = (current_pos, path)\n      break  # Shortest path found\n\n    # Explore valid, unvisited neighbors\n    for (dy, dx), action in DIR_TO_ACTION.items():\n      neighbor_pos = (current_pos[0] + dy, current_pos[1] + dx)\n      ny, nx = neighbor_pos\n\n      # Check if neighbor is valid for traversal\n      if (0 <= ny < height and 0 <= nx < width and\n          neighbor_pos not in visited and\n          grid[ny, nx, :].sum() == 0): # Can only move into empty cells\n        \n        visited.add(neighbor_pos)\n        new_path = path + [action]\n        queue.append((neighbor_pos, new_path))\n        \n  # --- Step 3: Construct the final action sequence if a path was found ---\n  if found_path_info:\n    destination_pos, move_actions = found_path_info\n    \n    # Determine the direction to face the primitive from our destination.\n    primitive_to_face_pos = targets[destination_pos]\n    dy = primitive_to_face_pos[0] - destination_pos[0]\n    dx = primitive_to_face_pos[1] - destination_pos[1]\n    \n    # Get the action required to turn in that direction.\n    # Issuing this move action into the blocked primitive cell will cause the agent to turn.\n    turn_action = DIR_TO_ACTION[(dy, dx)]\n    \n    # The complete plan: move to the adjacent cell, turn to face, and collect.\n    full_action_sequence = move_actions + [turn_action, Actions.USE]\n    return full_action_sequence\n\n  # If the BFS completes without finding a path, the primitive is unreachable.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move adjacent to, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the \n  shortest path to a cell adjacent to the target primitive. It correctly handles\n  obstacles by only pathfinding through empty cells and ensures the agent is\n  facing the primitive before issuing the 'USE' command to collect it.\n\n  Args:\n      env: The CraftLab environment instance.\n      primitive (str): The name of the primitive to collect.\n\n  Returns:\n      list[int]: A list of action integers representing the optimal plan,\n                  or an empty list if the primitive is unreachable.\n  \"\"\"\n  \n  # 1. Initialization and Setup\n  state = env._current_state\n  grid = state.grid\n  cookbook = state.world.cookbook\n  start_pos = state.pos\n  grid_width, grid_height, _ = grid.shape\n\n  # Define movement deltas and their corresponding actions.\n  # The actions (craft.UP, etc.) are assumed to be integer constants.\n  delta_to_action = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  deltas = list(delta_to_action.keys())\n\n  # 2. Identify Target and Goal Positions\n  # The \"target\" is the cell containing the primitive. The \"goal\" is an empty,\n  # adjacent cell from which the agent can collect the primitive.\n  try:\n      primitive_index = cookbook.index[primitive]\n  except KeyError:\n      return [] # Primitive name is not valid\n\n  target_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  \n  if target_locations.shape[0] == 0:\n      return [] # Primitive does not exist on the map.\n\n  goal_positions = set()\n  goal_to_target_map = {} # Maps a goal cell to its corresponding target primitive cell\n\n  for tx, ty in target_locations:\n      for dx, dy in deltas:\n          # A potential goal cell is adjacent to the target\n          gx, gy = tx + dx, ty + dy \n\n          if not (0 <= gx < grid_width and 0 <= gy < grid_height):\n              continue\n          \n          # A goal cell must be empty for the agent to stand on it.\n          # grid[gx, gy].sum() == 0 is a robust check for an empty cell.\n          if grid[gx, gy].sum() == 0:\n              goal_pos = (gx, gy)\n              goal_positions.add(goal_pos)\n              goal_to_target_map[goal_pos] = (tx, ty)\n\n  if not goal_positions:\n      # This occurs if all primitives are completely surrounded, with no adjacent empty cells.\n      return []\n\n  # Handle the edge case where the agent is already at a valid goal position.\n  if start_pos in goal_positions:\n      target_pos = goal_to_target_map[start_pos]\n      face_delta = (target_pos[0] - start_pos[0], target_pos[1] - start_pos[1])\n      face_action = delta_to_action[face_delta]\n      return [face_action, craft.USE]\n\n  # 3. Breadth-First Search (BFS) for the shortest path\n  queue = collections.deque([(start_pos, [])])  # Stores (position, list_of_actions)\n  visited = {start_pos}\n\n  while queue:\n      current_pos, path = queue.popleft()\n\n      # Explore neighbors\n      cx, cy = current_pos\n      for dx, dy in deltas:\n          neighbor_pos = (cx + dx, cy + dy)\n          nx, ny = neighbor_pos\n\n          if not (0 <= nx < grid_width and 0 <= ny < grid_height) or neighbor_pos in visited:\n              continue\n          \n          # Check if the neighbor is one of our goal positions\n          if neighbor_pos in goal_positions:\n              # Found the shortest path to an adjacent cell.\n              move_action = delta_to_action[(dx, dy)]\n              final_path = path + [move_action]\n\n              # Determine the final action to FACE the primitive. This action will\n              # turn the agent, even if the target cell is blocked.\n              target_pos = goal_to_target_map[neighbor_pos]\n              face_delta = (target_pos[0] - neighbor_pos[0], target_pos[1] - neighbor_pos[1])\n              face_action = delta_to_action[face_delta]\n              \n              final_path.append(face_action)\n              final_path.append(craft.USE)\n              return final_path\n\n          # If not a goal, check if it's a valid empty cell to continue pathfinding.\n          if grid[nx, ny].sum() == 0:\n              visited.add(neighbor_pos)\n              move_action = delta_to_action[(dx, dy)]\n              new_path = path + [move_action]\n              queue.append((neighbor_pos, new_path))\n  \n  # 4. No Path Found\n  # If the queue is exhausted, no goal position is reachable.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, navigate to, and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to an empty cell adjacent to the target primitive. It then\n  calculates the necessary turning actions to face the primitive before\n  issuing the final 'USE' command to collect it.\n\n  Args:\n      env: The CraftLab environment instance.\n      primitive: The string name of the primitive to collect.\n\n  Returns:\n      A list of integer actions representing the optimal plan, or an empty\n      list if the primitive is unreachable.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  # Action and direction constants for clarity. Assumes a standard mapping.\n  # Directions are ordered clockwise: UP, RIGHT, DOWN, LEFT.\n  ACTIONS = {'DOWN': 1, 'UP': 0, 'LEFT': 2, 'RIGHT': 3, 'USE': 4}\n  DIRECTIONS = {'UP': 0, 'RIGHT': 1, 'DOWN': 2, 'LEFT': 3}\n  \n  # Mapping from action to the (dy, dx) vector of movement.\n  ACTION_VECTORS = {\n      ACTIONS['UP']: (-1, 0),\n      ACTIONS['DOWN']: (1, 0),\n      ACTIONS['LEFT']: (0, -1),\n      ACTIONS['RIGHT']: (0, 1),\n  }\n  \n  VECTORS_TO_ACTION = {v: k for k, v in ACTION_VECTORS.items()}\n\n  # Mapping from an action to the direction the agent faces after the action.\n  ACTION_TO_DIRECTION = {\n      ACTIONS['UP']: DIRECTIONS['UP'],\n      ACTIONS['RIGHT']: DIRECTIONS['RIGHT'],\n      ACTIONS['DOWN']: DIRECTIONS['DOWN'],\n      ACTIONS['LEFT']: DIRECTIONS['LEFT'],\n  }\n  \n  # Mapping from a relative vector to the direction it represents.\n  VECTOR_TO_DIRECTION = {\n      (-1, 0): DIRECTIONS['UP'],\n      (0, 1): DIRECTIONS['RIGHT'],\n      (1, 0): DIRECTIONS['DOWN'],\n      (0, -1): DIRECTIONS['LEFT'],\n  }\n\n  primitive_idx = state.world.cookbook.index[primitive]\n  height, width = grid.shape[:2]\n\n  # 1. Find all locations of the primitive and identify valid adjacent goal positions.\n  goal_positions = set()\n  primitive_locations = []\n  for r in range(height):\n      for c in range(width):\n          if grid[r, c, primitive_idx] > 0:\n              primitive_locations.append((r, c))\n\n  if not primitive_locations:\n      return [] # Primitive does not exist on the map.\n\n  for r_prim, c_prim in primitive_locations:\n      for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n          r_adj, c_adj = r_prim + dr, c_prim + dc\n          if 0 <= r_adj < height and 0 <= c_adj < width:\n              # A valid goal is an empty cell adjacent to the primitive.\n              if grid[r_adj, c_adj, :].sum() == 0:\n                  goal_positions.add((r_adj, c_adj))\n\n  if not goal_positions:\n      return [] # Primitive is blocked and has no accessible adjacent cells.\n\n  # 2. Perform BFS to find the shortest path to a goal position.\n  queue = collections.deque([(start_pos, [])]) # (position, path_of_actions)\n  visited = {start_pos}\n  \n  path_to_goal = None\n  final_pos = None\n\n  while queue:\n      current_pos, path = queue.popleft()\n\n      if current_pos in goal_positions:\n          path_to_goal = path\n          final_pos = current_pos\n          break\n\n      for action, (dr, dc) in ACTION_VECTORS.items():\n          next_pos = (current_pos[0] + dr, current_pos[1] + dc)\n          \n          if (0 <= next_pos[0] < height and 0 <= next_pos[1] < width and\n                  next_pos not in visited):\n              # Agent can only move into empty cells.\n              if grid[next_pos[0], next_pos[1], :].sum() == 0:\n                  visited.add(next_pos)\n                  new_path = path + [action]\n                  queue.append((next_pos, new_path))\n\n  if path_to_goal is None:\n      return [] # No path found.\n\n  # 3. Determine final orientation and add turning actions if necessary.\n  \n  # Find the specific primitive location we are next to.\n  primitive_pos = None\n  for r_prim, c_prim in primitive_locations:\n      if abs(r_prim - final_pos[0]) + abs(c_prim - final_pos[1]) == 1:\n          primitive_pos = (r_prim, c_prim)\n          break\n  \n  # Calculate the direction needed to face the primitive.\n  dy = primitive_pos[0] - final_pos[0]\n  dx = primitive_pos[1] - final_pos[1]\n  required_dir = VECTOR_TO_DIRECTION[(dy, dx)]\n  \n  # Determine current direction after movement.\n  if path_to_goal:\n      last_move_action = path_to_goal[-1]\n      current_dir = ACTION_TO_DIRECTION[last_move_action]\n  else:\n      # Agent started next to the primitive, no moves were needed.\n      current_dir = start_dir\n\n  # Calculate turning actions.\n  turn_actions = []\n  # Difference in clockwise steps (0=none, 1=right, 2=180, 3=left)\n  turn_diff = (required_dir - current_dir + 4) % 4\n  \n  if turn_diff == 1: # Turn right\n      turn_actions.append(ACTIONS['RIGHT'])\n  elif turn_diff == 2: # Turn 180 degrees\n      turn_actions.extend([ACTIONS['RIGHT'], ACTIONS['RIGHT']])\n  elif turn_diff == 3: # Turn left\n      turn_actions.append(ACTIONS['LEFT'])\n  \n  # 4. Combine movement, turning, and final USE action.\n  return path_to_goal + turn_actions + [ACTIONS['USE']]\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a cell adjacent to the target primitive. It ensures that\n  the final movement action in the path also correctly orients the agent to\n  face the primitive, allowing for a subsequent 'USE' action to collect it.\n\n  The pathfinding logic treats any cell with an item on it as non-traversable,\n  ensuring the agent only moves through empty cells.\n  \"\"\"\n  \n  # Action constants and mappings from direction vectors (dx, dy) to actions\n  DIR_TO_ACTION = {\n      (0, -1): craft.UP,\n      (0, 1):  craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0):  craft.RIGHT,\n  }\n  USE_ACTION = craft.USE\n\n  # 1. Initialize environment state and parameters\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos  # Agent's starting position (x, y)\n  h, w, _ = grid.shape\n\n  try:\n      primitive_idx = state.world.cookbook.index[primitive]\n  except KeyError:\n      # The requested primitive does not exist in the game's vocabulary.\n      return []\n\n  # 2. Identify all locations of the primitive on the grid.\n  primitive_locations = set()\n  for r in range(h):\n      for c in range(w):\n          if grid[r, c, primitive_idx] > 0:\n              primitive_locations.add((c, r))  # Store as (x, y)\n\n  if not primitive_locations:\n      return []  # Primitive is not present on the map.\n\n  # 3. Determine valid goal states. A goal state is an empty cell adjacent\n  # to a primitive, paired with the direction the agent must face to collect it.\n  # We store this as a dictionary: {goal_position: required_facing_vector}\n  goals = {}\n  for prim_x, prim_y in primitive_locations:\n      for face_dir_vec in DIR_TO_ACTION.keys():\n          dx, dy = face_dir_vec\n          # The position to stand on is adjacent to the primitive.\n          # pos = primitive_pos - face_direction\n          adj_pos = (prim_x - dx, prim_y - dy)\n          adj_x, adj_y = adj_pos\n\n          # Check if the adjacent cell is within bounds and is empty.\n          if 0 <= adj_y < h and 0 <= adj_x < w and grid[adj_y, adj_x].sum() == 0:\n              goals[adj_pos] = face_dir_vec\n\n  if not goals:\n      return []  # Primitive is completely surrounded by obstacles.\n\n  # 4. Perform BFS to find the shortest path to a valid goal state.\n  # The queue stores tuples of (current_position, path_of_actions).\n  queue = collections.deque([(start_pos, [])])\n  # 'visited' tracks positions we've already planned a path to.\n  visited = {start_pos}\n\n  while queue:\n      current_pos, path = queue.popleft()\n\n      # Explore all possible moves from the current position.\n      for move_dir_vec, action in DIR_TO_ACTION.items():\n          dx, dy = move_dir_vec\n          next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n          \n          # Check if this move achieves a goal state.\n          # The agent must land on a goal position AND the move direction\n          # must match the required facing direction for that goal.\n          if next_pos in goals and goals[next_pos] == move_dir_vec:\n              # Solution found: path to move adjacent, plus the USE action.\n              return path + [action, USE_ACTION]\n\n          # If not a solution, check if it's a valid step for further search.\n          next_x, next_y = next_pos\n          if (0 <= next_y < h and 0 <= next_x < w and\n                  next_pos not in visited and\n                  grid[next_y, next_x].sum() == 0): # Must be an empty cell\n              \n              visited.add(next_pos)\n              new_path = path + [action]\n              queue.append((next_pos, new_path))\n  \n  # If the queue is exhausted and no path was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Finds the shortest sequence of actions to move adjacent to a primitive and collect it.\n\n  This function uses Breadth-First Search (BFS) to explore possible paths from the\n  agent's current position. The key aspects of the implementation are:\n  1.  **Correct Goal State**: The goal is not just to be near a primitive, but to\n      execute a move that lands the agent in an empty cell while facing the\n      primitive. This ensures the subsequent 'USE' action is valid.\n  2.  **Valid Moves**: The agent can only move into cells that are completely empty.\n      Any item, whether it's a resource or a non-grabbable obstacle like stone,\n      makes a cell non-traversable.\n  3.  **Pathfinding**: BFS guarantees finding the shortest path in terms of the\n      number of actions (steps). The state in our BFS queue is a tuple containing\n      the agent's position and the list of actions taken to reach it.\n\n  The algorithm proceeds as follows:\n  -   It first identifies the grid locations of the target primitive.\n  -   It checks if the agent is already in a position to collect the primitive.\n  -   It then initiates a BFS, exploring outward from the start position. For each\n      potential move, it checks if the destination cell is empty and unvisited.\n  -   If a move is valid, it then checks if that move also satisfies the goal\n      condition (i.e., puts the agent in a position facing the primitive).\n  -   If a goal state is found, the path of actions is returned, appended with\n      the final 'USE' action. If the entire grid is explored without finding a\n      path, an empty list is returned.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  cookbook = state.world.cookbook\n  start_pos = state.pos  # Assumed to be (x, y)\n  start_dir = state.dir\n\n  # 1. Validate the primitive and get its index.\n  primitive_idx = cookbook.index[primitive]\n  # A primitive must be in the 'primitives' set to be collectible.\n  if primitive_idx is None or primitive_idx not in cookbook.primitives:\n      return []\n\n  # 2. Define mappings for coordinates and actions, assuming an (x, y) grid.\n  # grid.shape is (WIDTH, HEIGHT, ...), so grid access is grid[x, y].\n  grid_w, grid_h = grid.shape[0], grid.shape[1]\n  \n  # Map action constants to (dx, dy) position deltas.\n  action_to_delta = {\n      craft.UP: (0, -1),\n      craft.DOWN: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n\n  # We assume the agent's direction `dir` corresponds to the move actions.\n  # e.g., dir 0 corresponds to UP, dir 1 to DOWN, etc.\n  dir_to_delta = action_to_delta\n\n  # 3. Find all locations of the target primitive.\n  primitive_locs = set()\n  for x in range(grid_w):\n      for y in range(grid_h):\n          if grid[x, y, primitive_idx] > 0:\n              primitive_locs.add((x, y))\n\n  if not primitive_locs:\n      return [] # Primitive does not exist on the map.\n\n  # 4. Initial check: Is the agent already facing the primitive?\n  if start_dir in dir_to_delta:\n      dx_start, dy_start = dir_to_delta[start_dir]\n      faced_pos_start = (start_pos[0] + dx_start, start_pos[1] + dy_start)\n      if faced_pos_start in primitive_locs:\n          return [craft.USE]\n\n  # 5. BFS to find the shortest path of actions.\n  queue = collections.deque([(start_pos, [])])  # State: (position, path_of_actions)\n  visited = {start_pos}\n\n  while queue:\n      (x_curr, y_curr), path = queue.popleft()\n\n      # Explore all possible moves from the current position.\n      for action, (dx, dy) in action_to_delta.items():\n          next_pos = (x_curr + dx, y_curr + dy)\n\n          # Ensure the next position is within the grid boundaries.\n          if not (0 <= next_pos[0] < grid_w and 0 <= next_pos[1] < grid_h):\n              continue\n          \n          # A move is only valid if it lands on an empty cell that hasn't been visited.\n          is_traversable = np.sum(grid[next_pos[0], next_pos[1], :]) == 0\n          if next_pos in visited or not is_traversable:\n              continue\n\n          # This is a valid, new empty cell to move to.\n          # Now, check if this move also achieves the goal orientation.\n          # After moving with `action`, we are at `next_pos` and facing the direction\n          # corresponding to `action`. The cell in front is `next_pos + delta_of_action`.\n          faced_pos_after_move = (next_pos[0] + dx, next_pos[1] + dy)\n          \n          if faced_pos_after_move in primitive_locs:\n              # Goal found! We moved to an empty cell and are now facing the primitive.\n              return path + [action, craft.USE]\n          \n          # If not a goal state, add this new valid position to the queue for exploration.\n          visited.add(next_pos)\n          queue.append((next_pos, path + [action]))\n\n  return [] # No path found.\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a location from which the agent can collect the target\n  primitive. The state in the BFS includes both the agent's position and its\n  direction, ensuring that the final action sequence leaves the agent correctly\n  oriented to perform the 'USE' action on the primitive.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of integer actions representing the shortest plan to collect the\n    primitive. Returns an empty list if the primitive is not on the map or\n    no path can be found.\n  \"\"\"\n  \n  # Based on the problem description for CraftLab.action_specs:\n  # DOWN -> 0, UP -> 1, LEFT -> 2, RIGHT -> 3, USE -> 4\n  ACTION_DOWN, ACTION_UP, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 0, 1, 2, 3, 4\n\n  state = env._current_state\n  grid = state.grid\n  h, w = grid.shape[0], grid.shape[1]\n  primitive_index = state.world.cookbook.index[primitive]\n\n  # Mappings derived from the documentation of CraftState.step and CraftLab.action_specs\n  # The environment uses (row, col) coordinates.\n  # Directions are encoded as: 0:UP, 1:RIGHT, 2:DOWN, 3:LEFT\n  action_to_dir = {ACTION_UP: 0, ACTION_RIGHT: 1, ACTION_DOWN: 2, ACTION_LEFT: 3}\n  dir_to_delta = {\n      0: (-1, 0),  # UP\n      1: (0, 1),   # RIGHT\n      2: (1, 0),   # DOWN\n      3: (0, -1),  # LEFT\n  }\n  action_to_delta = {action: dir_to_delta[direction] for action, direction in action_to_dir.items()}\n\n  # Helper function to determine if a grid cell is blocked (impassable).\n  # According to the game rules, any non-empty cell is blocked.\n  def is_blocked(pos):\n      r, c = pos\n      if not (0 <= r < h and 0 <= c < w):\n          return True  # Out of bounds is considered blocked\n      return grid[r, c].sum() > 0\n\n  # Step 1: Find all locations of the target primitive on the grid.\n  primitive_locs = set()\n  for r in range(h):\n      for c in range(w):\n          if grid[r, c, primitive_index] > 0:\n              primitive_locs.add((r, c))\n\n  if not primitive_locs:\n      return []  # Primitive does not exist on the map.\n\n  # Step 2: Perform BFS. The state includes position and direction.\n  # Queue stores: (current_position, current_direction, path_taken)\n  q = collections.deque([(state.pos, state.dir, [])])\n  # Visited set stores: (position, direction) to avoid cycles.\n  visited = set([(state.pos, state.dir)])\n\n  while q:\n      pos, direction, path = q.popleft()\n\n      # Step 3: Check for goal condition.\n      # The goal is reached if the agent is facing a cell with the primitive.\n      dr, dc = dir_to_delta[direction]\n      fwd_pos = (pos[0] + dr, pos[1] + dc)\n\n      if fwd_pos in primitive_locs:\n          # Found a valid path. Append the USE action to collect.\n          return path + [ACTION_USE]\n\n      # Step 4: Expand to neighbors by trying all move actions.\n      for action in [ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT]:\n          dr, dc = action_to_delta[action]\n          next_pos = (pos[0] + dr, pos[1] + dc)\n\n          # An agent can only move into an empty (non-blocked) cell.\n          if is_blocked(next_pos):\n              continue\n\n          # The new direction is determined by the move action taken.\n          next_dir = action_to_dir[action]\n          \n          if (next_pos, next_dir) not in visited:\n              visited.add((next_pos, next_dir))\n              new_path = path + [action]\n              q.append((next_pos, next_dir, new_path))\n              \n  # If the queue empties and no solution was found, no path exists.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a specified primitive.\n\n    This function implements a Breadth-First Search (BFS) algorithm to find the\n    shortest path from the agent's current position to a cell adjacent to the\n    target primitive. It correctly handles obstacles by only traversing empty\n    cells. Once an adjacent cell is reached, it generates the final actions to\n    turn towards the primitive and collect it.\n\n    Args:\n        env (CraftLab): The environment instance.\n        primitive (str): The name of the primitive to collect.\n\n    Returns:\n        list[int]: A list of action integers representing the optimal plan.\n                   Returns an empty list if the primitive is not on the map,\n                   is inaccessible, or no path exists.\n    \"\"\"\n    # 1. Initialization and Constants\n    \n    # Action mapping as described in the prompt's `action_specs` description:\n    # DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n    ACTION_MAP = {'DOWN': 0, 'UP': 1, 'LEFT': 2, 'RIGHT': 3, 'USE': 4}\n    \n    # Map actions to (dx, dy) changes for an (x, y) coordinate system.\n    ACTION_DELTAS = {\n        ACTION_MAP['UP']:    (0, -1),\n        ACTION_MAP['DOWN']:  (0, 1),\n        ACTION_MAP['LEFT']:  (-1, 0),\n        ACTION_MAP['RIGHT']: (1, 0),\n    }\n\n    # Reverse mapping to find an action given a (dx, dy) delta.\n    ACTION_FROM_DELTA = {v: k for k, v in ACTION_DELTAS.items()}\n\n    state = env._current_state\n    grid = state.grid\n    start_pos = state.pos  # Position is an (x, y) tuple.\n    \n    # Grid shape is (WIDTH, HEIGHT, n_kinds) as per documentation.\n    width, height, _ = grid.shape\n    \n    try:\n        primitive_idx = state.world.cookbook.index[primitive]\n    except KeyError:\n        # The primitive name is not valid in this world's cookbook.\n        return []\n\n    # 2. Identify BFS Goal Locations\n\n    # Find all (x, y) coordinates of the target primitive.\n    # For a (W, H, K) grid, np.argwhere returns (x, y) index pairs.\n    primitive_locations = np.argwhere(grid[:, :, primitive_idx] > 0)\n    if primitive_locations.shape[0] == 0:\n        return [] # Primitive does not exist on the map.\n\n    # The true goals for BFS are empty, traversable cells *adjacent* to the primitive.\n    goals = set()\n    # This dictionary maps each valid goal cell to the primitive it's next to.\n    goal_to_primitive_map = {}\n    \n    for x, y in primitive_locations:\n        primitive_pos = (x, y)\n        for dx, dy in ACTION_DELTAS.values():\n            adj_pos = (x + dx, y + dy)\n            \n            # Check if adjacent cell is within map bounds.\n            if 0 <= adj_pos[0] < width and 0 <= adj_pos[1] < height:\n                # A cell is traversable only if it is completely empty. Any item,\n                # grabbable or not, makes a cell non-traversable for movement.\n                if grid[adj_pos[0], adj_pos[1]].sum() == 0:\n                    goals.add(adj_pos)\n                    goal_to_primitive_map[adj_pos] = primitive_pos\n\n    if not goals:\n        # Primitive exists but has no empty adjacent cells.\n        return []\n\n    # 3. Perform BFS to Find Shortest Path\n    \n    queue = collections.deque([start_pos])\n    visited = {start_pos}\n    # `came_from` stores {child_pos: (parent_pos, action_from_parent)}\n    # This allows for efficient path reconstruction.\n    came_from = {start_pos: None}\n    found_goal_pos = None\n\n    if start_pos in goals:\n        found_goal_pos = start_pos\n    else:\n        while queue:\n            current_pos = queue.popleft()\n            \n            for action, (dx, dy) in ACTION_DELTAS.items():\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n                if 0 <= next_pos[0] < width and 0 <= next_pos[1] < height and next_pos not in visited:\n                    # Check if this neighbor is a goal first.\n                    if next_pos in goals:\n                        visited.add(next_pos)\n                        came_from[next_pos] = (current_pos, action)\n                        found_goal_pos = next_pos\n                        queue.clear() # Path found, stop searching.\n                        break\n                    \n                    # If not a goal, check if it's a valid path cell (empty).\n                    if grid[next_pos[0], next_pos[1]].sum() == 0:\n                        visited.add(next_pos)\n                        came_from[next_pos] = (current_pos, action)\n                        queue.append(next_pos)\n            \n            if found_goal_pos:\n                break\n    \n    if found_goal_pos is None:\n        # No path exists from start to any goal cell.\n        return []\n\n    # 4. Reconstruct Path and Final Action Sequence\n\n    # Backtrack from the goal to the start to build the path of actions.\n    path_actions = []\n    curr = found_goal_pos\n    while curr != start_pos:\n        prev, action = came_from[curr]\n        path_actions.append(action)\n        curr = prev\n    path_actions.reverse()\n    \n    # Determine the final actions: turn to face the primitive, then USE.\n    primitive_pos = goal_to_primitive_map[found_goal_pos]\n    final_dx = primitive_pos[0] - found_goal_pos[0]\n    final_dy = primitive_pos[1] - found_goal_pos[1]\n    \n    # This move action will cause the agent to turn to face the primitive.\n    # Since the primitive's cell is blocked, the agent won't move, only turn.\n    final_turn_action = ACTION_FROM_DELTA[(final_dx, final_dy)]\n    \n    full_action_list = path_actions + [final_turn_action, ACTION_MAP['USE']]\n\n    return full_action_list\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a specified primitive.\n\n    This function implements a robust strategy based on Breadth-First Search (BFS)\n    to find the shortest path to a primitive. It correctly identifies that the\n    agent must navigate to an empty cell *adjacent* to the primitive, not onto\n    the primitive's cell itself. It also includes logic to ensure the agent is\n    facing the primitive before attempting to collect it, generating additional\n    turning actions if necessary.\n\n    The strategy is as follows:\n    1.  Identify all locations of the target primitive on the grid.\n    2.  Determine all valid goal positions, which are empty cells adjacent to\n        any instance of the primitive.\n    3.  Use BFS to find the shortest path of traversable (empty) cells from the\n        agent's current position to any of the goal positions.\n    4.  Convert the found path of coordinates into a sequence of move actions\n        (UP, DOWN, LEFT, RIGHT).\n    5.  Check the agent's final orientation. If it's not facing the primitive,\n        generate a sequence of \"out-and-back\" moves to turn the agent in place.\n    6.  Append the 'USE' action to collect the primitive.\n    7.  If no path is found, return an empty list.\n    \"\"\"\n    state = env._current_state\n    grid = state.grid\n    # The grid shape from numpy is (height, width), so we extract them correctly.\n    HEIGHT, WIDTH, _ = grid.shape\n\n    # Action constants for readability, based on CraftLab's action spec.\n    # DOWN\u21920, UP\u21921, LEFT\u21922, RIGHT\u21923, USE\u21924\n    ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT, ACTION_USE = 1, 0, 2, 3, 4\n\n    # Mappings for pathfinding logic\n    DELTA_TO_ACTION = {\n        (0, -1): ACTION_UP,    # (dx, dy)\n        (0, 1): ACTION_DOWN,\n        (-1, 0): ACTION_LEFT,\n        (1, 0): ACTION_RIGHT,\n    }\n    ACTION_TO_DELTA = {v: k for k, v in DELTA_TO_ACTION.items()}\n    # Assumed mapping for CraftState.dir attribute for when the agent does not move.\n    DIR_TO_DELTA = {\n        0: (0, -1),  # 0: UP\n        1: (1, 0),   # 1: RIGHT\n        2: (0, 1),   # 2: DOWN\n        3: (-1, 0),  # 3: LEFT\n    }\n\n    primitive_idx = state.world.cookbook.index[primitive]\n    start_pos = state.pos  # (x, y)\n\n    # Step 1 & 2: Find all valid, empty goal positions adjacent to the primitive.\n    primitive_locations_yx = np.argwhere(grid[:, :, primitive_idx] > 0)\n    if primitive_locations_yx.shape[0] == 0:\n        return []  # Primitive does not exist on the map.\n\n    goal_positions = set()\n    goal_to_primitive_map = {}  # Map goal cell to the primitive cell it's for\n\n    for prim_pos_yx in primitive_locations_yx:\n        prim_pos = (prim_pos_yx[1], prim_pos_yx[0])  # Convert (y, x) to (x, y)\n        for dx, dy in DELTA_TO_ACTION.keys():\n            adj_pos = (prim_pos[0] + dx, prim_pos[1] + dy)\n            # Check bounds\n            if 0 <= adj_pos[0] < WIDTH and 0 <= adj_pos[1] < HEIGHT:\n                # A cell is traversable only if it's completely empty.\n                if grid[adj_pos[1], adj_pos[0], :].sum() == 0:\n                    goal_positions.add(adj_pos)\n                    goal_to_primitive_map[adj_pos] = prim_pos\n\n    if not goal_positions:\n        return []  # No accessible empty cell next to any primitive.\n\n    # Step 3: BFS to find the shortest path to a goal position.\n    queue = collections.deque([(start_pos, [start_pos])])\n    visited = {start_pos}\n    path_to_goal = None\n\n    if start_pos in goal_positions:\n        path_to_goal = [start_pos]\n    else:\n        while queue:\n            curr_pos, path = queue.popleft()\n            for dx, dy in DELTA_TO_ACTION.keys():\n                next_pos = (curr_pos[0] + dx, curr_pos[1] + dy)\n                if next_pos in visited or not (0 <= next_pos[0] < WIDTH and 0 <= next_pos[1] < HEIGHT):\n                    continue\n                # Agent can only move through empty cells.\n                if grid[next_pos[1], next_pos[0], :].sum() == 0:\n                    visited.add(next_pos)\n                    new_path = path + [next_pos]\n                    if next_pos in goal_positions:\n                        path_to_goal = new_path\n                        queue.clear() # Found shortest path, exit loop\n                        break\n                    queue.append((next_pos, new_path))\n\n    if not path_to_goal:\n        return []  # No path found.\n\n    # Step 4: Convert the path of coordinates into a list of move actions.\n    actions = []\n    for i in range(len(path_to_goal) - 1):\n        p1 = path_to_goal[i]\n        p2 = path_to_goal[i+1]\n        delta = (p2[0] - p1[0], p2[1] - p1[1])\n        actions.append(DELTA_TO_ACTION[delta])\n\n    # Step 5: Ensure correct orientation before using the USE action.\n    final_pos = path_to_goal[-1]\n    primitive_pos = goal_to_primitive_map[final_pos]\n    required_dir_delta = (primitive_pos[0] - final_pos[0], primitive_pos[1] - final_pos[1])\n\n    if not actions:  # Agent started at the goal, so it has not moved yet.\n        current_dir_delta = DIR_TO_DELTA.get(state.dir)\n    else:\n        current_dir_delta = ACTION_TO_DELTA[actions[-1]]\n\n    if current_dir_delta != required_dir_delta:\n        # Generate an \"out-and-back\" move sequence to turn in place.\n        # e.g., to face RIGHT, perform [LEFT, RIGHT], which leaves the agent\n        # at the same spot but facing RIGHT.\n        required_face_action = DELTA_TO_ACTION[required_dir_delta]\n        turn_sequences = {\n            ACTION_RIGHT: [ACTION_LEFT, ACTION_RIGHT],\n            ACTION_LEFT: [ACTION_RIGHT, ACTION_LEFT],\n            ACTION_DOWN: [ACTION_UP, ACTION_DOWN],\n            ACTION_UP: [ACTION_DOWN, ACTION_UP],\n        }\n        turn_seq = turn_sequences[required_face_action]\n        out_action = turn_seq[0]\n        out_delta = ACTION_TO_DELTA[out_action]\n        out_pos = (final_pos[0] + out_delta[0], final_pos[1] + out_delta[1])\n\n        # Check if the intermediate cell for turning is empty and valid.\n        if (0 <= out_pos[0] < WIDTH and 0 <= out_pos[1] < HEIGHT and\n            grid[out_pos[1], out_pos[0], :].sum() == 0):\n            actions.extend(turn_seq)\n        # If turning is not possible (e.g., in a 1-wide corridor),\n        # proceed anyway; the USE action may fail, but we have navigated correctly.\n\n    # Step 6: Append the USE action.\n    actions.append(ACTION_USE)\n\n    return actions\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move adjacent to, face, and collect a primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path to a position from which a target primitive can be collected. The key aspects are:\n  1.  The agent can only move through empty cells. Any cell with an item, workshop,\n      or terrain is considered blocked.\n  2.  To collect an item, the agent must be in an adjacent empty cell and facing\n      the item. The `USE` action is directional.\n  3.  The BFS finds the shortest path of moves that ends with the agent landing in\n      the correct adjacent cell, with the final move action providing the correct\n      orientation to face the primitive.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\", \"IRON\").\n\n  Returns:\n    A list of integer actions (e.g., [UP, RIGHT, RIGHT, USE]) to collect the\n    primitive, or an empty list if it's not possible.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n  start_pos = state.pos  # This is an (x, y) tuple\n\n  # Action constants from the environment spec and their corresponding (dx, dy) vectors.\n  # The grid is indexed as grid[x, y, ...].\n  actions = {\"UP\": 1, \"DOWN\": 0, \"LEFT\": 2, \"RIGHT\": 3, \"USE\": 4}\n  action_vectors = {\n      actions[\"UP\"]: (0, -1),\n      actions[\"DOWN\"]: (0, 1),\n      actions[\"LEFT\"]: (-1, 0),\n      actions[\"RIGHT\"]: (1, 0)\n  }\n\n  # 1. Get the integer index for the primitive from the cookbook.\n  try:\n    primitive_index = state.world.cookbook.index[primitive]\n  except KeyError:\n    # The primitive name is not recognized.\n    return []\n\n  # 2. Find all grid coordinates where the target primitive exists.\n  primitive_locations = set()\n  for x in range(width):\n    for y in range(height):\n      if grid[x, y, primitive_index] > 0:\n        primitive_locations.add((x, y))\n\n  if not primitive_locations:\n    # The primitive does not exist on the map.\n    return []\n\n  # Helper function to check if a cell is traversable (i.e., within bounds and empty).\n  def is_traversable(pos):\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is traversable only if it is completely empty.\n    return grid[x, y, :].sum() == 0\n\n  # 3. Perform BFS to find the shortest path.\n  # The queue stores tuples of (current_position, path_of_actions).\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n    (curr_x, curr_y), path = queue.popleft()\n\n    # Explore all possible moves from the current position.\n    for action, (dx, dy) in action_vectors.items():\n      # The position the agent would land on after the move.\n      next_pos = (curr_x + dx, curr_y + dy)\n      \n      # The position the agent would be facing after landing at next_pos.\n      facing_pos = (next_pos[0] + dx, next_pos[1] + dy)\n\n      # Check if this move places the agent in a position to collect the primitive.\n      # This requires landing on a traversable cell (next_pos) while facing\n      # a cell that contains the primitive (facing_pos).\n      if facing_pos in primitive_locations and is_traversable(next_pos):\n        return path + [action, actions[\"USE\"]]\n\n      # If this is not a collection move, check if it's a valid exploratory move.\n      # The agent can only move to unvisited, empty cells.\n      if is_traversable(next_pos) and next_pos not in visited:\n        visited.add(next_pos)\n        queue.append((next_pos, path + [action]))\n              \n  # If the queue becomes empty, no path was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Finds the shortest sequence of actions to navigate to and collect a primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path. The state in the BFS includes the agent's position and its current\n  direction, as the 'USE' action depends on which way the agent is facing.\n\n  The search goal is to find a state where the agent is positioned in an empty\n  cell and is facing an adjacent cell that contains the target primitive.\n  \"\"\"\n  current_state = env._current_state\n  grid = current_state.grid\n  cookbook = current_state.world.cookbook\n  \n  # --- 1. Initialization and Constants ---\n  \n  # Action constants based on the environment's action specifications.\n  DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n  try:\n    primitive_idx = cookbook.index[primitive]\n  except KeyError:\n    # The primitive name is not in the cookbook's index; it cannot be collected.\n    return []\n\n  # Map movement actions to coordinate changes (dx, dy).\n  # This mapping assumes a standard Cartesian coordinate system (x, y).\n  action_to_delta = {\n      UP: (0, 1),\n      DOWN: (0, -1),\n      LEFT: (-1, 0),\n      RIGHT: (1, 0),\n  }\n\n  # Grid dimensions for boundary checks.\n  width, height = grid.shape[0], grid.shape[1]\n  \n  # Obstacles are defined by non-grabbable items.\n  non_grabbable_indices = current_state.world.non_grabbable_indices\n  def is_blocked(pos):\n    \"\"\"Checks if a cell at a given position is blocked by a non-grabbable item.\"\"\"\n    x, y = pos\n    for idx in non_grabbable_indices:\n        if grid[x, y, idx] > 0:\n            return True\n    return False\n\n  # --- 2. BFS Setup ---\n\n  start_pos = current_state.pos\n  start_dir = current_state.dir\n\n  # The BFS queue stores tuples of (position, direction, path_of_actions).\n  # Including direction in the state is essential for solving the task correctly.\n  queue = collections.deque([(start_pos, start_dir, [])])\n  \n  # The visited set stores (position, direction) tuples to avoid cycles\n  # and redundant computations in the state space.\n  visited = set([(start_pos, start_dir)])\n\n  # --- 3. BFS Execution ---\n\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # --- Check for Goal State ---\n    # The goal is achieved if the agent is facing the primitive from an adjacent cell.\n    if direction in action_to_delta:\n      # Calculate the coordinates of the cell the agent is currently facing.\n      dx, dy = action_to_delta[direction]\n      facing_pos = (pos[0] + dx, pos[1] + dy)\n\n      # Check if the facing cell is within the grid boundaries.\n      if 0 <= facing_pos[0] < width and 0 <= facing_pos[1] < height:\n        # Check if the facing cell contains the target primitive.\n        if grid[facing_pos[0], facing_pos[1], primitive_idx] > 0:\n          # Goal found! Return the path plus the final USE action.\n          return path + [USE]\n\n    # --- Expand Neighbors (Generate next possible states) ---\n    for action, (dx, dy) in action_to_delta.items():\n      next_pos = (pos[0] + dx, pos[1] + dy)\n      \n      # The move action determines the agent's new direction.\n      next_dir = action\n      \n      # This tuple represents the complete state for the next step.\n      next_state = (next_pos, next_dir)\n\n      # --- Validate the next state before adding it to the queue ---\n      # 1. Check if the next position is within the grid boundaries.\n      if not (0 <= next_pos[0] < width and 0 <= next_pos[1] < height):\n        continue\n              \n      # 2. Check if the next position is blocked by an obstacle. The agent can only move into empty cells.\n      if is_blocked(next_pos):\n        continue\n              \n      # 3. Check if this state (position and direction) has already been visited.\n      if next_state in visited:\n        continue\n\n      # If the state is valid and new, add it to the queue and visited set.\n      visited.add(next_state)\n      new_path = path + [action]\n      queue.append((next_pos, next_dir, new_path))\n          \n  # If the queue becomes empty, no path to the primitive could be found.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  The strategy is as follows:\n  1.  Identify all instances of the target primitive on the map.\n  2.  Determine all valid \"target\" positions, which are empty cells adjacent\n      to any instance of the primitive.\n  3.  Use Breadth-First Search (BFS) to find the shortest path from the agent's\n      current position to any of these target positions. The pathfinding\n      correctly treats cells with non-grabbable items (like water, stone) as\n      impassable walls, while allowing movement over other grabbable items.\n  4.  Once a path to an adjacent cell is found, calculate the final action\n      required to turn and face the primitive. This is achieved by issuing a\n      move command towards the primitive's blocked cell, which changes the\n      agent's orientation without changing its position.\n  5.  Append the 'USE' action to the sequence to collect the primitive.\n  6.  If no primitive exists or no path can be found, an empty list is returned.\n  \"\"\"\n\n  # --- 1. Setup and Initialization ---\n  state = env._current_state\n  grid = state.grid  # Grid indexed as grid[y, x, kind]\n  start_pos = state.pos  # Position is a tuple (x, y)\n  cookbook = env.world.cookbook\n  non_grabbable_indices = env.world.non_grabbable_indices\n\n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    return []  # The specified primitive does not exist in the game's recipes.\n\n  # Map (dx, dy) movement vectors to the environment's action constants.\n  action_map = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  directions = list(action_map.keys())\n  height, width, _ = grid.shape\n\n  # --- 2. Identify Target Positions ---\n  target_adj_positions = set()\n  # np.argwhere returns (row, col) indices, which corresponds to (y, x).\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  if primitive_locations.shape[0] == 0:\n    return []  # Primitive not found on the map.\n\n  for prim_y, prim_x in primitive_locations:\n    for dx, dy in directions:\n      ax, ay = prim_x + dx, prim_y + dy\n      if 0 <= ax < width and 0 <= ay < height:\n        # A valid target position must be empty for the agent to stand on.\n        if np.sum(grid[ay, ax, :]) == 0:\n          target_adj_positions.add((ax, ay))  # Store as (x, y)\n\n  if not target_adj_positions:\n    return []  # No empty cells adjacent to the primitive.\n\n  # --- 3. Pathfinding with Breadth-First Search (BFS) ---\n  queue = collections.deque([(start_pos, [])])  # Queue stores ((x, y), path_list)\n  visited = {start_pos}\n\n  found_path = None\n  final_pos = None\n\n  # Handle the case where the agent starts at a target position.\n  if start_pos in target_adj_positions:\n    found_path = []\n    final_pos = start_pos\n  else:\n    while queue:\n      (curr_x, curr_y), path = queue.popleft()\n\n      for dx, dy in directions:\n        nx, ny = curr_x + dx, curr_y + dy\n        neighbor_pos = (nx, ny)\n\n        if not (0 <= nx < width and 0 <= ny < height) or neighbor_pos in visited:\n          continue\n\n        # A cell is traversable if it does not contain a non-grabbable item.\n        is_traversable = not any(grid[ny, nx, i] > 0 for i in non_grabbable_indices)\n        \n        if is_traversable:\n          visited.add(neighbor_pos)\n          move_action = action_map.get((dx, dy))\n          new_path = path + [move_action]\n\n          if neighbor_pos in target_adj_positions:\n            found_path = new_path\n            final_pos = neighbor_pos\n            queue.clear()  # Terminate BFS once the shortest path is found.\n            break\n          \n          queue.append((neighbor_pos, new_path))\n      if found_path is not None:\n        break\n\n  if found_path is None:\n    return []  # No path found.\n\n  # --- 4. Finalize Action Sequence (Turn and Use) ---\n  # Find the specific primitive instance we are next to.\n  primitive_pos = None\n  for dx, dy in directions:\n    px, py = final_pos[0] + dx, final_pos[1] + dy\n    if 0 <= px < width and 0 <= py < height and grid[py, px, primitive_index] > 0:\n      primitive_pos = (px, py)\n      break\n  \n  if primitive_pos is None:\n    return [] # Should be logically impossible if pathfinding is correct.\n\n  # Determine the action to face the primitive from our final position.\n  face_dx = primitive_pos[0] - final_pos[0]\n  face_dy = primitive_pos[1] - final_pos[1]\n  face_action = action_map.get((face_dx, face_dy))\n\n  if face_action is None:\n    return [] # Should also be logically impossible.\n\n  # The complete sequence: move to the adjacent cell, turn to face, then use.\n  return found_path + [face_action, craft.USE]\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a specified primitive.\n\n    This function uses Breadth-First Search (BFS) to find the shortest path from the\n    agent's current position to an empty cell adjacent to the target primitive.\n    It correctly identifies that items block movement and that the agent must be\n    facing the primitive to collect it with the 'USE' action.\n\n    The strategy is as follows:\n    1. Identify all locations of the target primitive on the grid.\n    2. Determine all valid \"goal\" positions, which are empty cells adjacent to any\n       instance of the primitive. A map is created from each goal to its target.\n    3. Perform a BFS starting from the agent's current position, searching for the\n       shortest path to any of the goal positions. The search only considers\n       empty cells as traversable.\n    4. Once a path to a goal cell is found, append the necessary action to make the\n       agent face the adjacent primitive.\n    5. Finally, append the 'USE' action to collect the primitive.\n\n    Args:\n        env: The environment instance, providing access to the current state.\n        primitive: The string name of the primitive to collect.\n\n    Returns:\n        A list of integer actions to collect the primitive, or an empty list if\n        the primitive is unreachable.\n    \"\"\"\n    current_state = env._current_state\n    grid = current_state.grid\n    start_pos = current_state.pos\n    cookbook = current_state.world.cookbook\n    height, width = grid.shape[0], grid.shape[1]\n\n    # Map directions (dx, dy) to their corresponding action constants.\n    # Assumes grid is indexed (y, x) and pos is (x, y).\n    # UP corresponds to a change of -1 in y.\n    dir_to_action = {\n        (0, -1): craft.UP,\n        (1, 0): craft.RIGHT,\n        (0, 1): craft.DOWN,\n        (-1, 0): craft.LEFT,\n    }\n\n    try:\n        primitive_index = cookbook.index[primitive]\n    except KeyError:\n        return []  # Primitive name not found in cookbook\n\n    # 1. Find all target primitive locations and their adjacent, empty goal cells.\n    target_locations_yx = np.argwhere(grid[:, :, primitive_index] > 0)\n    if target_locations_yx.shape[0] == 0:\n        return []  # Primitive is not present on the map\n\n    goal_to_target_map = {}  # Map {(goal_x, goal_y): (target_x, target_y)}\n    for t_y, t_x in target_locations_yx:\n        for dx, dy in dir_to_action.keys():\n            gx, gy = t_x + dx, t_y + dy\n            if 0 <= gx < width and 0 <= gy < height:\n                # A cell is a valid goal if it's empty. Any non-empty cell is a blocker.\n                if grid[gy, gx, :].sum() == 0:\n                    goal_to_target_map[(gx, gy)] = (t_x, t_y)\n\n    goal_positions = set(goal_to_target_map.keys())\n    if not goal_positions:\n        return []  # Primitive is unreachable (e.g., completely walled in)\n\n    # 2. Handle case where the agent is already at a goal position.\n    if start_pos in goal_positions:\n        target_pos = goal_to_target_map[start_pos]\n        dx = target_pos[0] - start_pos[0]\n        dy = target_pos[1] - start_pos[1]\n        face_action = dir_to_action[(dx, dy)]\n        return [face_action, craft.USE]\n\n    # 3. BFS to find the shortest path to a goal position.\n    queue = collections.deque([(start_pos, [])])  # Stores ((x, y), path_of_actions)\n    visited = {start_pos}\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        for (dx, dy), action in dir_to_action.items():\n            nx, ny = x + dx, y + dy\n            neighbor_pos = (nx, ny)\n\n            if 0 <= nx < width and 0 <= ny < height and neighbor_pos not in visited:\n                # If the neighbor is a goal position, we've found the shortest path.\n                if neighbor_pos in goal_positions:\n                    final_path = path + [action]\n                    target_pos = goal_to_target_map[neighbor_pos]\n\n                    # Determine action to face the primitive from the goal cell.\n                    face_dx = target_pos[0] - neighbor_pos[0]\n                    face_dy = target_pos[1] - neighbor_pos[1]\n                    face_action = dir_to_action[(face_dx, face_dy)]\n\n                    final_path.append(face_action)\n                    final_path.append(craft.USE)\n                    return final_path\n\n                # If not a goal, check if it's traversable (empty) to continue path.\n                if grid[ny, nx, :].sum() == 0:\n                    visited.add(neighbor_pos)\n                    queue.append((neighbor_pos, path + [action]))\n\n    # 4. If the queue is exhausted and no path was found.\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path to an empty cell adjacent to the target primitive. It then adds the\n  necessary actions to turn towards the primitive and collect it.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of integer actions to be executed, or an empty list if the\n    primitive cannot be reached or does not exist.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos  # Assumed to be (x, y) or (col, row)\n  width, height, _ = grid.shape\n\n  # Define movement vectors and their corresponding action constants from the craft module.\n  # Assumes a coordinate system where pos=(x, y) with x for width and y for height.\n  directions = {\n      craft.UP:    (0, -1),  # Decrement y\n      craft.DOWN:  (0, 1),   # Increment y\n      craft.LEFT:  (-1, 0),  # Decrement x\n      craft.RIGHT: (1, 0),   # Increment x\n  }\n  # Create a reverse mapping from vector to action for the final turn.\n  action_for_vec = {v: k for k, v in directions.items()}\n\n  # 1. Get the integer index for the primitive name.\n  try:\n    primitive_index = state.world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive is not defined in the game's recipes.\n    return []\n\n  # 2. Find all locations of the primitive and identify adjacent, empty cells as goals.\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  if primitive_locations.size == 0:\n    # The primitive does not exist on the current map.\n    return []\n\n  goal_positions = set()\n  # This map stores which primitive location each goal corresponds to,\n  # which is needed to determine the final turn direction.\n  goal_to_primitive_map = {}\n\n  for x, y in primitive_locations:\n    # A goal is an empty cell *from which* the agent can collect the primitive.\n    for action, (dx, dy) in directions.items():\n      # The adjacent cell's coordinates.\n      adj_x, adj_y = x + dx, y + dy\n      if 0 <= adj_x < width and 0 <= adj_y < height:\n        # Check if this adjacent cell is empty and thus traversable.\n        if grid[adj_x, adj_y].sum() == 0:\n          goal_pos = (adj_x, adj_y)\n          goal_positions.add(goal_pos)\n          # This goal allows collecting from primitive at (x, y).\n          goal_to_primitive_map[goal_pos] = (x, y)\n\n  if not goal_positions:\n    # No accessible spots to collect the primitive from.\n    return []\n\n  # 3. BFS to find the shortest path to one of the goal positions.\n  queue = collections.deque([(start_pos, [])])  # (position, path_of_actions)\n  visited = {start_pos}\n\n  found_path = None\n  final_pos = None\n\n  # Handle the edge case where the agent already starts at a goal position.\n  if start_pos in goal_positions:\n    found_path = []\n    final_pos = start_pos\n  else:\n    while queue:\n      (curr_x, curr_y), path = queue.popleft()\n\n      for action, (dx, dy) in directions.items():\n        next_x, next_y = curr_x + dx, curr_y + dy\n        next_pos = (next_x, next_y)\n\n        if not (0 <= next_x < width and 0 <= next_y < height) or next_pos in visited:\n          continue\n\n        # The agent can only move into completely empty cells.\n        if grid[next_x, next_y].sum() == 0:\n          visited.add(next_pos)\n          new_path = path + [action]\n          if next_pos in goal_positions:\n            found_path = new_path\n            final_pos = next_pos\n            # Since BFS explores layer by layer, the first path found is the shortest.\n            queue.clear()\n            break\n          queue.append((next_pos, new_path))\n\n  # 4. If a path was found, construct the full action sequence.\n  if found_path is None:\n    # No path exists from the agent's position to any goal.\n    return []\n\n  # Determine the direction to face for collection.\n  primitive_pos = goal_to_primitive_map[final_pos]\n  vec_to_primitive = (primitive_pos[0] - final_pos[0], primitive_pos[1] - final_pos[1])\n  turn_action = action_for_vec[vec_to_primitive]\n\n  # The final sequence: move to the adjacent spot, turn to face, then collect.\n  return found_path + [turn_action, craft.USE]\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
