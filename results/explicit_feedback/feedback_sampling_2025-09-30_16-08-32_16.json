{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, navigate to, and collect a primitive.\n\n  The strategy is as follows:\n  1.  Identify the integer index of the target primitive.\n  2.  Scan the grid to find all locations of this primitive.\n  3.  Define impassable terrain as any cell containing a \"non-grabbable\" entity.\n  4.  Determine the valid \"goal\" cells for pathfinding. A goal cell is any\n      unblocked cell that is directly adjacent to a target primitive.\n  5.  Use Breadth-First Search (BFS) to find the shortest sequence of moves\n      from the agent's current position to one of the goal cells.\n      - The BFS state is `(position, path_of_actions)`.\n      - It explores unblocked, unvisited cells.\n  6.  The final move in the BFS path naturally orients the agent to face the\n      primitive it is moving next to.\n  7.  If a path is found, append the `USE` action to the end to collect the item.\n  8.  If no path is found (e.g., the primitive is unreachable), return an empty list.\n  9.  An edge case where the agent starts already adjacent to the primitive is\n      handled. In this case, a 2-move \"turn\" sequence is generated to ensure\n      correct orientation before the `USE` action.\n  \"\"\"\n  \n  # --- 1. Initialization and State Extraction ---\n  state = env._current_state\n  grid = state.grid  # Assumed shape (height, width, n_kinds)\n  start_pos_xy = state.pos  # Format (x, y)\n  cookbook = state.world.cookbook\n  \n  # Mapping from relative movement (dx, dy) to action constants\n  action_map = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT\n  }\n  \n  # --- 2. Identify Primitive and Target Locations ---\n  try:\n      primitive_index = cookbook.index[primitive]\n  except KeyError:\n      # The requested primitive does not exist in the world's recipes.\n      return []\n      \n  # Find all locations (y, x) of the target primitive.\n  # np.argwhere returns a list of [row, col] indices, which corresponds to [y, x].\n  prim_locs_yx = np.argwhere(grid[:, :, primitive_index] > 0)\n  if prim_locs_yx.size == 0:\n      return [] # Primitive not found on the map.\n\n  # --- 3. Define Obstacles and Find Reachable Goal Cells ---\n  \n  def is_blocked(y, x):\n      \"\"\"Checks if a cell at (y, x) is within bounds and passable.\"\"\"\n      # Check grid bounds\n      if not (0 <= y < grid.shape[0] and 0 <= x < grid.shape[1]):\n          return True\n      # Check for non-grabbable obstacles (e.g., water, stone walls)\n      for i_kind in state.world.non_grabbable_indices:\n          if grid[y, x, i_kind] > 0:\n              return True\n      return False\n\n  # Identify all valid goal cells for BFS. These are unblocked cells\n  # (y, x) that are adjacent to any instance of the primitive.\n  goal_cells_yx = set()\n  for y, x in prim_locs_yx:\n      for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n          adj_y, adj_x = y + dy, x + dx\n          if not is_blocked(adj_y, adj_x):\n              goal_cells_yx.add((adj_y, adj_x))\n\n  if not goal_cells_yx:\n      return [] # No accessible cells next to the primitive.\n      \n  # --- 4. Handle Edge Case: Agent starts adjacent to the primitive ---\n  start_pos_yx = (start_pos_xy[1], start_pos_xy[0])\n  if start_pos_yx in goal_cells_yx:\n      # Agent is already adjacent. We must ensure it's facing the primitive.\n      # A 2-move sequence (e.g., LEFT then RIGHT) can orient the agent.\n      for prim_y, prim_x in prim_locs_yx:\n          if abs(prim_y - start_pos_yx[0]) + abs(prim_x - start_pos_yx[1]) == 1:\n              # This is an adjacent primitive. Determine required facing direction.\n              dy = prim_y - start_pos_yx[0]\n              dx = prim_x - start_pos_yx[1]\n              \n              # The last move must be towards the primitive to face it.\n              required_face_action = action_map[(dx, dy)]\n              # The first move is the opposite, to move away then back.\n              move_away_action = action_map[(-dx, -dy)]\n              \n              # Check if the \"away\" cell is free to move into.\n              away_y, away_x = start_pos_yx[0] - dy, start_pos_yx[1] - dx\n              if not is_blocked(away_y, away_x):\n                  return [move_away_action, required_face_action, craft.USE]\n      # If no valid turn is found, we let the BFS proceed. It might find a\n      # longer path around an obstacle that works.\n\n  # --- 5. Perform BFS to Find Shortest Path ---\n  queue = collections.deque([(start_pos_yx, [])])\n  visited = {start_pos_yx}\n\n  while queue:\n      (curr_y, curr_x), path = queue.popleft()\n\n      # Explore neighbors in the four cardinal directions\n      for (dx, dy), action in action_map.items():\n          next_y, next_x = curr_y + dy, curr_x + dx\n          \n          # Check if moving to this neighbor reaches a goal cell\n          if (next_y, next_x) in goal_cells_yx:\n              # Found a path. The final move (`action`) correctly orients the agent.\n              return path + [action, craft.USE]\n\n          # If not a goal, check if it's a valid, unvisited cell to continue search\n          if (next_y, next_x) not in visited:\n              if not is_blocked(next_y, next_x):\n                  visited.add((next_y, next_x))\n                  new_path = path + [action]\n                  queue.append(((next_y, next_x), new_path))\n  \n  # If the queue becomes empty, no path to an adjacent cell was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path from the agent's current position to a cell adjacent to the target primitive.\n  The pathfinding respects obstacles like water and stone but allows movement\n  through functional workshops.\n\n  The strategy is as follows:\n  1. Identify all locations of the target primitive on the grid.\n  2. Determine all valid, traversable cells adjacent to these locations. These\n      become the goal states for the BFS.\n  3. Perform a BFS starting from the agent's current position to find the\n      shortest sequence of moves to reach any of the goal cells.\n  4. The last move in the path naturally orients the agent to face the primitive.\n  5. Append the 'USE' action to the path to perform the collection.\n  6. If no path is found, return an empty list.\n  \"\"\"\n  state = env._current_state\n  world = state.world\n  grid = state.grid\n  height, width, _ = grid.shape\n\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the game's recipes.\n    return []\n\n  # --- Define Obstacles ---\n  # Impassable terrain are non-grabbable items, excluding workshops which are traversable.\n  impassable_indices = world.non_grabbable_indices.difference(set(world.workshop_indices))\n\n  def is_blocked(pos):\n    \"\"\"Checks if a grid cell is blocked by impassable terrain.\"\"\"\n    x, y = pos\n    for idx in impassable_indices:\n      if grid[y, x, idx] > 0:\n        return True\n    return False\n\n  # --- 1. Find all valid target cells (adjacent to the primitive) ---\n  target_adj_cells = set()\n  for y in range(height):\n    for x in range(width):\n      if grid[y, x, primitive_index] > 0:\n        # This cell contains the primitive. Find its valid neighbors.\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n          adj_x, adj_y = x + dx, y + dy\n\n          if 0 <= adj_x < width and 0 <= adj_y < height:\n            adj_pos = (adj_x, adj_y)\n            if not is_blocked(adj_pos):\n              target_adj_cells.add(adj_pos)\n\n  if not target_adj_cells:\n    # No accessible cells next to the primitive.\n    return []\n\n  # --- 2. BFS to find the shortest path to a target cell ---\n  start_pos = state.pos\n  \n  # The queue stores tuples of ((x, y), path_list).\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  action_map = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  \n  while queue:\n    (curr_x, curr_y), path = queue.popleft()\n\n    # The condition `if path:` ensures we make at least one move.\n    # This correctly orients the agent via the last move before using the item.\n    # This elegantly handles the case where the agent starts next to the target.\n    if (curr_x, curr_y) in target_adj_cells and path:\n      return path + [craft.USE]\n\n    # Explore neighbors\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:  # Corresponds to UP, DOWN, LEFT, RIGHT\n      next_x, next_y = curr_x + dx, curr_y + dy\n      next_pos = (next_x, next_y)\n\n      if 0 <= next_x < width and 0 <= next_y < height and \\\n          next_pos not in visited and not is_blocked(next_pos):\n        \n        visited.add(next_pos)\n        action = action_map[(dx, dy)]\n        new_path = path + [action]\n        queue.append((next_pos, new_path))\n  \n  # --- 3. If queue empties, no path was found ---\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find and collect a specified primitive.\n\n    This function implements a Breadth-First Search (BFS) over the agent's\n    state space (position and direction) to find the shortest action sequence\n    to position the agent in front of the target primitive and then collect it.\n\n    Args:\n        env: The environment instance, providing access to the current state.\n        primitive (str): The name of the primitive to collect.\n\n    Returns:\n        list[int]: A list of action integers representing the plan. Returns\n                   an empty list if the primitive is unreachable.\n    \"\"\"\n    state = env._current_state\n    grid = state.grid\n    cookbook = env.world.cookbook\n    grid_height, grid_width = grid.shape[0], grid.shape[1]\n\n    # 1. Get the integer index for the primitive from the cookbook.\n    try:\n        primitive_index = cookbook.index[primitive]\n    except KeyError:\n        return []  # Primitive name not found in the game's recipes.\n\n    # 2. Define action and direction mappings consistent with the environment.\n    # Based on CraftLab.action_specs: DOWN:0, UP:1, LEFT:2, RIGHT:3, USE:4\n    # We assume a standard directional mapping for agent's state: 0:Up(N), 1:Right(E), 2:Down(S), 3:Left(W)\n\n    # Maps an action ID to the (dx, dy) movement vector it produces.\n    action_to_vec = {\n        craft.UP: (0, -1),\n        craft.DOWN: (0, 1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n\n    # Maps an action ID to the agent's new direction after the move.\n    action_to_dir = {\n        craft.UP: 0,      # UP action results in facing Up (North)\n        craft.RIGHT: 1,   # RIGHT action results in facing Right (East)\n        craft.DOWN: 2,    # DOWN action results in facing Down (South)\n        craft.LEFT: 3,    # LEFT action results in facing Left (West)\n    }\n\n    # Maps a direction ID to the vector pointing from the agent.\n    dir_to_vec = {\n        0: (0, -1),  # Facing Up (North) -> cell in front is at y-1\n        1: (1, 0),   # Facing Right (East) -> cell in front is at x+1\n        2: (0, 1),   # Facing Down (South) -> cell in front is at y+1\n        3: (-1, 0),  # Facing Left (West) -> cell in front is at x-1\n    }\n\n    # 3. Define a helper function to check if a cell is passable.\n    # A cell is impassable if it's out of bounds or contains a non-grabbable entity.\n    def is_passable(x, y):\n        if not (0 <= x < grid_width and 0 <= y < grid_height):\n            return False\n        for kind_idx in env.world.non_grabbable_indices:\n            if grid[y, x, kind_idx] > 0:\n                return False\n        return True\n\n    # 4. Initialize BFS.\n    # The state is ((x, y, dir), path), tracking position, direction, and the actions taken.\n    start_state = (state.pos[0], state.pos[1], state.dir)\n    queue = collections.deque([(start_state, [])])\n    visited = {start_state}\n\n    # 5. Run BFS to find the shortest action sequence.\n    while queue:\n        (current_pos, path) = queue.popleft()\n        current_x, current_y, current_dir = current_pos\n\n        # GOAL CONDITION: Check if the cell directly in front of the agent\n        # contains the target primitive.\n        dir_dx, dir_dy = dir_to_vec[current_dir]\n        facing_x, facing_y = current_x + dir_dx, current_y + dir_dy\n\n        if 0 <= facing_x < grid_width and 0 <= facing_y < grid_height:\n            if grid[facing_y, facing_x, primitive_index] > 0:\n                # If so, the plan is complete. Append the USE action.\n                return path + [craft.USE]\n\n        # EXPANSION: Explore next states by trying all possible move actions.\n        for action in [craft.UP, craft.DOWN, craft.LEFT, craft.RIGHT]:\n            move_dx, move_dy = action_to_vec[action]\n            next_x, next_y = current_x + move_dx, current_y + move_dy\n            next_dir = action_to_dir[action]\n\n            next_state = (next_x, next_y, next_dir)\n\n            if next_state not in visited and is_passable(next_x, next_y):\n                visited.add(next_state)\n                new_path = path + [action]\n                queue.append((next_state, new_path))\n\n    # If the queue becomes empty, no path was found.\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a primitive.\n\n    The strategy is to find the shortest path to a cell adjacent to the target\n    primitive. It uses a Breadth-First Search (BFS) algorithm.\n\n    1.  Identify all locations of the target primitive on the grid.\n    2.  Determine all valid, unblocked cells adjacent to these primitive locations.\n        These adjacent cells are the goals for the pathfinding algorithm.\n    3.  A cell is considered \"blocked\" if it is out of bounds or contains a\n        non-grabbable entity (e.g., water, stone, boundary).\n    4.  Run BFS starting from the agent's current position to find the shortest\n        sequence of moves (UP, DOWN, LEFT, RIGHT) to reach any of the goal cells.\n    5.  Once a path is found, an additional action is appended to ensure the\n        agent is facing the primitive. This is achieved by adding a move action\n        from the adjacent cell towards the primitive cell. This \"bump\" action\n        is assumed to orient the agent correctly.\n    6.  Finally, the 'USE' action is appended to collect the primitive.\n\n    If no path is found, or the primitive does not exist, an empty list is returned.\n    \"\"\"\n    state = env._current_state\n    grid = state.grid\n    start_pos = state.pos  # This is (x, y)\n    width, height, _ = grid.shape\n\n    # Define action mappings based on the craft environment's constants.\n    # Mapping from (dx, dy) vector to action constant.\n    ACTION_MAP = {\n        (1, 0): craft.RIGHT,\n        (-1, 0): craft.LEFT,\n        (0, 1): craft.DOWN,\n        (0, -1): craft.UP,\n    }\n    # List of (dx, dy) vectors for exploring neighbors.\n    DIRECTIONS = list(ACTION_MAP.keys())\n\n    try:\n        primitive_idx = state.world.cookbook.index[primitive]\n    except KeyError:\n        # The requested primitive is not in the game's vocabulary.\n        return []\n\n    # Helper function to determine if a grid cell is impassable.\n    # Based on feedback, only non-grabbable entities are considered obstacles.\n    non_grabbable_indices = state.world.non_grabbable_indices\n    def is_blocked(x, y):\n        if not (0 <= x < width and 0 <= y < height):\n            return True\n        for idx in non_grabbable_indices:\n            if grid[x, y, idx] > 0:\n                return True\n        return False\n\n    # Find all locations of the primitive and their accessible adjacent cells (goals).\n    primitive_locations = np.argwhere(grid[:, :, primitive_idx] > 0)\n    if primitive_locations.shape[0] == 0:\n        return []  # Primitive not found on the map.\n\n    # goal_map maps an adjacent cell to the primitive it's next to.\n    # Key: (x, y) of adjacent cell, Value: (x, y) of primitive cell.\n    goal_map = {}\n    for px, py in primitive_locations:\n        for dx, dy in DIRECTIONS:\n            nx, ny = px + dx, py + dy\n            if not is_blocked(nx, ny):\n                goal_map[(nx, ny)] = (px, py)\n\n    if not goal_map:\n        return []  # No accessible locations next to the primitive.\n\n    # Handle the edge case where the agent already starts in a goal position.\n    if start_pos in goal_map:\n        primitive_pos = goal_map[start_pos]\n        dx = primitive_pos[0] - start_pos[0]\n        dy = primitive_pos[1] - start_pos[1]\n        face_action = ACTION_MAP.get((dx, dy))\n        if face_action is not None:\n            # Bump into the primitive to set direction, then use.\n            return [face_action, craft.USE]\n        return []\n\n    # BFS to find the shortest path to any goal cell.\n    # The queue stores tuples of ((x, y), path_list).\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n\n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n\n        for dx, dy in DIRECTIONS:\n            nx, ny = curr_x + dx, curr_y + dy\n            neighbor_pos = (nx, ny)\n\n            if neighbor_pos in visited or is_blocked(nx, ny):\n                continue\n            \n            visited.add(neighbor_pos)\n            move_action = ACTION_MAP[(dx, dy)]\n            new_path = path + [move_action]\n\n            # Check if this neighbor is a goal cell (adjacent to the primitive).\n            if neighbor_pos in goal_map:\n                # Path found. Now, construct the final action sequence.\n                primitive_pos = goal_map[neighbor_pos]\n                \n                # Determine the action to face the primitive from the goal cell.\n                face_dx = primitive_pos[0] - nx\n                face_dy = primitive_pos[1] - ny\n                face_action = ACTION_MAP.get((face_dx, face_dy))\n\n                if face_action is not None:\n                    # Final sequence: move to adjacent cell, bump into primitive to turn, then use.\n                    return new_path + [face_action, craft.USE]\n                else:\n                    # This case should not be reached if logic is sound. Fallback to just using.\n                    return new_path + [craft.USE]\n\n            # Enqueue the neighbor for continued search.\n            queue.append((neighbor_pos, new_path))\n\n    return []  # No path found.\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n    A list of action integers representing the shortest path to collect the\n    primitive, or an empty list if it's not possible.\n  \"\"\"\n  current_state = env._current_state\n  world = env.world\n  grid = current_state.grid\n  height, width, _ = grid.shape\n\n  # The agent's position is (x, y), but numpy grid indexing is (row, col) -> (y, x).\n  # We use (y, x) for all internal calculations for consistency.\n  start_pos_xy = current_state.pos\n  start_pos = (start_pos_xy[1], start_pos_xy[0])\n\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the game's vocabulary.\n    return []\n\n  # Define movement directions (dy, dx) and their corresponding actions.\n  # (dy, dx) corresponds to changes in (row, col) indices.\n  action_map = {\n      (-1, 0): craft.UP,\n      (1, 0): craft.DOWN,\n      (0, -1): craft.LEFT,\n      (0, 1): craft.RIGHT,\n  }\n  directions = action_map.keys()\n\n  # Helper function to determine if a grid cell is impassable.\n  # A cell is blocked if it contains a non-grabbable entity, but workshops are exceptions.\n  workshop_indices = set(world.workshop_indices)\n  def is_blocked(y, x):\n    for kind_index in world.non_grabbable_indices:\n      if kind_index in workshop_indices:\n        continue\n      if grid[y, x, kind_index] > 0:\n        return True\n    return False\n\n  # Find all locations of the target primitive.\n  primitive_locs_y, primitive_locs_x = np.where(grid[:, :, primitive_index] > 0)\n  if not primitive_locs_y.size:\n    return []  # Primitive does not exist on the map.\n\n  # Determine all valid goal positions: unblocked cells adjacent to the primitive.\n  goal_positions = set()\n  for py, px in zip(primitive_locs_y, primitive_locs_x):\n    for dy, dx in directions:\n      ny, nx = py + dy, px + dx\n      # Check if the adjacent cell is within bounds and is a valid standing spot.\n      if 0 <= ny < height and 0 <= nx < width and not is_blocked(ny, nx):\n        goal_positions.add((ny, nx))\n\n  if not goal_positions:\n    return []  # No accessible location from which to collect the primitive.\n\n  # --- Breadth-First Search (BFS) to find the shortest path ---\n  queue = collections.deque([(start_pos, [])])  # Each item is ((y, x), path_list)\n  visited = {start_pos}\n\n  while queue:\n    pos, path = queue.popleft()\n\n    # If the current position is one of the valid collection spots, we're done.\n    if pos in goal_positions:\n      # The sequence of moves in `path` gets the agent to the right spot.\n      # The last move also orients the agent correctly.\n      # We append the USE action to perform the collection.\n      return path + [craft.USE]\n\n    # Explore neighbors.\n    for dy, dx in directions:\n      action = action_map[(dy, dx)]\n      next_pos = (pos[0] + dy, pos[1] + dx)\n      ny, nx = next_pos\n\n      # Check if the neighbor is valid, unvisited, and not blocked.\n      if 0 <= ny < height and 0 <= nx < width and next_pos not in visited:\n        if not is_blocked(ny, nx):\n          visited.add(next_pos)\n          new_path = path + [action]\n          queue.append((next_pos, new_path))\n\n  # If the queue empties and no path was found, return an empty list.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find a specified primitive, navigate to an\n  adjacent square, face the primitive, and collect it.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the\n  shortest path. The state in the BFS includes the agent's position and\n  facing direction, as both are crucial for the final 'USE' action.\n  \"\"\"\n  state = env._current_state\n  world = env.world\n  grid = state.grid\n  h, w, _ = grid.shape\n\n  # 1. Find the target primitive's index and locations on the grid.\n  try:\n    primitive_idx = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the world's cookbook.\n    return []\n\n  # Find all (row, col) coordinates of the primitive.\n  # We store them in a set of (y, x) tuples for efficient lookup.\n  target_locations = set(map(tuple, np.argwhere(grid[:, :, primitive_idx] > 0)))\n  if not target_locations:\n    return []\n\n  # 2. Define environment properties and helper functions.\n  # A cell is considered blocked if it contains a non-grabbable item.\n  impassable_indices = world.non_grabbable_indices\n  def is_blocked(pos):\n    x, y = pos\n    # Check against impassable terrain.\n    for idx in impassable_indices:\n      if grid[y, x, idx] > 0:\n        return True\n    return False\n\n  # Mappings from actions and directions to coordinate changes (dx, dy).\n  # Assumes agent pos is (x, y) and grid is indexed grid[y, x].\n  # Based on CraftLab, action constants are: UP=0, DOWN=1, LEFT=2, RIGHT=3, USE=4\n  # Based on CraftState, dir indices are: 0:DOWN, 1:UP, 2:LEFT, 3:RIGHT\n  action_to_move = {\n      craft.UP: (0, -1),\n      craft.DOWN: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  # Map from an action to the direction the agent will face afterward.\n  action_to_dir = {\n      craft.UP: 1,    # UP action -> UP direction\n      craft.DOWN: 0,  # DOWN action -> DOWN direction\n      craft.LEFT: 2,  # LEFT action -> LEFT direction\n      craft.RIGHT: 3, # RIGHT action -> RIGHT direction\n  }\n  # Map from direction index to the coordinate offset it points to.\n  dir_to_move = {\n      0: (0, 1),   # DOWN\n      1: (0, -1),  # UP\n      2: (-1, 0),  # LEFT\n      3: (1, 0),   # RIGHT\n  }\n\n  # 3. Initialize BFS.\n  # The state for the BFS is (position, direction, path_list).\n  start_pos = state.pos\n  start_dir = state.dir\n  \n  queue = collections.deque([(start_pos, start_dir, [])])\n  # Visited set stores (position, direction) tuples to avoid redundant exploration.\n  visited = {(start_pos, start_dir)}\n\n  # 4. Run BFS loop.\n  while queue:\n    pos, direction, path = queue.popleft()\n    px, py = pos\n\n    # --- Goal Check ---\n    # Check if the agent is currently facing the target primitive.\n    dx, dy = dir_to_move[direction]\n    facing_pos = (px + dx, py + dy)\n    facing_y, facing_x = facing_pos[1], facing_pos[0]\n    \n    # The goal is met if the cell the agent is facing contains the target.\n    if (facing_y, facing_x) in target_locations:\n      return path + [craft.USE]\n\n    # --- Expansion ---\n    # Explore taking each of the four movement actions.\n    for action, (dx, dy) in action_to_move.items():\n      new_pos = (px + dx, py + dy)\n      nx, ny = new_pos\n      new_dir = action_to_dir[action]\n\n      # Check if the new state is valid (in-bounds, not blocked) and has not been visited.\n      if 0 <= nx < w and 0 <= ny < h and \\\n         not is_blocked(new_pos) and \\\n         (new_pos, new_dir) not in visited:\n        \n        visited.add((new_pos, new_dir))\n        new_path = path + [action]\n        queue.append((new_pos, new_dir, new_path))\n  \n  # If the queue is exhausted, no path to collect the primitive was found.\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path to a state where the agent is adjacent to the target primitive and facing it.\n\n  The state in the BFS is represented by a tuple (position, direction), which is\n  crucial because the 'USE' action is directional.\n\n  Args:\n    env: The simulation environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of integer actions (e.g., [craft.RIGHT, craft.UP, craft.USE]) that\n    form a plan to collect the primitive. Returns an empty list if no path is found.\n  \"\"\"\n  import collections\n  import numpy as np\n\n  state = env._current_state\n  world = state.world\n  grid = state.grid\n  height, width, _ = grid.shape\n\n  # Action constants used by the environment\n  # DOWN: 0, UP: 1, LEFT: 2, RIGHT: 3, USE: 4\n  DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n  \n  # --- 1. Get Primitive Index and Define Mappings ---\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive does not exist in the world's cookbook.\n    return []\n\n  # Mappings from action/direction codes to coordinate deltas (dx, dy)\n  action_to_delta = {\n      DOWN: (0, 1),\n      UP: (0, -1),\n      LEFT: (-1, 0),\n      RIGHT: (1, 0),\n  }\n\n  # --- 2. Helper function to check for obstacles ---\n  def is_blocked(pos):\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return True\n    # A cell is blocked if it contains any non-grabbable item (e.g., water, stone, boundary).\n    # The agent cannot move onto these cells.\n    for kind_idx in world.non_grabbable_indices:\n      if grid[y, x, kind_idx] > 0:\n        return True\n    return False\n\n  # --- 3. Find all valid goal states ---\n  # A goal state is a (position, direction) tuple where the agent is\n  # adjacent to the primitive and facing it, ready to 'USE'.\n  goal_states = set()\n  primitive_locs = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  for y_prim, x_prim in primitive_locs:\n    # To collect at (x_prim, y_prim), agent can be at:\n    # (x_prim, y_prim - 1) facing DOWN (dir=0)\n    # (x_prim, y_prim + 1) facing UP (dir=1)\n    # (x_prim + 1, y_prim) facing LEFT (dir=2)\n    # (x_prim - 1, y_prim) facing RIGHT (dir=3)\n    \n    potential_goals = [\n      ((x_prim, y_prim - 1), DOWN),\n      ((x_prim, y_prim + 1), UP),\n      ((x_prim + 1, y_prim), LEFT),\n      ((x_prim - 1, y_prim), RIGHT),\n    ]\n\n    for pos, direction in potential_goals:\n      if not is_blocked(pos):\n        goal_states.add((pos, direction))\n        \n  if not goal_states:\n    # No accessible adjacent cells to any primitive instance.\n    return []\n\n  # --- 4. Perform BFS to find the shortest path ---\n  start_pos = state.pos\n  start_dir = state.dir\n\n  # The queue stores tuples of: (current_position, current_direction, path_so_far)\n  queue = collections.deque([(start_pos, start_dir, [])])\n  # The visited set stores (position, direction) to avoid cycles\n  visited = set([(start_pos, start_dir)])\n\n  while queue:\n    (curr_x, curr_y), curr_dir, path = queue.popleft()\n\n    # Check if the current state is a goal state\n    if ((curr_x, curr_y), curr_dir) in goal_states:\n      return path + [USE]\n\n    # Explore neighbors by trying all possible move actions\n    for action in [DOWN, UP, LEFT, RIGHT]:\n      new_dir = action\n      dx, dy = action_to_delta[action]\n      next_pos = (curr_x + dx, curr_y + dy)\n      \n      # If the next position is valid and we haven't been in this state before\n      if not is_blocked(next_pos) and (next_pos, new_dir) not in visited:\n        visited.add((next_pos, new_dir))\n        new_path = path + [action]\n        queue.append((next_pos, new_dir, new_path))\n        \n  # If the queue becomes empty, no path was found\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find the shortest path to a primitive,\n    move to an adjacent square, face it, and collect it.\n\n    This function implements a Breadth-First Search (BFS) to find the shortest\n    sequence of moves. The search goal is not just to reach a cell adjacent\n    to the primitive, but to arrive there with the final move correctly\n    orienting the agent to face the primitive. This ensures that the subsequent\n    'USE' action is successful.\n\n    The strategy is as follows:\n    1. Identify all locations of the target primitive on the grid.\n    2. Determine the set of valid \"goal states\" for the BFS. A goal state\n       consists of a position adjacent to a target, and the specific move\n       action required to arrive at that position while facing the target.\n    3. Define what constitutes a \"passable\" cell for navigation, excluding\n       impassable terrain like water or stone but allowing movement through\n       workshops.\n    4. Execute the BFS, starting from the agent's current position. The search\n       explores the grid, looking for the shortest path of moves that ends\n       in one of the pre-defined goal states.\n    5. If a path is found, append the 'USE' action and return the complete\n       action sequence.\n    6. If the primitive doesn't exist or is unreachable, return an empty list.\n    \"\"\"\n    # Action constants mapping, based on the environment's action specification.\n    # In CraftLab: DOWN: 0, UP: 1, LEFT: 2, RIGHT: 3, USE: 4\n    DOWN, UP, LEFT, RIGHT, USE = 0, 1, 2, 3, 4\n\n    # Map from move vectors (dx, dy) to the corresponding action integers.\n    # The grid's y-axis (height) increases downwards.\n    MOVE_ACTIONS = {\n        (0, 1): DOWN,   # Move Down (y increases)\n        (0, -1): UP,    # Move Up (y decreases)\n        (-1, 0): LEFT,  # Move Left (x decreases)\n        (1, 0): RIGHT, # Move Right (x increases)\n    }\n\n    current_state = env._current_state\n    grid = current_state.grid\n    start_pos = current_state.pos\n    world = current_state.world\n\n    # Step 1: Get the integer index for the primitive from the world's cookbook.\n    try:\n        target_idx = world.cookbook.index[primitive]\n    except KeyError:\n        return [] # Primitive does not exist in the world definition.\n\n    # Step 2: Find all locations of the target primitive on the current grid.\n    # grid.shape is (WIDTH, HEIGHT, ...), so coordinates are (x, y).\n    target_locations = set(zip(*np.where(grid[:, :, target_idx] > 0)))\n    if not target_locations:\n        return [] # Primitive is not present on the map.\n\n    # Step 3: Define impassable terrain for pathfinding.\n    # A cell is impassable if it's a non-grabbable entity (like water, stone)\n    # but not a workshop, which should be traversable.\n    impassable_indices = set(world.non_grabbable_indices) - set(world.workshop_indices)\n    width, height, _ = grid.shape\n\n    def is_passable(x, y):\n        # Helper function to check if a cell is within bounds and not blocked.\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        for idx in impassable_indices:\n            if grid[x, y, idx] > 0:\n                return False\n        return True\n\n    # Step 4: Identify all valid goal states for the BFS.\n    # A goal state is a tuple: ((position), required_final_action).\n    # This means the agent must arrive at 'position' using 'required_final_action'\n    # to be correctly oriented for collection.\n    goal_states = set()\n    for tx, ty in target_locations:\n        for move_vec, required_action in MOVE_ACTIONS.items():\n            # The adjacent position from which the agent will perform the USE action.\n            adj_pos = (tx - move_vec[0], ty - move_vec[1])\n            \n            # This adjacent position must be a passable cell.\n            if is_passable(adj_pos[0], adj_pos[1]):\n                # The goal is to arrive at adj_pos with the last move being required_action.\n                goal_states.add((adj_pos, required_action))\n\n    # Step 5: Execute BFS to find the shortest path to a goal state.\n    # The queue stores tuples of (current_position, path_to_that_position).\n    queue = collections.deque([(start_pos, [])])\n    # The visited set stores positions to avoid cycles and redundant exploration.\n    visited = {start_pos}\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        # Explore all possible moves from the current position.\n        for move_vec, action in MOVE_ACTIONS.items():\n            next_x, next_y = x + move_vec[0], y + move_vec[1]\n            next_pos = (next_x, next_y)\n            \n            # Check if this move results in reaching a defined goal state.\n            if (next_pos, action) in goal_states:\n                # We found the shortest path that ends with the correct orientation.\n                # The full plan is the path to the adjacent cell plus the USE action.\n                return path + [action, USE]\n\n            # If not a goal, check if it's a valid, unvisited cell to continue the search.\n            if next_pos not in visited and is_passable(next_x, next_y):\n                visited.add(next_pos)\n                new_path = path + [action]\n                queue.append((next_pos, new_path))\n    \n    # If the queue empties, it means the primitive is unreachable.\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a cell adjacent to the target primitive. It correctly\n  identifies impassable terrain and ensures the agent navigates to a\n  neighboring cell before attempting to collect the item with a 'USE' action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of action integers representing the optimal plan, or an empty\n    list if the primitive is unreachable.\n  \"\"\"\n  state = env._current_state\n  grid = state.grid\n  cookbook = env.world.cookbook\n  start_pos = state.pos\n\n  # 1. Initialization and Mapping\n  try:\n    primitive_idx = cookbook.index[primitive]\n  except (KeyError, AttributeError):\n    # The requested primitive does not exist in the game's cookbook.\n    return []\n\n  height, width, _ = grid.shape\n  \n  # Map coordinate deltas (dx, dy) to their corresponding action constants.\n  # Note: grid is indexed [y, x]. A move 'UP' decreases the y-coordinate.\n  delta_to_action = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  deltas = list(delta_to_action.keys())\n\n  # 2. Define Passable Terrain\n  non_grabbable_indices = env.world.non_grabbable_indices\n  def is_passable(pos):\n    \"\"\"Checks if a grid cell is within bounds and not blocked by impassable terrain.\"\"\"\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is impassable if it contains any non-grabbable entity.\n    for idx in non_grabbable_indices:\n      if grid[y, x, idx] > 0:\n        return False\n    return True\n\n  # 3. Identify all valid destination cells\n  # A destination is a passable cell adjacent to any instance of the primitive.\n  destination_cells = set()\n  for y in range(height):\n    for x in range(width):\n      if grid[y, x, primitive_idx] > 0:\n        # This cell (x, y) contains the target primitive.\n        # Its passable neighbors are our potential destinations.\n        for dx, dy in deltas:\n          neighbor_pos = (x + dx, y + dy)\n          if is_passable(neighbor_pos):\n            destination_cells.add(neighbor_pos)\n  \n  if not destination_cells:\n    return []  # No accessible spot next to any instance of the primitive.\n\n  # If the agent already starts at a valid destination, just USE.\n  if start_pos in destination_cells:\n    return [craft.USE]\n\n  # 4. BFS to find the shortest path to any destination cell\n  # The queue stores tuples of (current_position, path_taken_to_get_here).\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n    current_pos, path = queue.popleft()\n\n    for dx, dy in deltas:\n      next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n      \n      if next_pos in visited:\n        continue\n      \n      # We only explore cells that are valid for the agent to stand on.\n      if is_passable(next_pos):\n        visited.add(next_pos)\n        action = delta_to_action[(dx, dy)]\n        new_path = path + [action]\n        \n        if next_pos in destination_cells:\n          # Found the shortest path to a valid cell adjacent to the primitive.\n          # Append the final USE action to collect it.\n          return new_path + [craft.USE]\n        \n        queue.append((next_pos, new_path))\n  \n  return [] # No path could be found to any destination cell.\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find a specified primitive, navigate to an\n    adjacent cell, face the primitive, and collect it.\n\n    This function uses a Breadth-First Search (BFS) algorithm to find the\n    shortest path. The state in the BFS includes both the agent's position and\n    its direction, as the 'USE' action is dependent on orientation. The agent\n    must be facing the primitive to collect it.\n\n    The search terminates upon finding a state where the cell immediately in\n    front of the agent contains the target primitive.\n\n    Args:\n        env: The CraftLab environment instance.\n        primitive (str): The name of the primitive to collect (e.g., 'WOOD').\n\n    Returns:\n        list: A list of action integers (e.g., [craft.UP, craft.RIGHT, craft.USE])\n              representing the plan to collect the primitive. Returns an empty\n              list if the primitive cannot be found or reached.\n    \"\"\"\n    state = env._current_state\n    world = env.world\n    grid = state.grid\n\n    try:\n        primitive_index = world.cookbook.index[primitive]\n    except KeyError:\n        # The requested primitive does not exist in the game's vocabulary.\n        return []\n\n    # Action constants from the environment are used for clarity.\n    # We map actions to (dx, dy) vectors for grid traversal.\n    # Standard cartesian coordinates: (x, y) where +x is right, +y is down.\n    action_to_vector = {\n        craft.UP: (0, -1),\n        craft.DOWN: (0, 1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n\n    # The agent's direction is assumed to correspond to the last move action taken.\n    # This mapping converts a direction (represented by an action constant) to a vector.\n    dir_to_vector = action_to_vector\n\n    start_pos = state.pos  # The agent's starting (x, y) position.\n    start_dir = state.dir  # The agent's starting direction.\n\n    height, width, _ = grid.shape\n\n    # Helper function to determine if a cell is impassable.\n    # A cell is blocked if it's out of bounds or contains a non-grabbable entity.\n    non_grabbable = world.non_grabbable_indices\n    def is_blocked(x, y):\n        if not (0 <= y < height and 0 <= x < width):\n            return True\n        # The grid is indexed by [y, x] (row, column).\n        for kind_index in non_grabbable:\n            if grid[y, x, kind_index] > 0:\n                return True\n        return False\n\n    # Initialize the BFS queue with the starting state.\n    # Each item is a tuple: (position, direction, path_of_actions).\n    queue = collections.deque([(start_pos, start_dir, [])])\n    # The visited set stores (position, direction) tuples to avoid cycles and redundant exploration.\n    visited = {(start_pos, start_dir)}\n\n    while queue:\n        (x, y), direction, path = queue.popleft()\n\n        # GOAL CHECK: Is the primitive in the cell directly in front of the agent?\n        if direction in dir_to_vector:\n            dx, dy = dir_to_vector[direction]\n            front_x, front_y = x + dx, y + dy\n\n            if 0 <= front_y < height and 0 <= front_x < width:\n                if grid[front_y, front_x, primitive_index] > 0:\n                    # Success! The agent is positioned correctly. Append the USE action.\n                    return path + [craft.USE]\n\n        # EXPAND SEARCH: Explore all possible moves from the current state.\n        for action, (dx, dy) in action_to_vector.items():\n            new_x, new_y = x + dx, y + dy\n            \n            # A move action also determines the agent's new direction.\n            new_dir = action\n            new_pos = (new_x, new_y)\n\n            # Enqueue the new state if it's valid and has not been visited.\n            if not is_blocked(new_x, new_y) and (new_pos, new_dir) not in visited:\n                visited.add((new_pos, new_dir))\n                new_path = path + [action]\n                queue.append((new_pos, new_dir, new_path))\n                \n    # If the queue becomes empty, no path was found.\n    return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to a cell adjacent to a primitive,\n  orient the agent correctly, and collect it.\n\n  This function uses a Breadth-First Search (BFS) to find the shortest path.\n  It correctly handles obstacles, including those that can be cleared with tools,\n  and ensures the agent is facing the primitive before the final 'USE' action.\n  \"\"\"\n  # 1. SETUP AND INITIALIZATION\n  state = env._current_state\n  world = env.world\n  grid = state.grid\n  start_pos_xy = state.pos  # Agent position is (x, y)\n  inventory = state.inventory\n  cookbook = world.cookbook\n  height, width, _ = grid.shape  # Grid is indexed [y, x]\n\n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    return []  # Primitive name is invalid for this scenario\n\n  # Action constants and mappings for movement and orientation\n  # move_map: (dx, dy) -> action_code\n  move_map = {\n      (0, -1): craft.UP,\n      (0, 1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  # A map to find the opposite action, useful for re-orienting\n  opposite_move_map = {\n      craft.UP: craft.DOWN,\n      craft.DOWN: craft.UP,\n      craft.LEFT: craft.RIGHT,\n      craft.RIGHT: craft.LEFT,\n  }\n\n  # 2. HELPER FUNCTION FOR OBSTACLE DETECTION\n  # Create a map from obstacle_index -> required_tool_index for efficient lookup.\n  # This makes reasonable assumptions based on the game's logic.\n  tool_map = {}\n  if 'AXE' in cookbook.index and 'WOOD' in cookbook.index:\n    tool_map[cookbook.index['WOOD']] = cookbook.index['AXE']\n  if 'HAMMER' in cookbook.index and 'ROCK' in cookbook.index:\n    tool_map[cookbook.index['ROCK']] = cookbook.index['HAMMER']\n  \n  def is_blocked(y, x):\n    \"\"\"\n    Checks if a cell at (y, x) is blocked. A cell is blocked if it contains a\n    non-grabbable item and the agent does not have the required tool to clear it.\n    \"\"\"\n    item_indices_at_pos = np.where(grid[y, x] > 0)[0]\n    for item_idx in item_indices_at_pos:\n      if item_idx in world.non_grabbable_indices:\n        required_tool_idx = tool_map.get(item_idx)\n        if required_tool_idx is None or inventory[required_tool_idx] == 0:\n          return True  # It's a blocker we can't clear\n    return False\n\n  # 3. FIND GOAL POSITIONS (valid, unblocked cells adjacent to the primitive)\n  primitive_locations_yx = np.argwhere(grid[:, :, primitive_index] > 0)\n  if primitive_locations_yx.shape[0] == 0:\n    return []  # Primitive does not exist on the map\n\n  goal_positions_yx = set()\n  for prim_y, prim_x in primitive_locations_yx:\n    for dx, dy in move_map.keys():\n      adj_x, adj_y = prim_x + dx, prim_y + dy\n      if 0 <= adj_y < height and 0 <= adj_x < width:\n        if not is_blocked(adj_y, adj_x):\n          goal_positions_yx.add((adj_y, adj_x))\n  \n  if not goal_positions_yx:\n    return []  # No accessible cells next to any instance of the primitive\n\n  # Handle the edge case where the agent starts at a goal position but may not be oriented correctly\n  start_pos_yx = (start_pos_xy[1], start_pos_xy[0])\n  if start_pos_yx in goal_positions_yx:\n    for prim_y, prim_x in primitive_locations_yx:\n      dy, dx = prim_y - start_pos_yx[0], prim_x - start_pos_yx[1]\n      if abs(dx) + abs(dy) == 1:\n        # Found the adjacent primitive. Generate a sequence to turn and collect.\n        target_action = move_map[(dx, dy)]\n        opposite_action = opposite_move_map[target_action]\n        # Move away, then move back to orient correctly, then use.\n        return [opposite_action, target_action, craft.USE]\n\n  # 4. PERFORM BREADTH-FIRST SEARCH (BFS) TO FIND SHORTEST PATH\n  # The queue stores tuples of: ((y, x)_position, list_of_actions_path)\n  queue = collections.deque([(start_pos_yx, [])])\n  visited = {start_pos_yx}\n\n  while queue:\n    (curr_y, curr_x), path = queue.popleft()\n\n    # Check if the current position is a goal (adjacent to the primitive)\n    if (curr_y, curr_x) in goal_positions_yx:\n      # Find the specific primitive this goal position is next to.\n      for prim_y, prim_x in primitive_locations_yx:\n        dy, dx = prim_y - curr_y, prim_x - curr_x\n        if abs(dx) + abs(dy) == 1:\n          # This is the primitive. The required facing direction is (dx, dy).\n          target_action = move_map[(dx, dy)]\n          \n          # If the last move in the path already results in the correct orientation, just USE.\n          if path and path[-1] == target_action:\n            return path + [craft.USE]\n          else:\n            # Otherwise, append a sequence to re-orient correctly.\n            opposite_action = opposite_move_map[target_action]\n            return path + [opposite_action, target_action, craft.USE]\n\n    # Expand search to neighbors\n    for (dx, dy), action in move_map.items():\n      next_y, next_x = curr_y + dy, curr_x + dx\n      if 0 <= next_y < height and 0 <= next_x < width:\n        next_pos_yx = (next_y, next_x)\n        if next_pos_yx not in visited and not is_blocked(next_y, next_x):\n          visited.add(next_pos_yx)\n          new_path = path + [action]\n          queue.append((next_pos_yx, new_path))\n  \n  return []  # Return an empty list if no path is found\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
