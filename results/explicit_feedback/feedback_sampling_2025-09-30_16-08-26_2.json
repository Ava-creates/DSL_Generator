{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses Breadth-First Search (BFS) to find the shortest path from the\n  agent's current position to a cell adjacent to the target primitive. It then\n  generates the necessary move actions to follow this path, face the primitive,\n  and collect it using the 'USE' action.\n  \"\"\"\n  # Get necessary info from the environment\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos  # Assumed to be (row, col)\n\n  # Map of (d_row, d_col) to corresponding action constants\n  action_map = {\n      (-1, 0): craft.UP,\n      (1, 0): craft.DOWN,\n      (0, -1): craft.LEFT,\n      (0, 1): craft.RIGHT\n  }\n  directions = list(action_map.keys())\n\n  # Get the integer index for the primitive name from the cookbook\n  try:\n      primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n      # The primitive name doesn't exist in the world's recipes.\n      return []\n\n  # Create a set of walkable non-empty indices (workshops) for quick lookup\n  walkable_indices = set(world.workshop_indices)\n\n  def is_blocked(pos):\n      \"\"\"Checks if a grid position is impassable for pathfinding.\"\"\"\n      r, c = pos\n      # Check grid boundaries\n      if not (0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]):\n          return True\n      # A cell is blocked if it contains anything...\n      if np.sum(grid[r, c]) > 0:\n          # ...unless that thing is a workshop.\n          kind_index = np.argmax(grid[r, c])\n          if kind_index in walkable_indices:\n              return False  # It's a walkable workshop.\n          return True  # It's a resource or obstacle, so it's blocked.\n      return False  # It's empty, so it's not blocked.\n\n  # BFS Initialization: The queue stores tuples of (position, path_of_actions)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n      current_pos, path = queue.popleft()\n      cr, cc = current_pos\n\n      # Goal Check: Is the current position adjacent to the primitive?\n      for dr, dc in directions:\n          neighbor_pos = (cr + dr, cc + dc)\n          nr, nc = neighbor_pos\n\n          # Check if neighbor is within bounds\n          if not (0 <= nr < grid.shape[0] and 0 <= nc < grid.shape[1]):\n              continue\n          \n          # Check if the neighbor cell contains the target primitive\n          if grid[nr, nc, primitive_index] > 0:\n              # Path found. The agent is at current_pos, next to the primitive.\n              # The action to face the primitive is the move towards it.\n              face_action = action_map[(dr, dc)]\n              # The full action sequence is the path, the face action, and USE.\n              return path + [face_action, craft.USE]\n\n      # Expansion: Add valid, unvisited neighbors to the queue\n      for dr, dc in directions:\n          next_pos = (cr + dr, cc + dc)\n          \n          if next_pos not in visited and not is_blocked(next_pos):\n              visited.add(next_pos)\n              move_action = action_map[(dr, dc)]\n              new_path = path + [move_action]\n              queue.append((next_pos, new_path))\n  \n  # If the queue becomes empty, no path was found to any instance of the primitive\n  return []\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find the shortest path to, face, and collect a primitive.\n\n  This function uses Breadth-First Search (BFS) to find the shortest traversable\n  path to a cell adjacent to the specified primitive. Once such a path is found,\n  it appends the necessary actions to turn the agent towards the primitive and\n  then collect it with the 'USE' action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action constants representing the plan to collect the primitive,\n    or an empty list if the primitive is unreachable or not on the map.\n  \"\"\"\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n  \n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    return [] # Primitive name is not valid\n\n  # A map from (dx, dy) coordinate changes to the corresponding action constant.\n  action_map = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (1, 0): craft.RIGHT,\n      (-1, 0): craft.LEFT\n  }\n\n  workshop_indices = set(world.workshop_indices)\n\n  def is_blocked(x, y):\n    \"\"\"\n    Checks if a cell is blocked. A cell is blocked if it contains any entity,\n    unless that entity is a workshop.\n    \"\"\"\n    # Get all entity kinds present at the location (x, y).\n    present_kinds_indices = np.where(grid[x, y] > 0)[0]\n    \n    if not present_kinds_indices.any():\n      return False  # Empty cells are not blocked.\n\n    # A cell is traversable only if it contains *nothing but* workshops.\n    for kind_idx in present_kinds_indices:\n      if kind_idx not in workshop_indices:\n        return True # Found a non-workshop entity, so it's blocked.\n            \n    return False # The cell only contains workshops, so it's not blocked.\n\n  # Find all locations of the target primitive.\n  # np.argwhere returns (row, col) which corresponds to (y, x).\n  primitive_locs = np.argwhere(grid[:, :, primitive_index] > 0)\n  if primitive_locs.shape[0] == 0:\n    return [] # Primitive does not exist on the map.\n\n  # The goal of the BFS is to reach any valid cell *adjacent* to any primitive.\n  # goal_map stores {adjacent_cell_pos: primitive_cell_pos}.\n  goal_map = {}\n  for pos in primitive_locs:\n    py, px = pos[0], pos[1]\n    for (dx, dy), action in action_map.items():\n      tx, ty = px - dx, py - dy # Target cell is adjacent to the primitive\n      if 0 <= tx < width and 0 <= ty < height and not is_blocked(tx, ty):\n        if (tx, ty) not in goal_map:\n          goal_map[(tx, ty)] = (px, py)\n  \n  if not goal_map:\n    return [] # No accessible cells next to any instance of the primitive.\n\n  start_pos = state.pos\n  \n  # Edge case: agent already starts at a goal location.\n  if start_pos in goal_map:\n    px, py = goal_map[start_pos]\n    dx, dy = px - start_pos[0], py - start_pos[1]\n    turn_action = action_map[(dx, dy)]\n    return [turn_action, craft.USE]\n\n  # Initialize BFS queue and visited set.\n  queue = collections.deque([(start_pos, [])]) # Stores (position, path)\n  visited = {start_pos}\n\n  while queue:\n    (cx, cy), path = queue.popleft()\n\n    for (dx, dy), action in action_map.items():\n      nx, ny = cx + dx, cy + dy\n      next_pos = (nx, ny)\n\n      if not (0 <= nx < width and 0 <= ny < height) or next_pos in visited:\n        continue\n\n      # Check if the neighboring cell is a goal.\n      if next_pos in goal_map:\n        # Found the shortest path. Now construct the full action sequence.\n        final_path = path + [action]\n        \n        # Determine the action needed to face the primitive from the goal cell.\n        primitive_x, primitive_y = goal_map[next_pos]\n        turn_dx = primitive_x - nx\n        turn_dy = primitive_y - ny\n        turn_action = action_map[(turn_dx, turn_dy)]\n        \n        # Append the turn (by moving into the blocked primitive cell) and the USE action.\n        final_path.append(turn_action)\n        final_path.append(craft.USE)\n        return final_path\n\n      # If it's a regular traversable cell, add it to the queue.\n      if not is_blocked(nx, ny):\n        visited.add(next_pos)\n        new_path = path + [action]\n        queue.append((next_pos, new_path))\n        \n  return [] # No path found to any cell adjacent to the primitive.\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a specified primitive.\n\n    The strategy is as follows:\n    1.  Identify all locations of the target primitive on the grid.\n    2.  For each primitive, determine the valid, passable, adjacent \"goal\" cells\n        from which the agent can collect it.\n    3.  Use Breadth-First Search (BFS) to find the shortest path from the agent's\n        current position to any of these goal cells.\n    4.  Once a path to a goal cell is found, construct the final action sequence:\n        a. The sequence of moves from the BFS to reach the goal cell.\n        b. A final \"move\" action that turns the agent to face the primitive.\n           (The move itself will be blocked, but it correctly sets the agent's direction).\n        c. A 'USE' action to collect the primitive.\n    5.  If no path is found, or the primitive does not exist, return an empty list.\n    \"\"\"\n    \n    # State and world information from the environment\n    grid = env._current_state.grid\n    start_pos = env._current_state.pos\n    cookbook = env.world.cookbook\n    WIDTH, HEIGHT, _ = grid.shape\n\n    # Get integer indices for items from the cookbook\n    try:\n        primitive_index = cookbook.index[primitive]\n    except KeyError:\n        return [] # Primitive name is not valid\n\n    workshop_indices = env.world.workshop_indices\n\n    # Define movement actions and their corresponding (dx, dy) grid changes\n    moves = {\n        craft.UP: (0, 1),\n        craft.DOWN: (0, -1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n    # Create a reverse mapping to find the action required to face a given direction\n    direction_to_action = {v: k for k, v in moves.items()}\n\n    # Helper function to determine if a cell is passable for pathfinding.\n    # Based on CraftState.step logic, a cell is passable if it is empty\n    # or contains a workshop. Any other object blocks movement.\n    def is_passable(x, y):\n        if not (0 <= x < WIDTH and 0 <= y < HEIGHT):\n            return False\n        \n        cell = grid[x, y]\n        # An empty cell is passable\n        if cell.sum() == 0:\n            return True\n        \n        # A cell with a workshop is also passable\n        for i_ws in workshop_indices:\n            if cell[i_ws] > 0:\n                return True\n        \n        # Any other non-empty cell is a blocker\n        return False\n\n    # 1. Find all grid locations of the target primitive\n    target_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n    if target_locations.shape[0] == 0:\n        return [] # Primitive does not exist on the map\n\n    # 2. Determine all reachable \"goal\" positions adjacent to the targets\n    # The goal_map stores {goal_pos: target_pos} to know which primitive to face\n    goal_map = {}\n    for tx, ty in target_locations:\n        # Check all four neighbors of the target\n        for move_vec in moves.values():\n            adj_x, adj_y = tx + move_vec[0], ty + move_vec[1]\n            \n            if is_passable(adj_x, adj_y):\n                # The position to stand on is (adj_x, adj_y)\n                # The primitive to face is at (tx, ty)\n                goal_map[(adj_x, adj_y)] = (tx, ty)\n\n    if not goal_map:\n        return [] # No accessible cells next to any instance of the primitive\n\n    # 3. BFS to find the shortest path from the start to any goal position\n    queue = collections.deque([(start_pos, [])]) # (current_position, path_list)\n    visited = {start_pos}\n\n    # Handle the edge case where the agent already starts at a goal position\n    if start_pos in goal_map:\n        final_pos = start_pos\n        target_pos = goal_map[final_pos]\n        \n        # Determine the direction to face the target\n        dx = target_pos[0] - final_pos[0]\n        dy = target_pos[1] - final_pos[1]\n        \n        turn_action = direction_to_action[(dx, dy)]\n        return [turn_action, craft.USE]\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        # Explore neighbors\n        for action, (dx, dy) in moves.items():\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n            if next_pos in visited:\n                continue\n\n            if is_passable(next_pos[0], next_pos[1]):\n                visited.add(next_pos)\n                new_path = path + [action]\n                \n                # 4. Check if the neighbor is a goal position\n                if next_pos in goal_map:\n                    final_pos = next_pos\n                    target_pos = goal_map[final_pos]\n                    \n                    # Determine the final \"move\" to turn the agent towards the target\n                    turn_dx = target_pos[0] - final_pos[0]\n                    turn_dy = target_pos[1] - final_pos[1]\n                    turn_action = direction_to_action[(turn_dx, turn_dy)]\n                    \n                    # Return the complete action sequence\n                    return new_path + [turn_action, craft.USE]\n                \n                # If not a goal, add to the queue to continue the search\n                queue.append((next_pos, new_path))\n    \n    # 5. If the queue becomes empty, no path was found\n    return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates an action sequence to find and collect a specified primitive.\n\n    This function uses a Breadth-First Search (BFS) over the state space of (position, direction)\n    to find the shortest action sequence to a state where the agent is adjacent to and\n    facing the target primitive. It correctly handles obstacles and workshop locations.\n    \"\"\"\n    # Get grid dimensions and key indices from the environment\n    grid = env._current_state.grid\n    width, height, _ = grid.shape\n    primitive_index = env.world.cookbook.index[primitive]\n    \n    # Create a set of workshop indices for efficient lookup\n    workshop_indices = set(env.world.workshop_indices)\n    \n    # Helper function to determine if a grid cell is blocked for pathfinding\n    def is_blocked(x, y):\n        \"\"\"Checks if a cell at (x, y) is impassable.\"\"\"\n        # Check if the cell is outside the grid boundaries\n        if not (0 <= x < width and 0 <= y < height):\n            return True\n        \n        # A cell is blocked if it contains any non-grabbable item that is not a workshop\n        grid_slice = grid[x, y]\n        for kind_index in env.world.non_grabbable_indices:\n            if grid_slice[kind_index] > 0:\n                if kind_index not in workshop_indices:\n                    return True # It's a non-workshop, non-grabbable item -> obstacle\n        return False\n\n    # Find all locations of the target primitive\n    primitive_locs = set(zip(*np.where(grid[:, :, primitive_index] > 0)))\n    if not primitive_locs:\n        return []  # No primitive found on the map, return empty path\n\n    # Mappings for directions and actions. Assumes craft constants (0-3) and agent \n    # direction indices are aligned. The deltas match the coordinate system from feedback.\n    dir_to_delta = {\n        craft.DOWN: (0, -1),\n        craft.UP: (0, 1),\n        craft.LEFT: (-1, 0),\n        craft.RIGHT: (1, 0),\n    }\n    \n    # List of possible move actions\n    move_actions = [craft.DOWN, craft.UP, craft.LEFT, craft.RIGHT]\n\n    # Initialize BFS queue and visited set for the (position, direction) state space\n    start_pos = env._current_state.pos\n    start_dir = env._current_state.dir\n    # The state in the queue is (position, direction, path_of_actions)\n    queue = collections.deque([(start_pos, start_dir, [])])\n    # The visited set stores (position, direction) tuples to avoid cycles\n    visited = set([(start_pos, start_dir)])\n\n    while queue:\n        (x, y), direction, path = queue.popleft()\n\n        # --- GOAL CHECK ---\n        # Check if the agent's current direction points to a cell with the primitive.\n        dx, dy = dir_to_delta[direction]\n        facing_pos = (x + dx, y + dy)\n        if facing_pos in primitive_locs:\n            # If so, the path is complete. Append the USE action and return.\n            return path + [craft.USE]\n\n        # --- EXPLORE NEIGHBORING STATES ---\n        # Explore the result of taking each possible move action from the current position.\n        for action in move_actions:\n            # A move action determines both the new position and the new direction.\n            move_dx, move_dy = dir_to_delta[action]\n            new_pos = (x + move_dx, y + move_dy)\n            new_dir = action  # The agent's direction becomes the direction of the move.\n\n            # Create the new state tuple\n            new_state = (new_pos, new_dir)\n\n            # If the new state hasn't been visited and the destination cell is not blocked,\n            # add it to the queue to explore later.\n            if new_state not in visited and not is_blocked(new_pos[0], new_pos[1]):\n                visited.add(new_state)\n                new_path = path + [action]\n                queue.append((new_pos, new_dir, new_path))\n    \n    return []  # Return an empty list if no path is found\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the\n  shortest path to a state where the agent is adjacent to the target\n  primitive and facing it. The search space is (position, direction),\n  ensuring the final action sequence leaves the agent in the correct\n  orientation to perform the 'USE' action.\n\n  Args:\n      env: The CraftLab environment instance.\n      primitive (str): The name of the primitive to collect.\n\n  Returns:\n      list: A list of integer actions (e.g., [craft.UP, craft.RIGHT, craft.USE])\n            to collect the primitive, or an empty list if it's not possible.\n  \"\"\"\n\n  # --- Constants and Mappings ---\n  # Map direction indices (as used in CraftState.dir) to coordinate deltas (dx, dy).\n  # The Craft environment uses: 0=down, 1=up, 2=left, 3=right for directions.\n  DIR_TO_DELTA = {\n      craft.DOWN: (0, -1),\n      craft.UP: (0, 1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  MOVE_ACTIONS = [craft.DOWN, craft.UP, craft.LEFT, craft.RIGHT]\n\n  # --- Setup ---\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The requested primitive doesn't exist in the world's cookbook.\n    return []\n\n  # Find all locations of the target primitive.\n  target_locations = set(zip(*np.where(grid[:, :, primitive_index] > 0)))\n  if not target_locations:\n    # The primitive does not exist on the current grid.\n    return []\n\n  # --- Helper Function: is_blocked ---\n  _is_blocked_cache = {}\n  workshop_indices = set(world.workshop_indices)\n\n  def is_blocked(pos):\n    x, y = pos\n    if pos in _is_blocked_cache:\n      return _is_blocked_cache[pos]\n\n    # Check grid boundaries.\n    if not (0 <= x < width and 0 <= y < height):\n      _is_blocked_cache[pos] = True\n      return True\n\n    # A cell is blocked if it contains any non-grabbable item (except workshops),\n    # as these are environmental obstacles.\n    for i in world.non_grabbable_indices:\n      if grid[x, y, i] > 0 and i not in workshop_indices:\n        _is_blocked_cache[pos] = True\n        return True\n\n    # Also treat the target primitive itself as an obstacle for pathfinding,\n    # as the agent cannot move onto its cell.\n    if grid[x, y, primitive_index] > 0:\n      _is_blocked_cache[pos] = True\n      return True\n\n    _is_blocked_cache[pos] = False\n    return False\n\n  # --- BFS Initialization ---\n  start_pos = state.pos\n  start_dir = state.dir\n\n  # The queue stores tuples of (current_position, current_direction, path_so_far).\n  queue = collections.deque([(start_pos, start_dir, [])])\n\n  # The visited set stores tuples of (position, direction) to avoid cycles\n  # and redundant exploration of the same state.\n  visited = set([(start_pos, start_dir)])\n\n  # --- BFS Main Loop ---\n  while queue:\n    pos, direction, path = queue.popleft()\n\n    # --- Goal Check ---\n    # Determine which cell the agent is currently facing.\n    dx, dy = DIR_TO_DELTA[direction]\n    facing_pos = (pos[0] + dx, pos[1] + dy)\n\n    # If the facing cell contains the target primitive, the goal is reached.\n    if facing_pos in target_locations:\n      # The agent is at `pos` and facing the primitive. The final action is USE.\n      return path + [craft.USE]\n\n    # --- Explore Neighbors ---\n    # From the current position, try all four possible move actions.\n    for action in MOVE_ACTIONS:\n      # In this environment, taking a move action also sets the new direction.\n      new_dir = action\n      dx, dy = DIR_TO_DELTA[new_dir]\n      new_pos = (pos[0] + dx, pos[1] + dy)\n\n      new_state_tuple = (new_pos, new_dir)\n\n      # Add the new state to the queue if it's unvisited and leads to a valid cell.\n      if new_state_tuple not in visited and not is_blocked(new_pos):\n        visited.add(new_state_tuple)\n        new_path = path + [action]\n        queue.append((new_pos, new_dir, new_path))\n\n  # If the queue becomes empty, it means no path exists to collect the primitive.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to navigate to and collect a specified primitive.\n    The strategy uses Breadth-First Search (BFS) to find the shortest path.\n\n    The core logic is to find a sequence of moves ending in a specific state:\n    1. The agent is at a cell `N` adjacent to the primitive `P`.\n    2. The agent is facing `P`.\n\n    According to the environment's `step` function, a move action (e.g., RIGHT)\n    updates both the agent's position and direction. A subsequent `USE` action\n    operates on the cell in the agent's current direction.\n    \n    This means to collect `P` from cell `N`, the agent's last move must have been\n    the one that moved it to `N` and oriented it towards `P`. For example, to\n    collect a primitive to the right of the agent, the agent's last move must\n    have been `RIGHT`.\n\n    The BFS therefore searches for a path, and at each step of exploration, it\n    checks if the proposed move would place the agent in a position to collect\n    the primitive.\n    \"\"\"\n    world = env.world\n    state = env._current_state\n    grid = state.grid\n    start_pos = state.pos\n    \n    try:\n        primitive_index = world.cookbook.index[primitive]\n    except KeyError:\n        # The requested primitive does not exist in the cookbook.\n        return []\n\n    def is_traversable(pos):\n        \"\"\"Checks if the agent can move onto the given cell.\"\"\"\n        x, y = pos\n        # Check bounds\n        if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n            return False\n        # A cell is traversable if it doesn't contain a non-grabbable, non-workshop item.\n        for kind_index in world.non_grabbable_indices:\n            if grid[x, y, kind_index] > 0:\n                # Workshops are non-grabbable but traversable.\n                if kind_index not in world.workshop_indices:\n                    return False # Blocked by an obstacle\n        return True\n\n    # BFS setup\n    queue = collections.deque([(start_pos, [])])  # Stores (position, path_to_position)\n    visited = {start_pos}\n\n    # Map from move vector (dx, dy) to the corresponding action constant\n    action_map = {\n        (-1, 0): craft.LEFT, (1, 0): craft.RIGHT,\n        (0, -1): craft.DOWN, (0, 1): craft.UP\n    }\n    \n    if not is_traversable(start_pos):\n        return [] # Agent starts in an invalid location\n\n    while queue:\n        curr_pos, path = queue.popleft()\n\n        # Explore neighbors by trying each possible move\n        for (dx, dy), action in action_map.items():\n            # Calculate the position after the move\n            next_pos = (curr_pos[0] + dx, curr_pos[1] + dy)\n\n            if next_pos in visited:\n                continue\n\n            # Check if the agent can move to the next position\n            if is_traversable(next_pos):\n                # If we make this move, the agent will be at `next_pos` and facing\n                # in the direction of the move (dx, dy). A `USE` action would then\n                # target the cell in front of the agent.\n                primitive_target_pos = (next_pos[0] + dx, next_pos[1] + dy)\n\n                # Check if this target cell contains the primitive\n                ptx, pty = primitive_target_pos\n                if (0 <= ptx < grid.shape[0] and 0 <= pty < grid.shape[1] and\n                        grid[ptx, pty, primitive_index] > 0):\n                    \n                    # Success: We found a sequence of moves.\n                    # The path to `curr_pos` is `path`.\n                    # The final move is `action`, which takes us to `next_pos`.\n                    # From `next_pos`, `USE` will collect the primitive.\n                    return path + [action, craft.USE]\n\n                # If this move doesn't lead to collection, add it to the queue\n                # to continue exploring the path.\n                visited.add(next_pos)\n                queue.append((next_pos, path + [action]))\n\n    return [] # No path found to collect the primitive\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n  - Uses Breadth-First Search (BFS) to find the shortest path to a cell adjacent to the primitive.\n  - Ensures the agent is facing the primitive before using the 'USE' action.\n  - Handles turning by moving away and back if necessary.\n  \"\"\"\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n\n  # 1. Preliminaries: Mappings and Helper functions\n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive name is not in the cookbook, cannot be collected.\n    return []\n\n  # Action constants to delta (dx, dy) vectors\n  vec_map = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.RIGHT: (1, 0),\n      craft.LEFT: (-1, 0),\n  }\n  # Delta (dx, dy) vectors to action constants\n  action_map = {v: k for k, v in vec_map.items()}\n  \n  # Opposite actions for turning maneuver\n  opposite_action = {\n      craft.UP: craft.DOWN,\n      craft.DOWN: craft.UP,\n      craft.LEFT: craft.RIGHT,\n      craft.RIGHT: craft.LEFT,\n  }\n  \n  # Get indices for workshops, which are walkable\n  workshop_indices = {\n      world.cookbook.index.get('WORKSHOP0'),\n      world.cookbook.index.get('WORKSHOP1'),\n      world.cookbook.index.get('WORKSHOP2'),\n  }\n  # Filter out None in case some workshops don't exist in the recipe\n  workshop_indices = {idx for idx in workshop_indices if idx is not None}\n\n  def is_blocked(pos):\n    x, y = pos\n    if not (0 <= x < width and 0 <= y < height):\n      return True\n    \n    # An empty cell is not blocked\n    if np.sum(grid[x, y]) == 0:\n      return False\n      \n    # Check if the cell contains anything that is NOT a workshop\n    for i, val in enumerate(grid[x, y]):\n      if val > 0 and i not in workshop_indices:\n        return True # Blocked by a resource, item, or non-workshop structure\n            \n    # If we only found workshops, the cell is walkable and thus not blocked\n    return False\n\n  start_pos = state.pos\n  \n  # 2. Find all target destination cells (valid cells adjacent to the primitive)\n  destinations = set()\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  \n  if primitive_locations.size == 0:\n    return [] # Primitive not found on map\n\n  for prim_pos in primitive_locations:\n    px, py = prim_pos\n    for vec in vec_map.values():\n      adj_pos = (px - vec[0], py - vec[1])\n      if not is_blocked(adj_pos):\n        destinations.add(adj_pos)\n\n  if not destinations:\n    return [] # No accessible cells next to the primitive\n\n  # Handle edge case where agent is already at a destination\n  if start_pos in destinations:\n    path = []\n    final_pos = start_pos\n  else:\n    # 3. BFS to find the shortest path to any destination\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n    path = None\n    final_pos = None\n\n    while queue:\n      current_pos, current_path = queue.popleft()\n\n      if current_pos in destinations:\n        path = current_path\n        final_pos = current_pos\n        break  # Found the shortest path to an adjacent cell\n\n      # Expand to neighbors\n      for vec, action in action_map.items():\n        dx, dy = vec\n        neighbor_pos = (current_pos[0] + dx, current_pos[1] + dy)\n        if neighbor_pos not in visited and not is_blocked(neighbor_pos):\n          visited.add(neighbor_pos)\n          new_path = current_path + [action]\n          queue.append((neighbor_pos, new_path))\n    \n    if path is None:\n      return [] # No path found\n\n  # 4. Construct final action sequence, including turning if needed\n  # Find which primitive location this final_pos is adjacent to\n  target_primitive_pos = None\n  for vec in vec_map.values():\n    check_pos = (final_pos[0] + vec[0], final_pos[1] + vec[1])\n    # Check bounds before indexing grid\n    if (0 <= check_pos[0] < width and 0 <= check_pos[1] < height and\n            grid[check_pos[0], check_pos[1], primitive_index] > 0):\n      target_primitive_pos = check_pos\n      break\n          \n  if target_primitive_pos is None:\n    # This should not happen if destinations were calculated correctly\n    return []\n\n  # Determine the action required to face the primitive from the final position\n  required_vec = (target_primitive_pos[0] - final_pos[0], target_primitive_pos[1] - final_pos[1])\n  face_action = action_map[required_vec]\n\n  # The agent's direction is determined by the last move in the path\n  last_action = path[-1] if path else None\n\n  if last_action == face_action:\n    # Already facing the right way after moving\n    return path + [craft.USE]\n  else:\n    # Agent is not facing the primitive. Perform a turn-in-place maneuver.\n    # This reliably sets the agent's final direction to `face_action`.\n    move_back_action = opposite_action[face_action]\n    return path + [move_back_action, face_action, craft.USE]\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, navigate to, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest \n  path to a cell adjacent to the target primitive. It then ensures the agent \n  is correctly oriented towards the primitive before adding the final 'USE' action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD', 'IRON').\n\n  Returns:\n    A list of action integers representing the plan to collect the primitive,\n    or an empty list if no path is found.\n  \"\"\"\n  # Define mappings for actions, their (dx, dy) effects on a grid, and their opposites.\n  # Assumes a grid where (0,0) is top-left, x increases rightwards (columns), \n  # and y increases downwards (rows).\n  action_to_delta = {\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n      craft.UP: (0, -1),\n      craft.DOWN: (0, 1),\n  }\n  delta_to_action = {v: k for k, v in action_to_delta.items()}\n  inverse_action = {\n      craft.LEFT: craft.RIGHT,\n      craft.RIGHT: craft.LEFT,\n      craft.UP: craft.DOWN,\n      craft.DOWN: craft.UP,\n  }\n\n  # 1. SETUP: Extract necessary information from the environment state.\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n  primitive_index = env.world.cookbook.index[primitive]\n\n  # Helper function to determine if a grid cell is available for pathfinding.\n  # A cell is passable if it's within bounds and doesn't contain a permanent obstacle.\n  # NOTE: This implementation does not handle tool-based obstacle removal (e.g., using an axe on wood).\n  passable_non_grabbable = set(env.world.workshop_indices)\n  def is_passable(x, y):\n      if not (0 <= x < width and 0 <= y < height):\n          return False\n      # A cell is impassable if it contains a non-grabbable item (unless it's a workshop).\n      for kind_idx in env.world.non_grabbable_indices:\n          if grid[x, y, kind_idx] > 0 and kind_idx not in passable_non_grabbable:\n              return False\n      # The agent also cannot move onto a cell that already contains the target resource.\n      if grid[x, y, primitive_index] > 0:\n          return False\n      return True\n\n  # 2. FIND GOAL CELLS: Identify all passable cells adjacent to the target primitive.\n  target_cells = np.argwhere(grid[:, :, primitive_index] > 0)\n  if target_cells.shape[0] == 0:\n      return []  # Primitive does not exist on the map.\n\n  goal_cells = set()\n  # In numpy argwhere, the output is (row, col), which corresponds to (y, x).\n  for y, x in target_cells:\n      for dx, dy in action_to_delta.values():\n          adj_x, adj_y = x + dx, y + dy\n          if is_passable(adj_x, adj_y):\n              goal_cells.add((adj_x, adj_y))\n  \n  if not goal_cells:\n      return []  # Primitive is completely surrounded by impassable obstacles.\n\n  # 3. BFS PATHFINDING: Find the shortest path from the agent to any goal cell.\n  start_pos = state.pos\n  \n  # If agent is already at a valid location, the path is empty.\n  if start_pos in goal_cells:\n      path_to_goal = []\n      final_pos = start_pos\n  else:\n      queue = collections.deque([(start_pos, [])])\n      visited = {start_pos}\n      path_to_goal = None\n      final_pos = None\n\n      while queue:\n          (cx, cy), path = queue.popleft()\n          for action, (dx, dy) in action_to_delta.items():\n              nx, ny = cx + dx, cy + dy\n\n              if (nx, ny) in visited or not is_passable(nx, ny):\n                  continue\n              \n              visited.add((nx, ny))\n              new_path = path + [action]\n\n              if (nx, ny) in goal_cells:\n                  path_to_goal = new_path\n                  final_pos = (nx, ny)\n                  queue.clear() # Found shortest path, terminate BFS.\n                  break\n      \n      if path_to_goal is None:\n          return [] # No path exists to any goal cell.\n\n  # 4. ORIENTATION: Ensure the agent is facing the primitive before collecting.\n  # First, find which specific target cell our final position is adjacent to.\n  target_pos = None\n  for dx, dy in action_to_delta.values():\n      check_x, check_y = final_pos[0] + dx, final_pos[1] + dy\n      if 0 <= check_x < width and 0 <= check_y < height and grid[check_y, check_x, primitive_index] > 0:\n          target_pos = (check_x, check_y)\n          break\n          \n  if not target_pos: \n      # This case should not be reached if goal_cells was constructed correctly.\n      return [] \n\n  # Determine the direction to face and the corresponding final move action.\n  face_dx, face_dy = target_pos[0] - final_pos[0], target_pos[1] - final_pos[1]\n  required_face_action = delta_to_action.get((face_dx, face_dy))\n  \n  # If the agent's last move does not result in the correct orientation, add moves to fix it.\n  if not path_to_goal or path_to_goal[-1] != required_face_action:\n      # Use a simple re-orientation: move one step away from the target, then move back.\n      # This guarantees the last move sets the correct facing direction.\n      reorient_action_1 = inverse_action[required_face_action]\n      reorient_delta = action_to_delta[reorient_action_1]\n      temp_pos = (final_pos[0] + reorient_delta[0], final_pos[1] + reorient_delta[1])\n      \n      # Only perform this maneuver if the temporary cell is passable.\n      if is_passable(temp_pos[0], temp_pos[1]):\n          path_to_goal.append(reorient_action_1)\n          path_to_goal.append(required_face_action)\n  \n  # 5. FINAL ACTION: Add the USE action to collect the primitive.\n  path_to_goal.append(craft.USE)\n\n  return path_to_goal\n",
  "evaluation_result": [
    0.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n  This function uses Breadth-First Search (BFS) to find the shortest path to a\n  cell adjacent to the target primitive. It can also generate plans that involve\n  using tools (like an axe for wood) to clear obstacles if the tool is in the\n  agent's inventory.\n  \"\"\"\n  \n  cookbook = env.world.cookbook\n  state = env._current_state\n  grid = state.grid\n  inventory = state.inventory\n  width, height, _ = grid.shape\n\n  # 1. Setup: Get indices and define mappings\n  try:\n    primitive_idx = cookbook.index[primitive]\n    # Define obstacles that can be cleared with tools\n    tool_for_obstacle = {\n        cookbook.index['WOOD']: cookbook.index['AXE'],\n        cookbook.index['STONE']: cookbook.index['HAMMER'],\n        cookbook.index['ROCK']: cookbook.index['HAMMER'],\n        cookbook.index['GRASS']: cookbook.index['SHEARS'],\n    }\n  except KeyError:\n    # A required item (e.g., the primitive itself or a tool) doesn't exist in this world's recipes.\n    return []\n\n  # Identify non-grabbable items that are passable (e.g., workshops)\n  passable_non_grabbable = set(env.world.workshop_indices)\n\n  # 2. Find all locations of the primitive and define goal positions for BFS\n  # Note: np.argwhere returns coordinates as (row, col), which corresponds to (x, y) for a (WIDTH, HEIGHT) grid.\n  primitive_locs = np.argwhere(grid[:, :, primitive_idx] > 0)\n  if primitive_locs.shape[0] == 0:\n    return [] # Primitive not found on the map\n\n  goal_positions = set()\n  # The goal is to reach any cell adjacent to any instance of the primitive\n  for x, y in primitive_locs:\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n      adj_x, adj_y = x + dx, y + dy\n      # An adjacent cell is a valid goal if it's within bounds and not permanently blocked\n      if 0 <= adj_x < width and 0 <= adj_y < height:\n        is_blocked = False\n        for kind_idx in env.world.non_grabbable_indices:\n            if grid[adj_x, adj_y, kind_idx] > 0 and kind_idx not in passable_non_grabbable:\n                is_blocked = True\n                break\n        if not is_blocked:\n          goal_positions.add((adj_x, adj_y))\n  \n  if not goal_positions:\n    # All adjacent cells are blocked, impossible to collect\n    return []\n\n  # 3. BFS Initialization\n  start_pos_x, start_pos_y = state.pos\n  start_node = ((start_pos_x, start_pos_y), []) # ((x, y), path)\n  queue = collections.deque([start_node])\n  visited = {start_node[0]}\n  \n  # Directions: (dx, dy, action)\n  directions = [\n      (0, -1, craft.DOWN),\n      (0, 1, craft.UP),\n      (-1, 0, craft.LEFT),\n      (1, 0, craft.RIGHT)\n  ]\n\n  # 4. BFS Loop\n  while queue:\n    (x, y), path = queue.popleft()\n\n    # Check for goal completion\n    if (x, y) in goal_positions:\n      # The path leads to a cell adjacent to the primitive. The last move\n      # in the path orients the agent correctly. Append USE to collect.\n      return path + [craft.USE]\n\n    # Explore neighbors\n    for dx, dy, move_action in directions:\n      next_x, next_y = x + dx, y + dy\n\n      if not (0 <= next_x < width and 0 <= next_y < height) or (next_x, next_y) in visited:\n        continue\n\n      # Check what's in the next cell\n      blocking_idx = -1\n      for kind_idx in env.world.non_grabbable_indices:\n        if grid[next_x, next_y, kind_idx] > 0:\n          blocking_idx = kind_idx\n          break\n      \n      # Case 1: The cell is not blocked by a non-grabbable item\n      if blocking_idx == -1:\n        visited.add((next_x, next_y))\n        queue.append(((next_x, next_y), path + [move_action]))\n        continue\n\n      # Case 2: The cell is blocked, check if passable (workshop) or clearable (tool)\n      if blocking_idx in passable_non_grabbable:\n        visited.add((next_x, next_y))\n        queue.append(((next_x, next_y), path + [move_action]))\n      \n      elif blocking_idx in tool_for_obstacle and inventory[tool_for_obstacle[blocking_idx]] > 0:\n        # Obstacle can be cleared. Sequence: turn toward, use tool, move forward.\n        # A move action into a blocked cell turns the agent to face it.\n        # The second move action moves into the now-clear cell.\n        actions_to_clear = [move_action, craft.USE, move_action]\n        visited.add((next_x, next_y))\n        queue.append(((next_x, next_y), path + actions_to_clear))\n  \n  return [] # No path found\n",
  "evaluation_result": [
    2.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses Breadth-First Search (BFS) to find the shortest path to a\n  cell adjacent to the target primitive. It then constructs the full action\n  sequence required to move to that cell, face the primitive, and collect it.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of integer actions (e.g., [craft.UP, craft.RIGHT, craft.USE])\n    to collect the primitive, or an empty list if it's unreachable.\n  \"\"\"\n  # 1. Initialization and Setup\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    return []  # Primitive name not found in the cookbook\n\n  grid = env._current_state.grid\n  width, height, _ = grid.shape\n  start_pos = env._current_state.pos\n\n  # 2. Define what constitutes a traversable cell.\n  # Obstacles are non-grabbable items, excluding workshops which are walkable.\n  workshop_indices = set(env.world.workshop_indices)\n  non_grabbable = env.world.non_grabbable_indices\n  obstacles = non_grabbable - workshop_indices\n\n  def is_traversable(x, y):\n    \"\"\"Checks if a cell at (x, y) can be moved onto.\"\"\"\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    # A cell is not traversable if it contains a true obstacle.\n    for kind_index in obstacles:\n      if grid[x, y, kind_index] > 0:\n        return False\n    return True\n\n  # Define movement directions and their corresponding action constants\n  action_map = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (1, 0): craft.RIGHT,\n      (-1, 0): craft.LEFT\n  }\n  directions = list(action_map.keys())\n\n  # 3. Breadth-First Search (BFS)\n  # The queue stores tuples of ((x, y), path_of_actions)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  # If the agent starts at the destination, the path is empty.\n  if not is_traversable(*start_pos):\n    # This case might happen if the agent starts on a primitive.\n    # It's an invalid state for collection, so we can't proceed.\n    return []\n\n  while queue:\n    (x, y), path = queue.popleft()\n\n    # GOAL CHECK: Is the current cell (x, y) adjacent to the primitive?\n    # If so, we have found the shortest path to a collection point.\n    for p_dx, p_dy in directions:\n      primitive_x, primitive_y = x + p_dx, y + p_dy\n      if 0 <= primitive_x < width and 0 <= primitive_y < height:\n        if grid[primitive_x, primitive_y, primitive_index] > 0:\n          # Path found. Now, determine the final actions.\n          # The agent needs to face the primitive and then use the USE action.\n          face_action = action_map[(p_dx, p_dy)]\n          return path + [face_action, craft.USE]\n\n    # EXPAND SEARCH: If not at a goal, explore neighbors.\n    for dx, dy in directions:\n      next_x, next_y = x + dx, y + dy\n\n      if (next_x, next_y) not in visited and is_traversable(next_x, next_y):\n        visited.add((next_x, next_y))\n        move_action = action_map[(dx, dy)]\n        new_path = path + [move_action]\n        queue.append(((next_x, next_y), new_path))\n\n  # 4. If the queue becomes empty, no path to the primitive exists.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move next to, face, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a valid cell adjacent to the desired primitive. A cell is considered\n  valid for pathfinding if it is not an obstacle (like stone or water), not another\n  resource, and not the target primitive itself. The agent must stand on a valid\n  (e.g., empty or workshop) cell to collect from an adjacent one.\n\n  The returned action sequence consists of three parts:\n  1. A path of move actions to navigate to the cell adjacent to the primitive.\n  2. A single move action directed at the primitive. This serves to turn the\n     agent to face the primitive, as moving into a blocked cell is assumed to\n     only change the agent's direction.\n  3. The USE action to collect the primitive.\n\n  Args:\n    env: The current environment instance, providing access to the agent's state\n         and world information.\n    primitive: The string name of the primitive to collect (e.g., \"WOOD\").\n\n  Returns:\n    A list of integer actions to be executed in sequence to collect the\n    primitive, or an empty list if the primitive is not found or is unreachable.\n  \"\"\"\n  state = env._current_state\n  world = env.world\n  grid = state.grid\n  cookbook = world.cookbook\n\n  primitive_index = cookbook.index[primitive]\n  if primitive_index is None:\n      return []\n\n  # Define movement actions and their vector representations\n  moves = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  action_map = {v: k for k, v in moves.items()}\n\n  # Define what constitutes a \"visitable\" cell for pathfinding.\n  # A cell is visitable if it doesn't contain a resource or a blocking obstacle.\n  # Workshops are non-grabbable but are visitable.\n  grabbable_indices = set(world.grabbable_indices)\n  obstacle_indices = world.non_grabbable_indices - set(world.workshop_indices)\n\n  def is_visitable(pos):\n      x, y = pos\n      if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n          return False\n      \n      cell_vector = grid[x, y]\n      # A cell is blocked if it contains any grabbable resource.\n      if any(cell_vector[k] > 0 for k in grabbable_indices):\n          return False\n      # A cell is also blocked if it contains a non-workshop, non-grabbable item.\n      if any(cell_vector[k] > 0 for k in obstacle_indices):\n          return False\n      \n      return True\n\n  # Find all locations of the target primitive.\n  primitive_locs = np.argwhere(grid[:, :, primitive_index] > 0)\n  if not primitive_locs.any():\n      return []\n\n  # Identify all valid destination cells for the BFS. A destination is a\n  # visitable cell adjacent to a primitive.\n  dest_map = {}  # Maps {adjacent_cell: primitive_cell}\n  for loc in primitive_locs:\n      px, py = loc\n      for move_vec in moves.values():\n          adj_pos = (px - move_vec[0], py - move_vec[1])\n          if is_visitable(adj_pos):\n              dest_map[adj_pos] = tuple(loc)\n\n  if not dest_map:\n      return []\n\n  # Perform BFS to find the shortest path to a destination cell.\n  start_pos = tuple(state.pos)\n  \n  if start_pos in dest_map:\n      path = []\n      found_dest = start_pos\n  else:\n      queue = collections.deque([(start_pos, [])])\n      visited = {start_pos}\n      path = None\n      found_dest = None\n\n      while queue:\n          curr_pos, curr_path = queue.popleft()\n\n          for action, move_vec in moves.items():\n              next_pos = (curr_pos[0] + move_vec[0], curr_pos[1] + move_vec[1])\n\n              if next_pos in dest_map:\n                  path = curr_path + [action]\n                  found_dest = next_pos\n                  queue.clear()\n                  break\n              \n              if next_pos not in visited and is_visitable(next_pos):\n                  visited.add(next_pos)\n                  queue.append((next_pos, curr_path + [action]))\n          \n          if found_dest:\n              break\n\n  if found_dest is not None:\n      primitive_pos = dest_map[found_dest]\n      # Determine the action required to face the primitive from the adjacent cell.\n      face_vec = (primitive_pos[0] - found_dest[0], primitive_pos[1] - found_dest[1])\n      face_action = action_map[face_vec]\n\n      # Final sequence: path to move adjacent, action to face, then USE.\n      return path + [face_action, craft.USE]\n\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path to a state where the agent can collect the primitive. The core logic is:\n  1. Identify all locations of the target primitive.\n  2. For each primitive, determine the valid adjacent cells an agent can stand on.\n  3. For each valid adjacent cell, calculate the \"pre-adjacent\" cell. A move\n     from the pre-adjacent cell to the adjacent cell will leave the agent\n     correctly facing the primitive.\n  4. The BFS then searches for the shortest path from the agent's current\n     position to any of these pre-adjacent cells.\n  5. Once a path to a pre-adjacent cell is found, the final action to move to\n     the adjacent cell and the 'USE' action are appended to complete the sequence.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of action integers representing the shortest plan to collect the\n    primitive, or an empty list if it's not possible.\n  \"\"\"\n  grid = env._current_state.grid\n  WIDTH, HEIGHT, _ = grid.shape\n  cookbook = env.world.cookbook\n  \n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    # Primitive does not exist in the world's cookbook\n    return []\n\n  non_grabbable = env.world.non_grabbable_indices\n  workshops = {\n      cookbook.index['WORKSHOP0'],\n      cookbook.index['WORKSHOP1'],\n      cookbook.index['WORKSHOP2']\n  }\n\n  def is_blocked(pos):\n    \"\"\"Checks if a grid cell is impassable.\"\"\"\n    x, y = pos\n    # A cell is blocked if it contains any non-grabbable item that is not a workshop.\n    for kind_idx in non_grabbable:\n        if grid[x, y, kind_idx] > 0 and kind_idx not in workshops:\n            return True\n    return False\n\n  # Define movement directions and their corresponding actions\n  directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # UP, DOWN, RIGHT, LEFT\n  action_map = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (1, 0): craft.RIGHT,\n      (-1, 0): craft.LEFT\n  }\n\n  # --- Step 1 & 2: Find all valid \"endgame\" moves ---\n  # endgame_moves maps a \"pre-adjacent\" cell to the final actions needed.\n  # Key: (pre_adj_x, pre_adj_y)\n  # Value: [action_to_move_to_adj_cell, USE_action]\n  endgame_moves = {}\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  for prim_pos in primitive_locations:\n    px, py = prim_pos\n    for dx, dy in directions:\n      adj_pos = (px - dx, py - dy) # Cell adjacent to the primitive\n      \n      # Check if adjacent cell is valid (in bounds and not blocked)\n      if 0 <= adj_pos[0] < WIDTH and 0 <= adj_pos[1] < HEIGHT and not is_blocked(adj_pos):\n        # The move from adj_pos towards prim_pos sets the correct direction.\n        # The agent must arrive at adj_pos with this move.\n        # Therefore, the BFS must find a path to the cell *before* adj_pos.\n        pre_adj_pos = (adj_pos[0] - dx, adj_pos[1] - dy)\n        \n        # Check if pre-adjacent cell is valid\n        if 0 <= pre_adj_pos[0] < WIDTH and 0 <= pre_adj_pos[1] < HEIGHT and not is_blocked(pre_adj_pos):\n          final_move_action = action_map[(dx, dy)]\n          endgame_moves[adj_pos] = [final_move_action, craft.USE]\n\n  if not endgame_moves:\n    return [] # No accessible primitives\n\n  # --- Step 3: BFS to find shortest path to a valid adjacent cell ---\n  start_pos = env._current_state.pos\n  \n  # Edge case: If already at a location ready for the final move.\n  if start_pos in endgame_moves:\n      return endgame_moves[start_pos]\n\n  queue = collections.deque([(start_pos, [])]) # (position, path_to_position)\n  visited = {start_pos}\n\n  while queue:\n    current_pos, path = queue.popleft()\n\n    for dx, dy in directions:\n      move_action = action_map[(dx, dy)]\n      next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n\n      if not (0 <= next_pos[0] < WIDTH and 0 <= next_pos[1] < HEIGHT):\n        continue\n      if next_pos in visited:\n        continue\n      if is_blocked(next_pos):\n        continue\n      \n      # --- Step 4: Check for Goal Condition ---\n      if next_pos in endgame_moves:\n        # Found a path to a cell from which the final sequence can be executed\n        final_path = path + [move_action] + endgame_moves[next_pos]\n        return final_path\n      \n      visited.add(next_pos)\n      new_path = path + [move_action]\n      queue.append((next_pos, new_path))\n      \n  return [] # No path found\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find, move adjacent to, face, and collect a primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest \n  path to a cell adjacent to the desired primitive. It then calculates the \n  necessary action to face the primitive and an action to collect it.\n\n  The strategy relies on a key assumption about the game mechanics: attempting to\n  move into a blocked cell (like one containing a resource) results in the agent\n  turning to face that direction without changing its position.\n  \"\"\"\n  # 1. SETUP: Extract state information and define constants\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  start_pos = state.pos\n  \n  try:\n    primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n    # The specified primitive name is not valid\n    return []\n\n  # Mapping from action constants to (dx, dy) position deltas (x, y)\n  action_to_delta = {\n      craft.UP: (0, 1),\n      craft.DOWN: (0, -1),\n      craft.LEFT: (-1, 0),\n      craft.RIGHT: (1, 0),\n  }\n  # Reverse mapping from deltas to actions, used for the final facing turn\n  delta_to_action = {v: k for k, v in action_to_delta.items()}\n  \n  # For efficient lookups\n  workshop_indices_set = set(world.workshop_indices)\n\n  # 2. HELPER FUNCTION: Determines if a grid cell is passable\n  def is_passable(x, y):\n    \"\"\"Checks if the agent can move onto the cell at (x, y).\"\"\"\n    # Check grid bounds\n    if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n      return False\n    \n    # Identify all types of items in the cell\n    present_indices = set(np.where(grid[x, y] > 0)[0])\n\n    if not present_indices:\n      return True  # Empty cell is always passable\n    \n    # A cell is passable only if every item in it is a workshop\n    return present_indices.issubset(workshop_indices_set)\n\n  # 3. FIND GOAL POSITIONS: Find all passable cells adjacent to the primitive\n  goal_to_target_map = {}\n  # Find all locations of the target primitive\n  primitive_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n\n  if primitive_locations.shape[0] == 0:\n    return [] # Primitive does not exist on the map\n\n  for loc in primitive_locations:\n    tx, ty = loc[0], loc[1]\n    # Check all four neighbors of the primitive's location\n    for _, (dx, dy) in action_to_delta.items():\n      # (gx, gy) is a potential standing position (goal) to collect from\n      gx, gy = tx - dx, ty - dy\n      if is_passable(gx, gy):\n        # Store the mapping from the valid standing spot to the target resource\n        if (gx, gy) not in goal_to_target_map:\n          goal_to_target_map[(gx, gy)] = (tx, ty)\n\n  if not goal_to_target_map:\n    return [] # No accessible locations to collect the primitive from\n\n  # Handle the edge case where the agent already starts at a goal position\n  if start_pos in goal_to_target_map:\n    target_pos = goal_to_target_map[start_pos]\n    dx = target_pos[0] - start_pos[0]\n    dy = target_pos[1] - start_pos[1]\n    face_action = delta_to_action.get((dx, dy))\n    if face_action is not None:\n      return [face_action, craft.USE]\n    return []\n\n  # 4. BFS: Find the shortest path from start to any goal position\n  queue = collections.deque([(start_pos, [])]) # (position, list_of_actions)\n  visited = {start_pos}\n\n  while queue:\n    (curr_x, curr_y), path = queue.popleft()\n\n    # Explore neighbors\n    for action, (dx, dy) in action_to_delta.items():\n      next_pos = (curr_x + dx, curr_y + dy)\n\n      if next_pos in visited or not is_passable(next_pos[0], next_pos[1]):\n        continue\n      \n      visited.add(next_pos)\n      new_path = path + [action]\n\n      # Check if this neighbor is a goal position\n      if next_pos in goal_to_target_map:\n        # 5. CONSTRUCT FINAL ACTION LIST\n        # A shortest path to a valid collection spot has been found.\n        target_pos = goal_to_target_map[next_pos]\n        \n        # Determine the direction to face from the destination to the primitive\n        face_dx = target_pos[0] - next_pos[0]\n        face_dy = target_pos[1] - next_pos[1]\n        face_action = delta_to_action.get((face_dx, face_dy))\n        \n        # Check if the agent is already facing the correct direction after its last move\n        last_move_delta = (dx, dy)\n        required_face_delta = (face_dx, face_dy)\n\n        actions_to_take = new_path\n        if last_move_delta != required_face_delta and face_action is not None:\n          # If not facing the right way, add a turn action\n          actions_to_take.append(face_action)\n        \n        actions_to_take.append(craft.USE)\n        return actions_to_take\n      \n      # If not a goal, add the new state to the queue to continue searching\n      queue.append((next_pos, new_path))\n      \n  # 6. NO PATH FOUND\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "    \"\"\"\n    Generates a sequence of actions to find and collect a specified primitive.\n\n    This function uses Breadth-First Search (BFS) to find the shortest path\n    to a cell adjacent to the target primitive. It handles obstacles correctly,\n    recognizing that non-grabbable items (except workshops) block movement.\n\n    The final action sequence will navigate the agent to the adjacent cell,\n    turn it to face the primitive, and then collect it with the USE action.\n\n    Args:\n        env: The CraftLab environment instance.\n        primitive: The string name of the primitive to collect (e.g., \"WOOD\", \"IRON\").\n\n    Returns:\n        A list of action integers representing the plan, or an empty list\n        if the primitive cannot be reached.\n    \"\"\"\n    cookbook = env.world.cookbook\n    state = env._current_state\n\n    # Return empty list if the primitive name is not valid\n    if primitive not in cookbook.index.contents:\n        return []\n    primitive_index = cookbook.index[primitive]\n\n    start_pos = state.pos\n    grid = state.grid\n    width, height, _ = grid.shape\n\n    # Pre-calculate workshop indices to identify passable non-grabbable cells\n    workshop_indices = {\n        cookbook.index.get(name) for name in ['WORKSHOP0', 'WORKSHOP1', 'WORKSHOP2']\n    }\n    workshop_indices.discard(None)  # Remove None if a workshop type doesn't exist\n\n    def is_blocked(x, y):\n        \"\"\"\n        Checks if a cell is blocked. A cell is blocked if it contains a\n        non-grabbable item that is not a workshop.\n        \"\"\"\n        for i_kind in env.world.non_grabbable_indices:\n            if grid[x, y, i_kind] > 0 and i_kind not in workshop_indices:\n                return True\n        return False\n\n    # BFS setup: queue stores tuples of ((x, y), path_to_xy)\n    queue = collections.deque([(start_pos, [])])\n    visited = {start_pos}\n\n    # Map from (dx, dy) delta to the corresponding action constant.\n    # Assumes a coordinate system where y increases upwards.\n    action_for_delta = {\n        (0, 1): craft.UP,\n        (0, -1): craft.DOWN,\n        (-1, 0): craft.LEFT,\n        (1, 0): craft.RIGHT,\n    }\n\n    while queue:\n        (x, y), path = queue.popleft()\n\n        # Explore neighbors of the current cell\n        for (dx, dy), action in action_for_delta.items():\n            adj_x, adj_y = x + dx, y + dy\n            adj_pos = (adj_x, adj_y)\n\n            # Check if the neighbor is out of the grid bounds\n            if not (0 <= adj_x < width and 0 <= adj_y < height):\n                continue\n\n            # GOAL CONDITION: Is the adjacent cell the primitive we are looking for?\n            if grid[adj_x, adj_y, primitive_index] > 0:\n                # Path to the current adjacent cell (x, y) is `path`.\n                # To collect, we face the primitive and then use. The 'action'\n                # command will turn the agent to face the blocked primitive cell.\n                return path + [action, craft.USE]\n\n            # TRAVERSAL: If the adjacent cell is not the goal, check if we can move into it.\n            if adj_pos not in visited and not is_blocked(adj_x, adj_y):\n                visited.add(adj_pos)\n                new_path = path + [action]\n                queue.append((adj_pos, new_path))\n    \n    # If the queue is exhausted, no path was found\n    return []\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to a primitive, clear any obstacles\n  with the correct tools if necessary, and collect the primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest\n  path in terms of actions. The BFS is adapted to handle dynamic obstacles that\n  can be cleared with tools from the agent's inventory.\n\n  The state for the BFS is a tuple: (position, path), where 'path' is the\n  list of actions to reach the 'position'.\n  \"\"\"\n  \n  # 1. Initialization and Setup from the environment\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  inventory = state.inventory\n  width, height, _ = grid.shape\n  \n  # Get integer indices for items from their string names using the cookbook\n  primitive_index = world.cookbook.index[primitive]\n  \n  # Define mappings for movement directions to action constants\n  delta_to_action = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT,\n  }\n  \n  # Define obstacles and the tools required to clear them.\n  # This map can be extended if more tool-obstacle pairs exist.\n  obstacle_tool_map = {}\n  if 'WOOD' in world.cookbook.index and 'AXE' in world.cookbook.index:\n      obstacle_tool_map[world.cookbook.index['WOOD']] = world.cookbook.index['AXE']\n  \n  # Pre-calculate indices of impassable terrain. An entity is impassable if it's\n  # non-grabbable and not a functional workshop that can be stood on.\n  non_grabbable_indices = world.non_grabbable_indices\n  workshop_indices = {world.cookbook.index.get(f'WORKSHOP{i}') for i in range(3)}\n  \n  # 2. BFS Setup\n  start_pos = state.pos\n  # The queue stores tuples of (position, path_to_position)\n  queue = collections.deque([(start_pos, [])])\n  # The visited set stores positions to avoid cycles and redundant computations\n  visited = {start_pos}\n\n  # 3. Main BFS Loop\n  while queue:\n    pos, path = queue.popleft()\n    x, y = pos\n    \n    # 4. Explore Neighbors\n    for (dx, dy), action in delta_to_action.items():\n      nx, ny = x + dx, y + dy\n      next_pos = (nx, ny)\n      \n      # Ignore positions that are out of bounds or already visited\n      if not (0 <= nx < width and 0 <= ny < height) or next_pos in visited:\n        continue\n        \n      # --- Goal Condition ---\n      # Case 1: The adjacent cell contains the target primitive.\n      # The path found leads to (x, y). The 'action' faces the primitive.\n      # The 'USE' action then collects it. This is the successful exit.\n      if grid[nx, ny, primitive_index] > 0:\n        return path + [action, craft.USE]\n      \n      # --- Obstacle Handling ---\n      # Case 2: The adjacent cell is a clearable obstacle and we have the tool.\n      is_clearable = False\n      for obstacle_idx, tool_idx in obstacle_tool_map.items():\n        if grid[nx, ny, obstacle_idx] > 0 and inventory[tool_idx] > 0:\n          # The sequence to clear and move is: face, use tool, move forward.\n          extended_path = path + [action, craft.USE, action]\n          queue.append((next_pos, extended_path))\n          visited.add(next_pos)\n          is_clearable = True\n          break\n      \n      if is_clearable:\n        continue # Neighbor handled, move to the next one\n        \n      # --- Standard Movement ---\n      # Case 3: Check if the cell is impassable.\n      is_impassable = False\n      for kind_idx in non_grabbable_indices:\n        if grid[nx, ny, kind_idx] > 0 and kind_idx not in workshop_indices:\n          is_impassable = True\n          break\n          \n      if not is_impassable:\n        # If not impassable, it's a valid cell (empty or workshop) to move into.\n        visited.add(next_pos)\n        queue.append((next_pos, path + [action]))\n        \n  # 5. No Path Found\n  # If the queue is exhausted and the goal was not reached, return an empty list.\n  return []\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of integer actions to be executed, or an empty list if the\n    primitive is not found or is unreachable.\n  \"\"\"\n  world = env.world\n  state = env._current_state\n  cookbook = world.cookbook\n  grid = state.grid\n\n  # 1. Get the integer index for the primitive from the cookbook\n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    return [] # Primitive name is not valid\n\n  # Precompute a set of workshop indices for efficient checking\n  workshop_indices = set(world.workshop_indices)\n\n  def is_blocked(x, y):\n    \"\"\"\n    Helper function to determine if a grid cell is traversable.\n    A cell is blocked if it's out of bounds or contains a non-grabbable\n    item that is not a workshop.\n    \"\"\"\n    # Check if out of bounds\n    if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n      return True\n    \n    # Check for non-grabbable items that block movement\n    for i in world.non_grabbable_indices:\n      if i in workshop_indices:\n        continue # Workshops are non-grabbable but not obstacles\n      if grid[x, y, i] > 0:\n        return True\n    return False\n\n  # 2. Find all locations of the target primitive and identify adjacent,\n  #    walkable \"goal\" cells for the pathfinding algorithm.\n  target_locations = np.argwhere(grid[:, :, primitive_index] > 0)\n  if target_locations.shape[0] == 0:\n    return [] # Primitive does not exist on the map\n\n  # Map (dx, dy) tuples to the corresponding move actions\n  # Based on feedback samples: +y is UP, +x is RIGHT\n  moves = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT\n  }\n  \n  goal_positions = set()\n  # This map stores which target a goal position is adjacent to, which is\n  # needed to determine the final facing direction.\n  goal_to_target_map = {}\n\n  for tx, ty in target_locations:\n    # Check all four neighbors of the target\n    for move_vec, action in moves.items():\n      # The adjacent cell is at (target - move_vector)\n      gx, gy = tx - move_vec[0], ty - move_vec[1]\n      \n      if not is_blocked(gx, gy):\n        goal_positions.add((gx, gy))\n        goal_to_target_map[(gx, gy)] = (tx, ty)\n  \n  if not goal_positions:\n    return [] # No accessible cells next to any instance of the primitive\n\n  # 3. Use Breadth-First Search (BFS) to find the shortest path\n  start_pos = state.pos\n  \n  # Edge case: agent already starts at a goal position\n  if start_pos in goal_positions:\n    target_x, target_y = goal_to_target_map[start_pos]\n    face_dx, face_dy = target_x - start_pos[0], target_y - start_pos[1]\n    face_action = moves[(face_dx, face_dy)]\n    return [face_action, craft.USE]\n\n  queue = collections.deque([(start_pos, [])]) # Stores ((x, y), path_list)\n  visited = {start_pos}\n\n  while queue:\n    (cx, cy), path = queue.popleft()\n\n    for (dx, dy), action in moves.items():\n      nx, ny = cx + dx, cy + dy\n      neighbor_pos = (nx, ny)\n\n      if neighbor_pos in visited or is_blocked(nx, ny):\n        continue\n\n      new_path = path + [action]\n      \n      # Check if we have reached a goal position\n      if neighbor_pos in goal_positions:\n        # We found the shortest path.\n        # The agent is now at `neighbor_pos`.\n        target_pos = goal_to_target_map[neighbor_pos]\n        \n        # Determine the direction from the agent to the target primitive\n        face_dx = target_pos[0] - neighbor_pos[0]\n        face_dy = target_pos[1] - neighbor_pos[1]\n        \n        # Find the action that corresponds to turning to face that direction\n        face_action = moves[(face_dx, face_dy)]\n        \n        # The full sequence is: path to adjacent cell, turn to face, use item.\n        return new_path + [face_action, craft.USE]\n\n      visited.add(neighbor_pos)\n      queue.append((neighbor_pos, new_path))\n      \n  # 4. If the queue empties, no path was found\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a specified primitive.\n\n  This function implements a Breadth-First Search (BFS) to find the shortest\n  path to a cell adjacent to the target primitive. It correctly handles the\n  game's mechanic where attempting to move into a blocked cell (like the one\n  containing the primitive) changes the agent's direction without changing its\n  position. This \"bump-to-turn\" action is used to face the primitive before\n  issuing the 'USE' command.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of integer actions to collect the primitive, or an empty list if\n    it's not possible.\n  \"\"\"\n  world = env.world\n  state = env._current_state\n  grid = state.grid\n  width, height, _ = grid.shape\n\n  # Define movement directions and corresponding actions: (dx, dy, action)\n  directions = [\n      (1, 0, craft.RIGHT),\n      (-1, 0, craft.LEFT),\n      (0, 1, craft.UP),\n      (0, -1, craft.DOWN)\n  ]\n\n  # 1. Look up the integer index for the primitive resource.\n  try:\n      primitive_index = world.cookbook.index[primitive]\n  except KeyError:\n      # The requested primitive does not exist in the game's recipes.\n      return []\n\n  # Memoize workshop indices for quick lookups.\n  workshop_indices = set(world.workshop_indices)\n\n  def is_blocked(x, y):\n      \"\"\"\n      Helper to check if a cell is blocked for pathfinding.\n      A cell is blocked if it contains a non-grabbable entity that is not\n      a traversable workshop.\n      \"\"\"\n      for index in world.non_grabbable_indices:\n          if grid[x, y, index] > 0:\n              if index not in workshop_indices:\n                  return True\n      return False\n\n  # 2. Find all grid locations of the target primitive.\n  target_locations = set()\n  for r in range(width):\n      for c in range(height):\n          if grid[r, c, primitive_index] > 0:\n              target_locations.add((r, c))\n\n  if not target_locations:\n      return []  # Primitive not found on the map.\n\n  # 3. Identify all valid, accessible cells adjacent to the targets.\n  # These are the goal states for our BFS pathfinding.\n  # We map the goal cell to the action required to face the target from that cell.\n  goal_map = {}  # Maps adjacent position -> required turn_action\n  for tx, ty in target_locations:\n      for dx, dy, turn_action in directions:\n          adj_x, adj_y = tx - dx, ty - dy  # The cell to stand in\n          if 0 <= adj_x < width and 0 <= adj_y < height and not is_blocked(adj_x, adj_y):\n              if (adj_x, adj_y) not in goal_map:\n                  goal_map[(adj_x, adj_y)] = turn_action\n  \n  if not goal_map:\n      return []  # No accessible collection points.\n\n  # 4. Perform BFS to find the shortest path to a goal cell.\n  start_pos = state.pos\n\n  # Edge case: Agent is already at a valid collection spot.\n  if start_pos in goal_map:\n      turn_action = goal_map[start_pos]\n      return [turn_action, craft.USE]\n\n  # Initialize BFS queue with (position, path_of_actions)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n      (cx, cy), path = queue.popleft()\n\n      for dx, dy, move_action in directions:\n          nx, ny = cx + dx, cy + dy\n\n          # Check grid bounds and if we've already visited this cell.\n          if not (0 <= nx < width and 0 <= ny < height) or (nx, ny) in visited:\n              continue\n\n          # If the neighbor is a goal position, we have found our path.\n          if (nx, ny) in goal_map:\n              path_to_adjacent = path + [move_action]\n              turn_action = goal_map[(nx, ny)]\n              # Final sequence: move to spot, turn to face, use.\n              return path_to_adjacent + [turn_action, craft.USE]\n\n          # If the neighbor is a valid, non-goal cell, mark and add to queue.\n          if not is_blocked(nx, ny):\n              visited.add((nx, ny))\n              new_path = path + [move_action]\n              queue.append(((nx, ny), new_path))\n\n  # Return an empty list if the queue empties and no path was found.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find and collect a specified primitive.\n\n  This function uses a Breadth-First Search (BFS) algorithm to find the shortest \n  path to a cell adjacent to the target primitive. It correctly handles obstacles\n  in the environment, treating non-grabbable items (except workshops) and other \n  primitives as impassable terrain.\n\n  Once a path to an adjacent cell is found, it appends the necessary actions to \n  face the primitive and then collect it using the 'USE' action.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of integer actions to collect the primitive, or an empty list if \n    the primitive is unreachable.\n  \"\"\"\n  grid = env._current_state.grid\n  width, height, _ = grid.shape\n  start_pos = env._current_state.pos\n\n  # Get the integer index for the target primitive.\n  try:\n    primitive_index = env.world.cookbook.index[primitive]\n  except KeyError:\n    # Primitive name is not in the cookbook, cannot be found.\n    return []\n\n  # Define what constitutes an impassable cell for pathfinding.\n  # An agent cannot be on a cell with a non-grabbable item (like stone or water),\n  # unless that item is a workshop. Primitives are also impassable.\n  workshop_indices = set(env.world.workshop_indices)\n  impassable_indices = (env.world.non_grabbable_indices - workshop_indices) | env.world.cookbook.primitives\n\n  def is_blocked(x, y):\n    \"\"\"Checks if a cell at (x, y) is blocked and cannot be entered.\"\"\"\n    # Check grid boundaries.\n    if not (0 <= x < width and 0 <= y < height):\n      return True\n    # Check if the cell contains any impassable object.\n    for idx in impassable_indices:\n      if grid[x, y, idx] > 0:\n        return True\n    return False\n\n  # Define movement directions and their corresponding action constants.\n  # (dx, dy) format for position updates.\n  directions = [(0, 1), (0, -1), (-1, 0), (1, 0)] \n  action_map = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (-1, 0): craft.LEFT,\n      (1, 0): craft.RIGHT\n  }\n\n  # Initialize BFS queue with (position, path_to_position).\n  queue = collections.deque([(start_pos, [])])\n  # Keep track of visited cells to avoid cycles and redundant work.\n  visited = {start_pos}\n  \n  # If the agent starts on a blocked cell, it cannot move.\n  if is_blocked(start_pos[0], start_pos[1]):\n      return []\n\n  while queue:\n    (current_x, current_y), path = queue.popleft()\n\n    # Explore neighbors of the current cell.\n    for dx, dy in directions:\n      # The position of the neighboring cell.\n      neighbor_x, neighbor_y = current_x + dx, current_y + dy\n\n      # Check if the neighbor is within grid bounds.\n      if not (0 <= neighbor_x < width and 0 <= neighbor_y < height):\n        continue\n      \n      # --- Goal Condition Check ---\n      # If the neighboring cell contains the target primitive, we have found a solution.\n      # The agent is at (current_x, current_y), adjacent to the primitive.\n      if grid[neighbor_x, neighbor_y, primitive_index] > 0:\n        # The path to the adjacent cell is `path`.\n        # The final step is to face the primitive and use the tool.\n        # The move action corresponding to the direction (dx, dy) will turn the agent.\n        # Even if the move is blocked (by the primitive), it will set the agent's facing direction.\n        turn_action = action_map[(dx, dy)]\n        return path + [turn_action, craft.USE]\n\n      # --- Path Expansion ---\n      # If the neighbor is a valid, unvisited, and unblocked cell, add it to the queue.\n      if (neighbor_x, neighbor_y) not in visited and not is_blocked(neighbor_x, neighbor_y):\n        visited.add((neighbor_x, neighbor_y))\n        move_action = action_map[(dx, dy)]\n        new_path = path + [move_action]\n        queue.append(((neighbor_x, neighbor_y), new_path))\n  \n  # If the queue is exhausted and the primitive was not found, return an empty list.\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to find and collect a specified primitive.\n\n  This function uses Breadth-First Search (BFS) to find the shortest path to a\n  cell adjacent to the target primitive. It correctly handles obstacles and\n  traversable workshops. The returned action sequence will navigate the agent\n  next to the primitive, turn to face it, and then collect it.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect.\n\n  Returns:\n    A list of action integers representing the plan, or an empty list if\n    the primitive is unreachable.\n  \"\"\"\n  state = env._current_state\n  world = env.world\n  cookbook = world.cookbook\n  grid = state.grid\n  width, height, _ = grid.shape\n\n  try:\n    primitive_index = cookbook.index[primitive]\n  except KeyError:\n    return [] # Primitive name is not valid\n\n  start_pos = state.pos\n\n  # Map movement deltas (dx, dy) to corresponding action constants\n  action_map = {\n      (0, 1): craft.UP,\n      (0, -1): craft.DOWN,\n      (1, 0): craft.RIGHT,\n      (-1, 0): craft.LEFT\n  }\n  directions = list(action_map.keys())\n\n  # Workshops are special non-grabbable entities that the agent can stand on.\n  workshop_indices = {\n      idx for name, idx in cookbook.index.contents.items() if 'WORKSHOP' in name\n  }\n\n  def is_traversable(x, y):\n    \"\"\"Checks if a cell at (x, y) can be moved onto.\"\"\"\n    # Check if the cell is within the grid boundaries\n    if not (0 <= x < width and 0 <= y < height):\n      return False\n    \n    cell_contents = grid[x, y]\n    # An empty cell is always traversable\n    if np.sum(cell_contents) == 0:\n      return True\n\n    # A cell with a workshop is traversable\n    for ws_idx in workshop_indices:\n      if cell_contents[ws_idx] > 0:\n        return True\n    \n    # Any other non-empty cell is considered an obstacle\n    return False\n\n  # BFS setup\n  queue = collections.deque([(start_pos, [])]) # Each item is (position, path_taken)\n  visited = {start_pos}\n\n  while queue:\n    (current_x, current_y), path = queue.popleft()\n\n    # Goal Test: Check if any adjacent cell contains the primitive\n    for dx, dy in directions:\n      adj_x, adj_y = current_x + dx, current_y + dy\n\n      # Ensure the adjacent cell is within bounds\n      if 0 <= adj_x < width and 0 <= adj_y < height:\n        # If the adjacent cell has the primitive, we have found a solution\n        if grid[adj_x, adj_y, primitive_index] > 0:\n          # The agent is at (current_x, current_y).\n          # The action to face the primitive is the same as moving towards it.\n          face_action = action_map[(dx, dy)]\n          # The full plan is the path to this cell, the facing action, and the use action.\n          return path + [face_action, craft.USE]\n\n    # Expansion: Add valid, unvisited neighbors to the queue\n    for dx, dy in directions:\n      next_pos = (current_x + dx, current_y + dy)\n      \n      if next_pos not in visited and is_traversable(next_pos[0], next_pos[1]):\n        visited.add(next_pos)\n        move_action = action_map[(dx, dy)]\n        new_path = path + [move_action]\n        queue.append((next_pos, new_path))\n        \n  # If the queue is exhausted and no path was found\n  return []\n",
  "evaluation_result": [
    4.0,
    true
  ]
}, 
{
  "extracted_function_code": "  \"\"\"\n  Generates a sequence of actions to navigate to and collect a primitive.\n\n  This function uses Breadth-First Search (BFS) to find the shortest path \n  to a cell adjacent to the target primitive. The search is designed to \n  ensure that upon reaching the adjacent cell, the agent's final move will \n  have oriented it to be facing the primitive, making the subsequent 'USE' \n  action successful.\n\n  Args:\n    env: The CraftLab environment instance.\n    primitive: The string name of the primitive to collect (e.g., 'WOOD').\n\n  Returns:\n    A list of action constants representing the optimal sequence of moves \n    to collect the primitive, or an empty list if it's unreachable.\n  \"\"\"\n  \n  # 1. Setup and Initialization\n  state = env._current_state\n  world = state.world\n  grid = state.grid\n  start_pos = state.pos\n  grid_width, grid_height, _ = grid.shape\n\n  # Get integer indices for relevant items from the cookbook\n  primitive_index = world.cookbook.index[primitive]\n  # Assume up to 3 workshops; a more general solution would parse this\n  workshop_indices = {world.cookbook.index.get(f'WORKSHOP{i}') for i in range(3)}\n  \n  # Obstacles are non-grabbable items that are not workshops\n  obstacle_indices = world.non_grabbable_indices - workshop_indices\n\n  def is_blocked(pos):\n    \"\"\"Checks if a grid cell is an impassable obstacle.\"\"\"\n    x, y = pos\n    if not (0 <= x < grid_width and 0 <= y < grid_height):\n      return True # Out of bounds is blocked\n    \n    # A cell is blocked if it contains any pre-defined obstacle kind\n    for i in obstacle_indices:\n      if grid[x, y, i] > 0:\n        return True\n    return False\n\n  # Define movement directions and their corresponding actions\n  # Using (dx, dy) for (change in x, change in y)\n  directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] \n  action_map = {\n      (0, 1): craft.UP, \n      (0, -1): craft.DOWN, \n      (1, 0): craft.RIGHT, \n      (-1, 0): craft.LEFT\n  }\n\n  # 2. Breadth-First Search (BFS)\n  # The queue stores tuples of (current_position, path_to_get_here)\n  queue = collections.deque([(start_pos, [])])\n  visited = {start_pos}\n\n  while queue:\n    current_pos, path = queue.popleft()\n    curr_x, curr_y = current_pos\n\n    # Explore all possible moves from the current position\n    for dx, dy in directions:\n      move_action = action_map[(dx, dy)]\n      next_pos = (curr_x + dx, curr_y + dy)\n      \n      # Continue pathfinding if the next cell is valid and unvisited\n      if next_pos not in visited and not is_blocked(next_pos):\n        new_path = path + [move_action]\n\n        # --- Goal Condition Check ---\n        # After moving to `next_pos`, the agent will be facing in the\n        # direction of the move (dx, dy). The cell in front of the\n        # agent will be `next_pos + (dx, dy)`.\n        facing_pos_x = next_pos[0] + dx\n        facing_pos_y = next_pos[1] + dy\n\n        # Check if the cell we are now facing is in bounds\n        if 0 <= facing_pos_x < grid_width and 0 <= facing_pos_y < grid_height:\n          # Check if the cell we are facing contains the target primitive\n          if grid[facing_pos_x, facing_pos_y, primitive_index] > 0:\n            # Success! This path leads to the right spot with the right orientation.\n            # The full action sequence is the path to the adjacent cell,\n            # followed by the USE action.\n            return new_path + [craft.USE]\n\n        # If it's not a goal state, add the new position to the queue and visited set\n        visited.add(next_pos)\n        queue.append((next_pos, new_path))\n        \n  # 3. No path found\n  # If the queue is exhausted, the primitive is unreachable\n  return []\n",
  "evaluation_result": [
    -1,
    false
  ]
}, 
